/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["keystore_wdc_contract"] = factory();
	else
		root["keystore_wdc_contract"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./bn.js":
/*!***************!*\
  !*** ./bn.js ***!
  \***************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module.loaded, module.id, module, __webpack_require__.nmd, top-level-this-exports, __webpack_require__.* */
/*! CommonJS bailout: this is used directly at 3506:44-48 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (module, exports) {\n  'use strict'; // Utils\n\n  function assert(val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  } // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n\n\n  function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n\n    var TempCtor = function TempCtor() {};\n\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  } // BN\n\n\n  function BN(number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0; // Reduction context\n\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n\n  if (_typeof(module) === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n  var Buffer;\n\n  try {\n    Buffer = __webpack_require__(/*! buffer */ \"?e7a9\").Buffer;\n  } catch (e) {}\n\n  BN.isBN = function isBN(num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && _typeof(num) === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max(left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min(left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init(number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (_typeof(number) === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n\n    if (number[0] === '-') {\n      start++;\n    }\n\n    if (base === 16) {\n      this._parseHex(number, start);\n    } else {\n      this._parseBase(number, base, start);\n    }\n\n    if (number[0] === '-') {\n      this.negative = 1;\n    }\n\n    this._strip();\n\n    if (endian !== 'le') return;\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initNumber = function _initNumber(number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n\n      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return; // Reverse the bytes\n\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray(number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;\n        this.words[j] |= w << off & 0x3ffffff;\n        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n        off += 24;\n\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;\n        this.words[j] |= w << off & 0x3ffffff;\n        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n        off += 24;\n\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n\n    return this._strip();\n  };\n\n  function parseHex(str, start, end) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    var z = 0;\n\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n      r <<= 4;\n      var b; // 'a' - 'f'\n\n      if (c >= 49 && c <= 54) {\n        b = c - 49 + 0xa; // 'A' - 'F'\n      } else if (c >= 17 && c <= 22) {\n        b = c - 17 + 0xa; // '0' - '9'\n      } else {\n        b = c;\n      }\n\n      r |= b;\n      z |= b;\n    }\n\n    assert(!(z & 0xf0), 'Invalid character in ' + str);\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex(number, start) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w; // Scan 24-bit chunks and add them to the number\n\n    var off = 0;\n\n    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n      w = parseHex(number, i, i + 6);\n      this.words[j] |= w << off & 0x3ffffff; // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n\n      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;\n      off += 24;\n\n      if (off >= 26) {\n        off -= 26;\n        j++;\n      }\n    }\n\n    if (i + 6 !== start) {\n      w = parseHex(number, start, i + 6);\n      this.words[j] |= w << off & 0x3ffffff;\n      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;\n    }\n\n    this._strip();\n  };\n\n  function parseBase(str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n      r *= mul; // 'a'\n\n      if (c >= 49) {\n        b = c - 49 + 0xa; // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa; // '0' - '9'\n      } else {\n        b = c;\n      }\n\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase(number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1; // Find length of limb in base\n\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n\n    limbLen--;\n    limbPow = limbPow / base | 0;\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n    var word = 0;\n\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n      this.imuln(limbPow);\n\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n  };\n\n  BN.prototype.copy = function copy(dest) {\n    dest.words = new Array(this.length);\n\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype._move = function _move(dest) {\n    dest.words = this.words;\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone() {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand(size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n\n    return this;\n  }; // Remove leading `0` from `this`\n\n\n  BN.prototype._strip = function strip() {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign() {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect() {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n  /*\n   var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n   var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n   */\n\n\n  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];\n  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];\n  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];\n\n  BN.prototype.toString = function toString(base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n    var out;\n\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = ((w << off | carry) & 0xffffff).toString(16);\n        carry = w >>> 24 - off & 0xffffff;\n\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n\n        off += 2;\n\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);\n\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber() {\n    var ret = this.words[0];\n\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + this.words[1] * 0x4000000;\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n\n    return this.negative !== 0 ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON() {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer(endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray(endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this._strip();\n\n    var littleEndian = endian === 'le';\n    var res = allocate(ArrayType, reqLength);\n    var b, i;\n    var q = this.clone();\n\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  var allocate = function allocate(ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n\n    return new ArrayType(size);\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits(w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits(w) {\n      var t = w;\n      var r = 0;\n\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits(w) {\n    // Short-cut\n    if (w === 0) return 26;\n    var t = w;\n    var r = 0;\n\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n\n    return r;\n  }; // Return number of used bits in a BN\n\n\n  BN.prototype.bitLength = function bitLength() {\n    var w = this.words[this.length - 1];\n\n    var hi = this._countBits(w);\n\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray(num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = bit / 26 | 0;\n      var wbit = bit % 26;\n      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;\n    }\n\n    return w;\n  } // Number of trailing zero bits\n\n\n  BN.prototype.zeroBits = function zeroBits() {\n    if (this.isZero()) return 0;\n    var r = 0;\n\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n\n      r += b;\n      if (b !== 26) break;\n    }\n\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength() {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos(width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos(width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg() {\n    return this.negative !== 0;\n  }; // Return negative clone of `this`\n\n\n  BN.prototype.neg = function neg() {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg() {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  }; // Or `num` with `this` in-place\n\n\n  BN.prototype.iuor = function iuor(num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior(num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  }; // Or `num` with `this`\n\n\n  BN.prototype.or = function or(num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor(num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  }; // And `num` with `this` in-place\n\n\n  BN.prototype.iuand = function iuand(num) {\n    // b = min-length(num, this)\n    var b;\n\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand(num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  }; // And `num` with `this`\n\n\n  BN.prototype.and = function and(num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand(num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  }; // Xor `num` with `this` in-place\n\n\n  BN.prototype.iuxor = function iuxor(num) {\n    // a.length > b.length\n    var a;\n    var b;\n\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor(num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  }; // Xor `num` with `this`\n\n\n  BN.prototype.xor = function xor(num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor(num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  }; // Not ``this`` with ``width`` bitwidth\n\n\n  BN.prototype.inotn = function inotn(width) {\n    assert(typeof width === 'number' && width >= 0);\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26; // Extend the buffer with leading zeroes\n\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    } // Handle complete words\n\n\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    } // Handle the residue\n\n\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;\n    } // And remove leading zeroes\n\n\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn(width) {\n    return this.clone().inotn(width);\n  }; // Set `bit` of `this`\n\n\n  BN.prototype.setn = function setn(bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var off = bit / 26 | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | 1 << wbit;\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  }; // Add `num` to `this` in-place\n\n\n  BN.prototype.iadd = function iadd(num) {\n    var r; // negative + positive\n\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign(); // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    } // a.length > b.length\n\n\n    var a, b;\n\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++; // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  }; // Add `num` to `this`\n\n\n  BN.prototype.add = function add(num) {\n    var res;\n\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n    return num.clone().iadd(this);\n  }; // Subtract `num` from `this` in-place\n\n\n  BN.prototype.isub = function isub(num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign(); // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    } // At this point both numbers are positive\n\n\n    var cmp = this.cmp(num); // Optimization - zeroify\n\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    } // a > b\n\n\n    var a, b;\n\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    } // Copy rest of the words\n\n\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  }; // Subtract `num` from `this`\n\n\n  BN.prototype.sub = function sub(num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo(self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = self.length + num.length | 0;\n    out.length = len;\n    len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)\n\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n    var lo = r & 0x3ffffff;\n    var carry = r / 0x4000000 | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += r / 0x4000000 | 0;\n        rword = r & 0x3ffffff;\n      }\n\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  } // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n\n\n  var comb10MulTo = function comb10MulTo(self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = mid + Math.imul(ah0, bl0) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = mid + Math.imul(ah1, bl0) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = lo + Math.imul(al0, bl1) | 0;\n    mid = mid + Math.imul(al0, bh1) | 0;\n    mid = mid + Math.imul(ah0, bl1) | 0;\n    hi = hi + Math.imul(ah0, bh1) | 0;\n    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = mid + Math.imul(ah2, bl0) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = lo + Math.imul(al1, bl1) | 0;\n    mid = mid + Math.imul(al1, bh1) | 0;\n    mid = mid + Math.imul(ah1, bl1) | 0;\n    hi = hi + Math.imul(ah1, bh1) | 0;\n    lo = lo + Math.imul(al0, bl2) | 0;\n    mid = mid + Math.imul(al0, bh2) | 0;\n    mid = mid + Math.imul(ah0, bl2) | 0;\n    hi = hi + Math.imul(ah0, bh2) | 0;\n    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = mid + Math.imul(ah3, bl0) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = lo + Math.imul(al2, bl1) | 0;\n    mid = mid + Math.imul(al2, bh1) | 0;\n    mid = mid + Math.imul(ah2, bl1) | 0;\n    hi = hi + Math.imul(ah2, bh1) | 0;\n    lo = lo + Math.imul(al1, bl2) | 0;\n    mid = mid + Math.imul(al1, bh2) | 0;\n    mid = mid + Math.imul(ah1, bl2) | 0;\n    hi = hi + Math.imul(ah1, bh2) | 0;\n    lo = lo + Math.imul(al0, bl3) | 0;\n    mid = mid + Math.imul(al0, bh3) | 0;\n    mid = mid + Math.imul(ah0, bl3) | 0;\n    hi = hi + Math.imul(ah0, bh3) | 0;\n    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = mid + Math.imul(ah4, bl0) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = lo + Math.imul(al3, bl1) | 0;\n    mid = mid + Math.imul(al3, bh1) | 0;\n    mid = mid + Math.imul(ah3, bl1) | 0;\n    hi = hi + Math.imul(ah3, bh1) | 0;\n    lo = lo + Math.imul(al2, bl2) | 0;\n    mid = mid + Math.imul(al2, bh2) | 0;\n    mid = mid + Math.imul(ah2, bl2) | 0;\n    hi = hi + Math.imul(ah2, bh2) | 0;\n    lo = lo + Math.imul(al1, bl3) | 0;\n    mid = mid + Math.imul(al1, bh3) | 0;\n    mid = mid + Math.imul(ah1, bl3) | 0;\n    hi = hi + Math.imul(ah1, bh3) | 0;\n    lo = lo + Math.imul(al0, bl4) | 0;\n    mid = mid + Math.imul(al0, bh4) | 0;\n    mid = mid + Math.imul(ah0, bl4) | 0;\n    hi = hi + Math.imul(ah0, bh4) | 0;\n    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = mid + Math.imul(ah5, bl0) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = lo + Math.imul(al4, bl1) | 0;\n    mid = mid + Math.imul(al4, bh1) | 0;\n    mid = mid + Math.imul(ah4, bl1) | 0;\n    hi = hi + Math.imul(ah4, bh1) | 0;\n    lo = lo + Math.imul(al3, bl2) | 0;\n    mid = mid + Math.imul(al3, bh2) | 0;\n    mid = mid + Math.imul(ah3, bl2) | 0;\n    hi = hi + Math.imul(ah3, bh2) | 0;\n    lo = lo + Math.imul(al2, bl3) | 0;\n    mid = mid + Math.imul(al2, bh3) | 0;\n    mid = mid + Math.imul(ah2, bl3) | 0;\n    hi = hi + Math.imul(ah2, bh3) | 0;\n    lo = lo + Math.imul(al1, bl4) | 0;\n    mid = mid + Math.imul(al1, bh4) | 0;\n    mid = mid + Math.imul(ah1, bl4) | 0;\n    hi = hi + Math.imul(ah1, bh4) | 0;\n    lo = lo + Math.imul(al0, bl5) | 0;\n    mid = mid + Math.imul(al0, bh5) | 0;\n    mid = mid + Math.imul(ah0, bl5) | 0;\n    hi = hi + Math.imul(ah0, bh5) | 0;\n    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = mid + Math.imul(ah6, bl0) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = lo + Math.imul(al5, bl1) | 0;\n    mid = mid + Math.imul(al5, bh1) | 0;\n    mid = mid + Math.imul(ah5, bl1) | 0;\n    hi = hi + Math.imul(ah5, bh1) | 0;\n    lo = lo + Math.imul(al4, bl2) | 0;\n    mid = mid + Math.imul(al4, bh2) | 0;\n    mid = mid + Math.imul(ah4, bl2) | 0;\n    hi = hi + Math.imul(ah4, bh2) | 0;\n    lo = lo + Math.imul(al3, bl3) | 0;\n    mid = mid + Math.imul(al3, bh3) | 0;\n    mid = mid + Math.imul(ah3, bl3) | 0;\n    hi = hi + Math.imul(ah3, bh3) | 0;\n    lo = lo + Math.imul(al2, bl4) | 0;\n    mid = mid + Math.imul(al2, bh4) | 0;\n    mid = mid + Math.imul(ah2, bl4) | 0;\n    hi = hi + Math.imul(ah2, bh4) | 0;\n    lo = lo + Math.imul(al1, bl5) | 0;\n    mid = mid + Math.imul(al1, bh5) | 0;\n    mid = mid + Math.imul(ah1, bl5) | 0;\n    hi = hi + Math.imul(ah1, bh5) | 0;\n    lo = lo + Math.imul(al0, bl6) | 0;\n    mid = mid + Math.imul(al0, bh6) | 0;\n    mid = mid + Math.imul(ah0, bl6) | 0;\n    hi = hi + Math.imul(ah0, bh6) | 0;\n    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = mid + Math.imul(ah7, bl0) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = lo + Math.imul(al6, bl1) | 0;\n    mid = mid + Math.imul(al6, bh1) | 0;\n    mid = mid + Math.imul(ah6, bl1) | 0;\n    hi = hi + Math.imul(ah6, bh1) | 0;\n    lo = lo + Math.imul(al5, bl2) | 0;\n    mid = mid + Math.imul(al5, bh2) | 0;\n    mid = mid + Math.imul(ah5, bl2) | 0;\n    hi = hi + Math.imul(ah5, bh2) | 0;\n    lo = lo + Math.imul(al4, bl3) | 0;\n    mid = mid + Math.imul(al4, bh3) | 0;\n    mid = mid + Math.imul(ah4, bl3) | 0;\n    hi = hi + Math.imul(ah4, bh3) | 0;\n    lo = lo + Math.imul(al3, bl4) | 0;\n    mid = mid + Math.imul(al3, bh4) | 0;\n    mid = mid + Math.imul(ah3, bl4) | 0;\n    hi = hi + Math.imul(ah3, bh4) | 0;\n    lo = lo + Math.imul(al2, bl5) | 0;\n    mid = mid + Math.imul(al2, bh5) | 0;\n    mid = mid + Math.imul(ah2, bl5) | 0;\n    hi = hi + Math.imul(ah2, bh5) | 0;\n    lo = lo + Math.imul(al1, bl6) | 0;\n    mid = mid + Math.imul(al1, bh6) | 0;\n    mid = mid + Math.imul(ah1, bl6) | 0;\n    hi = hi + Math.imul(ah1, bh6) | 0;\n    lo = lo + Math.imul(al0, bl7) | 0;\n    mid = mid + Math.imul(al0, bh7) | 0;\n    mid = mid + Math.imul(ah0, bl7) | 0;\n    hi = hi + Math.imul(ah0, bh7) | 0;\n    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = mid + Math.imul(ah8, bl0) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = lo + Math.imul(al7, bl1) | 0;\n    mid = mid + Math.imul(al7, bh1) | 0;\n    mid = mid + Math.imul(ah7, bl1) | 0;\n    hi = hi + Math.imul(ah7, bh1) | 0;\n    lo = lo + Math.imul(al6, bl2) | 0;\n    mid = mid + Math.imul(al6, bh2) | 0;\n    mid = mid + Math.imul(ah6, bl2) | 0;\n    hi = hi + Math.imul(ah6, bh2) | 0;\n    lo = lo + Math.imul(al5, bl3) | 0;\n    mid = mid + Math.imul(al5, bh3) | 0;\n    mid = mid + Math.imul(ah5, bl3) | 0;\n    hi = hi + Math.imul(ah5, bh3) | 0;\n    lo = lo + Math.imul(al4, bl4) | 0;\n    mid = mid + Math.imul(al4, bh4) | 0;\n    mid = mid + Math.imul(ah4, bl4) | 0;\n    hi = hi + Math.imul(ah4, bh4) | 0;\n    lo = lo + Math.imul(al3, bl5) | 0;\n    mid = mid + Math.imul(al3, bh5) | 0;\n    mid = mid + Math.imul(ah3, bl5) | 0;\n    hi = hi + Math.imul(ah3, bh5) | 0;\n    lo = lo + Math.imul(al2, bl6) | 0;\n    mid = mid + Math.imul(al2, bh6) | 0;\n    mid = mid + Math.imul(ah2, bl6) | 0;\n    hi = hi + Math.imul(ah2, bh6) | 0;\n    lo = lo + Math.imul(al1, bl7) | 0;\n    mid = mid + Math.imul(al1, bh7) | 0;\n    mid = mid + Math.imul(ah1, bl7) | 0;\n    hi = hi + Math.imul(ah1, bh7) | 0;\n    lo = lo + Math.imul(al0, bl8) | 0;\n    mid = mid + Math.imul(al0, bh8) | 0;\n    mid = mid + Math.imul(ah0, bl8) | 0;\n    hi = hi + Math.imul(ah0, bh8) | 0;\n    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = mid + Math.imul(ah9, bl0) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = lo + Math.imul(al8, bl1) | 0;\n    mid = mid + Math.imul(al8, bh1) | 0;\n    mid = mid + Math.imul(ah8, bl1) | 0;\n    hi = hi + Math.imul(ah8, bh1) | 0;\n    lo = lo + Math.imul(al7, bl2) | 0;\n    mid = mid + Math.imul(al7, bh2) | 0;\n    mid = mid + Math.imul(ah7, bl2) | 0;\n    hi = hi + Math.imul(ah7, bh2) | 0;\n    lo = lo + Math.imul(al6, bl3) | 0;\n    mid = mid + Math.imul(al6, bh3) | 0;\n    mid = mid + Math.imul(ah6, bl3) | 0;\n    hi = hi + Math.imul(ah6, bh3) | 0;\n    lo = lo + Math.imul(al5, bl4) | 0;\n    mid = mid + Math.imul(al5, bh4) | 0;\n    mid = mid + Math.imul(ah5, bl4) | 0;\n    hi = hi + Math.imul(ah5, bh4) | 0;\n    lo = lo + Math.imul(al4, bl5) | 0;\n    mid = mid + Math.imul(al4, bh5) | 0;\n    mid = mid + Math.imul(ah4, bl5) | 0;\n    hi = hi + Math.imul(ah4, bh5) | 0;\n    lo = lo + Math.imul(al3, bl6) | 0;\n    mid = mid + Math.imul(al3, bh6) | 0;\n    mid = mid + Math.imul(ah3, bl6) | 0;\n    hi = hi + Math.imul(ah3, bh6) | 0;\n    lo = lo + Math.imul(al2, bl7) | 0;\n    mid = mid + Math.imul(al2, bh7) | 0;\n    mid = mid + Math.imul(ah2, bl7) | 0;\n    hi = hi + Math.imul(ah2, bh7) | 0;\n    lo = lo + Math.imul(al1, bl8) | 0;\n    mid = mid + Math.imul(al1, bh8) | 0;\n    mid = mid + Math.imul(ah1, bl8) | 0;\n    hi = hi + Math.imul(ah1, bh8) | 0;\n    lo = lo + Math.imul(al0, bl9) | 0;\n    mid = mid + Math.imul(al0, bh9) | 0;\n    mid = mid + Math.imul(ah0, bl9) | 0;\n    hi = hi + Math.imul(ah0, bh9) | 0;\n    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = mid + Math.imul(ah9, bl1) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = lo + Math.imul(al8, bl2) | 0;\n    mid = mid + Math.imul(al8, bh2) | 0;\n    mid = mid + Math.imul(ah8, bl2) | 0;\n    hi = hi + Math.imul(ah8, bh2) | 0;\n    lo = lo + Math.imul(al7, bl3) | 0;\n    mid = mid + Math.imul(al7, bh3) | 0;\n    mid = mid + Math.imul(ah7, bl3) | 0;\n    hi = hi + Math.imul(ah7, bh3) | 0;\n    lo = lo + Math.imul(al6, bl4) | 0;\n    mid = mid + Math.imul(al6, bh4) | 0;\n    mid = mid + Math.imul(ah6, bl4) | 0;\n    hi = hi + Math.imul(ah6, bh4) | 0;\n    lo = lo + Math.imul(al5, bl5) | 0;\n    mid = mid + Math.imul(al5, bh5) | 0;\n    mid = mid + Math.imul(ah5, bl5) | 0;\n    hi = hi + Math.imul(ah5, bh5) | 0;\n    lo = lo + Math.imul(al4, bl6) | 0;\n    mid = mid + Math.imul(al4, bh6) | 0;\n    mid = mid + Math.imul(ah4, bl6) | 0;\n    hi = hi + Math.imul(ah4, bh6) | 0;\n    lo = lo + Math.imul(al3, bl7) | 0;\n    mid = mid + Math.imul(al3, bh7) | 0;\n    mid = mid + Math.imul(ah3, bl7) | 0;\n    hi = hi + Math.imul(ah3, bh7) | 0;\n    lo = lo + Math.imul(al2, bl8) | 0;\n    mid = mid + Math.imul(al2, bh8) | 0;\n    mid = mid + Math.imul(ah2, bl8) | 0;\n    hi = hi + Math.imul(ah2, bh8) | 0;\n    lo = lo + Math.imul(al1, bl9) | 0;\n    mid = mid + Math.imul(al1, bh9) | 0;\n    mid = mid + Math.imul(ah1, bl9) | 0;\n    hi = hi + Math.imul(ah1, bh9) | 0;\n    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = mid + Math.imul(ah9, bl2) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = lo + Math.imul(al8, bl3) | 0;\n    mid = mid + Math.imul(al8, bh3) | 0;\n    mid = mid + Math.imul(ah8, bl3) | 0;\n    hi = hi + Math.imul(ah8, bh3) | 0;\n    lo = lo + Math.imul(al7, bl4) | 0;\n    mid = mid + Math.imul(al7, bh4) | 0;\n    mid = mid + Math.imul(ah7, bl4) | 0;\n    hi = hi + Math.imul(ah7, bh4) | 0;\n    lo = lo + Math.imul(al6, bl5) | 0;\n    mid = mid + Math.imul(al6, bh5) | 0;\n    mid = mid + Math.imul(ah6, bl5) | 0;\n    hi = hi + Math.imul(ah6, bh5) | 0;\n    lo = lo + Math.imul(al5, bl6) | 0;\n    mid = mid + Math.imul(al5, bh6) | 0;\n    mid = mid + Math.imul(ah5, bl6) | 0;\n    hi = hi + Math.imul(ah5, bh6) | 0;\n    lo = lo + Math.imul(al4, bl7) | 0;\n    mid = mid + Math.imul(al4, bh7) | 0;\n    mid = mid + Math.imul(ah4, bl7) | 0;\n    hi = hi + Math.imul(ah4, bh7) | 0;\n    lo = lo + Math.imul(al3, bl8) | 0;\n    mid = mid + Math.imul(al3, bh8) | 0;\n    mid = mid + Math.imul(ah3, bl8) | 0;\n    hi = hi + Math.imul(ah3, bh8) | 0;\n    lo = lo + Math.imul(al2, bl9) | 0;\n    mid = mid + Math.imul(al2, bh9) | 0;\n    mid = mid + Math.imul(ah2, bl9) | 0;\n    hi = hi + Math.imul(ah2, bh9) | 0;\n    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = mid + Math.imul(ah9, bl3) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = lo + Math.imul(al8, bl4) | 0;\n    mid = mid + Math.imul(al8, bh4) | 0;\n    mid = mid + Math.imul(ah8, bl4) | 0;\n    hi = hi + Math.imul(ah8, bh4) | 0;\n    lo = lo + Math.imul(al7, bl5) | 0;\n    mid = mid + Math.imul(al7, bh5) | 0;\n    mid = mid + Math.imul(ah7, bl5) | 0;\n    hi = hi + Math.imul(ah7, bh5) | 0;\n    lo = lo + Math.imul(al6, bl6) | 0;\n    mid = mid + Math.imul(al6, bh6) | 0;\n    mid = mid + Math.imul(ah6, bl6) | 0;\n    hi = hi + Math.imul(ah6, bh6) | 0;\n    lo = lo + Math.imul(al5, bl7) | 0;\n    mid = mid + Math.imul(al5, bh7) | 0;\n    mid = mid + Math.imul(ah5, bl7) | 0;\n    hi = hi + Math.imul(ah5, bh7) | 0;\n    lo = lo + Math.imul(al4, bl8) | 0;\n    mid = mid + Math.imul(al4, bh8) | 0;\n    mid = mid + Math.imul(ah4, bl8) | 0;\n    hi = hi + Math.imul(ah4, bh8) | 0;\n    lo = lo + Math.imul(al3, bl9) | 0;\n    mid = mid + Math.imul(al3, bh9) | 0;\n    mid = mid + Math.imul(ah3, bl9) | 0;\n    hi = hi + Math.imul(ah3, bh9) | 0;\n    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = mid + Math.imul(ah9, bl4) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = lo + Math.imul(al8, bl5) | 0;\n    mid = mid + Math.imul(al8, bh5) | 0;\n    mid = mid + Math.imul(ah8, bl5) | 0;\n    hi = hi + Math.imul(ah8, bh5) | 0;\n    lo = lo + Math.imul(al7, bl6) | 0;\n    mid = mid + Math.imul(al7, bh6) | 0;\n    mid = mid + Math.imul(ah7, bl6) | 0;\n    hi = hi + Math.imul(ah7, bh6) | 0;\n    lo = lo + Math.imul(al6, bl7) | 0;\n    mid = mid + Math.imul(al6, bh7) | 0;\n    mid = mid + Math.imul(ah6, bl7) | 0;\n    hi = hi + Math.imul(ah6, bh7) | 0;\n    lo = lo + Math.imul(al5, bl8) | 0;\n    mid = mid + Math.imul(al5, bh8) | 0;\n    mid = mid + Math.imul(ah5, bl8) | 0;\n    hi = hi + Math.imul(ah5, bh8) | 0;\n    lo = lo + Math.imul(al4, bl9) | 0;\n    mid = mid + Math.imul(al4, bh9) | 0;\n    mid = mid + Math.imul(ah4, bl9) | 0;\n    hi = hi + Math.imul(ah4, bh9) | 0;\n    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = mid + Math.imul(ah9, bl5) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = lo + Math.imul(al8, bl6) | 0;\n    mid = mid + Math.imul(al8, bh6) | 0;\n    mid = mid + Math.imul(ah8, bl6) | 0;\n    hi = hi + Math.imul(ah8, bh6) | 0;\n    lo = lo + Math.imul(al7, bl7) | 0;\n    mid = mid + Math.imul(al7, bh7) | 0;\n    mid = mid + Math.imul(ah7, bl7) | 0;\n    hi = hi + Math.imul(ah7, bh7) | 0;\n    lo = lo + Math.imul(al6, bl8) | 0;\n    mid = mid + Math.imul(al6, bh8) | 0;\n    mid = mid + Math.imul(ah6, bl8) | 0;\n    hi = hi + Math.imul(ah6, bh8) | 0;\n    lo = lo + Math.imul(al5, bl9) | 0;\n    mid = mid + Math.imul(al5, bh9) | 0;\n    mid = mid + Math.imul(ah5, bl9) | 0;\n    hi = hi + Math.imul(ah5, bh9) | 0;\n    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = mid + Math.imul(ah9, bl6) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = lo + Math.imul(al8, bl7) | 0;\n    mid = mid + Math.imul(al8, bh7) | 0;\n    mid = mid + Math.imul(ah8, bl7) | 0;\n    hi = hi + Math.imul(ah8, bh7) | 0;\n    lo = lo + Math.imul(al7, bl8) | 0;\n    mid = mid + Math.imul(al7, bh8) | 0;\n    mid = mid + Math.imul(ah7, bl8) | 0;\n    hi = hi + Math.imul(ah7, bh8) | 0;\n    lo = lo + Math.imul(al6, bl9) | 0;\n    mid = mid + Math.imul(al6, bh9) | 0;\n    mid = mid + Math.imul(ah6, bl9) | 0;\n    hi = hi + Math.imul(ah6, bh9) | 0;\n    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = mid + Math.imul(ah9, bl7) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = lo + Math.imul(al8, bl8) | 0;\n    mid = mid + Math.imul(al8, bh8) | 0;\n    mid = mid + Math.imul(ah8, bl8) | 0;\n    hi = hi + Math.imul(ah8, bh8) | 0;\n    lo = lo + Math.imul(al7, bl9) | 0;\n    mid = mid + Math.imul(al7, bh9) | 0;\n    mid = mid + Math.imul(ah7, bl9) | 0;\n    hi = hi + Math.imul(ah7, bh9) | 0;\n    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = mid + Math.imul(ah9, bl8) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = lo + Math.imul(al8, bl9) | 0;\n    mid = mid + Math.imul(al8, bh9) | 0;\n    mid = mid + Math.imul(ah8, bl9) | 0;\n    hi = hi + Math.imul(ah8, bh9) | 0;\n    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = mid + Math.imul(ah9, bl9) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n\n    return out;\n  }; // Polyfill comb\n\n\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo(self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n    var carry = 0;\n    var hncarry = 0;\n\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n        var lo = r & 0x3ffffff;\n        ncarry = ncarry + (r / 0x4000000 | 0) | 0;\n        lo = lo + rword | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = ncarry + (lo >>> 26) | 0;\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo(self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo(num, out) {\n    var res;\n    var len = this.length + num.length;\n\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  }; // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n\n  function FFTM(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT(N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  }; // Returns binary-reversed representation of `x`\n\n\n  FFTM.prototype.revBin = function revBin(x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n    var rb = 0;\n\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << l - i - 1;\n      x >>= 1;\n    }\n\n    return rb;\n  }; // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n\n\n  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n          var rx = rtwdf_ * ro - itwdf_ * io;\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n          /* jshint maxdepth : false */\n\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n      t = iws[i];\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b(ws, N) {\n    var carry = 0;\n\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {\n    var carry = 0;\n\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n      rws[2 * i] = carry & 0x1fff;\n      carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff;\n      carry = carry >>> 13;\n    } // Pad with zeroes\n\n\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub(N) {\n    var ph = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp(x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n    var rmws = out.words;\n    rmws.length = N;\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  }; // Multiply `this` by `num`\n\n\n  BN.prototype.mul = function mul(num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  }; // Multiply employing FFT\n\n\n  BN.prototype.mulf = function mulf(num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  }; // In-place Multiplication\n\n\n  BN.prototype.imul = function imul(num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln(num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n    assert(typeof num === 'number');\n    assert(num < 0x4000000); // Carry\n\n    var carry = 0;\n\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum\n\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln(num) {\n    return this.clone().imuln(num);\n  }; // `this` * `this`\n\n\n  BN.prototype.sqr = function sqr() {\n    return this.mul(this);\n  }; // `this` * `this` in-place\n\n\n  BN.prototype.isqr = function isqr() {\n    return this.imul(this.clone());\n  }; // Math.pow(`this`, `num`)\n\n\n  BN.prototype.pow = function pow(num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1); // Skip leading zeroes\n\n    var res = this;\n\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  }; // Shift-left in-place\n\n\n  BN.prototype.iushln = function iushln(bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = (this.words[i] | 0) - newCarry << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> 26 - r;\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln(bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  }; // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n\n\n  BN.prototype.iushrn = function iushrn(bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n\n    if (hint) {\n      h = (hint - hint % 26) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;\n    var maskedWords = extended;\n    h -= s;\n    h = Math.max(0, h); // Extended mode, copy masked part\n\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {// No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = carry << 26 - r | word >>> r;\n      carry = word & mask;\n    } // Push carried bits as a mask\n\n\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn(bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  }; // Shift-left\n\n\n  BN.prototype.shln = function shln(bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln(bits) {\n    return this.clone().iushln(bits);\n  }; // Shift-right\n\n\n  BN.prototype.shrn = function shrn(bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn(bits) {\n    return this.clone().iushrn(bits);\n  }; // Test if n bit is set\n\n\n  BN.prototype.testn = function testn(bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r; // Fast case: bit is much higher than all existing words\n\n    if (this.length <= s) return false; // Check bit and return\n\n    var w = this.words[s];\n    return !!(w & q);\n  }; // Return only lowers bits of number (in-place)\n\n\n  BN.prototype.imaskn = function imaskn(bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  }; // Return only lowers bits of number\n\n\n  BN.prototype.maskn = function maskn(bits) {\n    return this.clone().imaskn(bits);\n  }; // Add plain number `num` to `this`\n\n\n  BN.prototype.iaddn = function iaddn(num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num); // Possible sign change\n\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    } // Add without checks\n\n\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn(num) {\n    this.words[0] += num; // Carry\n\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n\n    this.length = Math.max(this.length, i + 1);\n    return this;\n  }; // Subtract plain number `num` from `this`\n\n\n  BN.prototype.isubn = function isubn(num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn(num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn(num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs() {\n    this.negative = 0;\n    return this;\n  };\n\n  BN.prototype.abs = function abs() {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - (right / 0x4000000 | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip(); // Subtraction overflow\n\n    assert(carry === -1);\n    carry = 0;\n\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n\n    this.negative = 1;\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv(num, mode) {\n    var shift = this.length - num.length;\n    var a = this.clone();\n    var b = num; // Normalize\n\n    var bhi = b.words[b.length - 1] | 0;\n\n    var bhiBits = this._countBits(bhi);\n\n    shift = 26 - bhiBits;\n\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    } // Initialize quotient\n\n\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n\n    if (diff.negative === 0) {\n      a = diff;\n\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n\n      qj = Math.min(qj / bhi | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n\n        a._ishlnsubmul(b, 1, j);\n\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n\n    if (q) {\n      q._strip();\n    }\n\n    a._strip(); // Denormalize\n\n\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  }; // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n\n\n  BN.prototype.divmod = function divmod(num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    } // Both numbers are positive at this point\n    // Strip both numbers to approximate shift value\n\n\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    } // Very short reduction\n\n\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  }; // Find `this` / `num`\n\n\n  BN.prototype.div = function div(num) {\n    return this.divmod(num, 'div', false).div;\n  }; // Find `this` % `num`\n\n\n  BN.prototype.mod = function mod(num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod(num) {\n    return this.divmod(num, 'mod', true).mod;\n  }; // Find Round(`this` / `num`)\n\n\n  BN.prototype.divRound = function divRound(num) {\n    var dm = this.divmod(num); // Fast case - exact division\n\n    if (dm.mod.isZero()) return dm.div;\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half); // Round down\n\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up\n\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn(num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n    var acc = 0;\n\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  }; // WARNING: DEPRECATED\n\n\n  BN.prototype.modn = function modn(num) {\n    return this.modrn(num);\n  }; // In-place division by number\n\n\n  BN.prototype.idivn = function idivn(num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n    assert(num <= 0x3ffffff);\n    var carry = 0;\n\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = w / num | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn(num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd(p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    } // A * x + B * y = x\n\n\n    var A = new BN(1);\n    var B = new BN(0); // C * x + D * y = y\n\n    var C = new BN(0);\n    var D = new BN(1);\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {\n        ;\n      }\n\n      if (i > 0) {\n        x.iushrn(i);\n\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {\n        ;\n      }\n\n      if (j > 0) {\n        y.iushrn(j);\n\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  }; // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n\n\n  BN.prototype._invmp = function _invmp(p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {\n        ;\n      }\n\n      if (i > 0) {\n        a.iushrn(i);\n\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {\n        ;\n      }\n\n      if (j > 0) {\n        b.iushrn(j);\n\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd(num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0; // Remove common factor of two\n\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  }; // Invert number in the field F(num)\n\n\n  BN.prototype.invm = function invm(num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven() {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd() {\n    return (this.words[0] & 1) === 1;\n  }; // And first word and num\n\n\n  BN.prototype.andln = function andln(num) {\n    return this.words[0] & num;\n  }; // Increment at the bit position in-line\n\n\n  BN.prototype.bincn = function bincn(bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r; // Fast case: bit is much higher than all existing words\n\n    if (this.length <= s) {\n      this._expand(s + 1);\n\n      this.words[s] |= q;\n      return this;\n    } // Add bit and propagate, if needed\n\n\n    var carry = q;\n\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero() {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn(num) {\n    var negative = num < 0;\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  }; // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n\n\n  BN.prototype.cmp = function cmp(num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  }; // Unsigned comparison\n\n\n  BN.prototype.ucmp = function ucmp(num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n    var res = 0;\n\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n      if (a === b) continue;\n\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n\n      break;\n    }\n\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn(num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt(num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten(num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte(num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn(num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt(num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten(num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte(num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn(num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq(num) {\n    return this.cmp(num) === 0;\n  }; //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n\n\n  BN.red = function red(num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed(ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed() {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed(ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed(ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd(num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd(num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub(num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub(num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl(num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul(num) {\n    assert(this.red, 'redMul works only with red numbers');\n\n    this.red._verify2(this, num);\n\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul(num) {\n    assert(this.red, 'redMul works only with red numbers');\n\n    this.red._verify2(this, num);\n\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr() {\n    assert(this.red, 'redSqr works only with red numbers');\n\n    this.red._verify1(this);\n\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr() {\n    assert(this.red, 'redISqr works only with red numbers');\n\n    this.red._verify1(this);\n\n    return this.red.isqr(this);\n  }; // Square root over p\n\n\n  BN.prototype.redSqrt = function redSqrt() {\n    assert(this.red, 'redSqrt works only with red numbers');\n\n    this.red._verify1(this);\n\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm() {\n    assert(this.red, 'redInvm works only with red numbers');\n\n    this.red._verify1(this);\n\n    return this.red.invm(this);\n  }; // Return negative clone of `this` % `red modulo`\n\n\n  BN.prototype.redNeg = function redNeg() {\n    assert(this.red, 'redNeg works only with red numbers');\n\n    this.red._verify1(this);\n\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow(num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n\n    this.red._verify1(this);\n\n    return this.red.pow(this, num);\n  }; // Prime numbers with efficient reduction\n\n\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  }; // Pseudo-Mersenne prime\n\n  function MPrime(name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp() {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce(num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      r._strip();\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split(input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK(num) {\n    return num.imul(this.k);\n  };\n\n  function K256() {\n    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split(input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n    var outLen = Math.min(input.length, 9);\n\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    } // Shift by 9 limbs\n\n\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;\n      prev = next;\n    }\n\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK(num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\n    var lo = 0;\n\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + (lo / 0x4000000 | 0);\n    } // Fast length reduction\n\n\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n\n    return num;\n  };\n\n  function P224() {\n    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n\n  inherits(P224, MPrime);\n\n  function P192() {\n    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n\n  inherits(P192, MPrime);\n\n  function P25519() {\n    // 2 ^ 255 - 19\n    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK(num) {\n    // K = 0x13\n    var carry = 0;\n\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n      num.words[i] = lo;\n      carry = hi;\n    }\n\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n\n    return num;\n  }; // Exported mostly for testing purposes, use plain name instead\n\n\n  BN._prime = function prime(name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n    var prime;\n\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n\n    primes[name] = prime;\n    return prime;\n  }; //\n  // Base reduction engine\n  //\n\n\n  function Red(m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1(a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2(a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red, 'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod(a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    a.umod(this.m)._forceRed(this)._move(a);\n\n    return a;\n  };\n\n  Red.prototype.neg = function neg(a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add(a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd(a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n\n    return res;\n  };\n\n  Red.prototype.sub = function sub(a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub(a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n\n    return res;\n  };\n\n  Red.prototype.shl = function shl(a, num) {\n    this._verify1(a);\n\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul(a, b) {\n    this._verify2(a, b);\n\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul(a, b) {\n    this._verify2(a, b);\n\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr(a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr(a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt(a) {\n    if (a.isZero()) return a.clone();\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1); // Fast case\n\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    } // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n\n\n    var q = this.m.subn(1);\n    var s = 0;\n\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n\n    assert(!q.isZero());\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg(); // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm(a) {\n    var inv = a._invmp(this.m);\n\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow(a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = word >> j & 1;\n\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo(num) {\n    var r = num.umod(this.m);\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom(num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  }; //\n  // Montgomery method engine\n  //\n\n\n  BN.mont = function mont(num) {\n    return new Mont(num);\n  };\n\n  function Mont(m) {\n    Red.call(this, m);\n    this.shift = this.m.bitLength();\n\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - this.shift % 26;\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo(num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom(num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul(a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul(a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm(a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n\n//# sourceURL=webpack://keystore_wdc_contract/./bn.js?");

/***/ }),

/***/ "./contract.js":
/*!*********************!*\
  !*** ./contract.js ***!
  \*********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/*! CommonJS bailout: module.exports is used directly at 2568:18-32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n(function () {\n  var _tool;\n\n  var OFFSET_SHORT_ITEM = 0x80;\n  var SIZE_THRESHOLD = 56;\n  var OFFSET_LONG_ITEM = 0xb7;\n  var OFFSET_SHORT_LIST = 0xc0;\n  var OFFSET_LONG_LIST = 0xf7;\n  var EMPTY_BYTES = new Uint8Array(new ArrayBuffer(0));\n  var EMPTY_RLP_ARRAY = new Uint8Array([0xc0]);\n  var NULL_RLP = new Uint8Array([0x80]);\n  var ENVS = {\n    NODE: 'NODE',\n    BROWSER: 'BROWSER'\n  };\n  var env = this['window'] === this ? ENVS.BROWSER : ENVS.NODE;\n  var isBrowser = env === ENVS.BROWSER;\n\n  var BN = __webpack_require__(/*! ./bn.js */ \"./bn.js\");\n\n  var _keccak256 = __webpack_require__(/*! ./sha3.js */ \"./sha3.js\").keccak256;\n\n  var nacl = __webpack_require__(/*! ./nacl.min.js */ \"./nacl.min.js\");\n\n  var RMD160 = new (__webpack_require__(/*! ./hashes.js */ \"./hashes.js\").RMD160)();\n  RMD160.setUTF8(false);\n  /**\n   * \n   * @param {Uint8Array} a \n   * @param {Uint8Array} b \n   */\n\n  function compareBytes(a, b) {\n    if (a.length > b.length) return 1;\n    if (b.length > a.length) return -1;\n\n    for (var i = 0; i < a.length; i++) {\n      var ai = a[i];\n      var bi = b[i];\n      if (ai > bi) return 1;\n      if (bi > ai) return -1;\n    }\n\n    return 0;\n  } // base58 \n\n\n  var base58 = base('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'); // rmd  Uint8Array  Uint8Array \n\n  var FakeString = /*#__PURE__*/function () {\n    function FakeString(u8) {\n      _classCallCheck(this, FakeString);\n\n      this.u8 = u8;\n      this.length = u8.length;\n    }\n\n    _createClass(FakeString, [{\n      key: \"charCodeAt\",\n      value: function charCodeAt(i) {\n        return this.u8[i];\n      }\n    }]);\n\n    return FakeString;\n  }();\n  /**\n   * rmd160 \n   * @param {Uint8Array} o \n   * @returns {Uint8Array}\n   */\n\n\n  function rmd160(o) {\n    assert(isBytes(o), 'o is not byte array');\n    return decodeHex(RMD160.hex(new FakeString(o)));\n  }\n  /**\n   * base58 \n   * @param {string} ALPHABET \n   */\n\n\n  function base(ALPHABET) {\n    var ALPHABET_MAP = {};\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0); // pre-compute lookup table\n\n    for (var z = 0; z < ALPHABET.length; z++) {\n      var x = ALPHABET.charAt(z);\n      if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');\n      ALPHABET_MAP[x] = z;\n    }\n    /**\n     * \n     * @param {Uint8Array} source \n     */\n\n\n    function encode(source) {\n      if (source.length === 0) return '';\n      var digits = [0];\n\n      for (var i = 0; i < source.length; ++i) {\n        for (var j = 0, carry = source[i]; j < digits.length; ++j) {\n          carry += digits[j] << 8;\n          digits[j] = carry % BASE;\n          carry = carry / BASE | 0;\n        }\n\n        while (carry > 0) {\n          digits.push(carry % BASE);\n          carry = carry / BASE | 0;\n        }\n      }\n\n      var string = ''; // deal with leading zeros\n\n      for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n        string += LEADER;\n      } // convert digits to a string\n\n\n      for (var q = digits.length - 1; q >= 0; --q) {\n        string += ALPHABET[digits[q]];\n      }\n\n      return string;\n    }\n    /**\n     * \n     * @param {string} string \n     * @returns {Uint8Array}\n     */\n\n\n    function decodeUnsafe(string) {\n      if (typeof string !== 'string') throw new TypeError('Expected String');\n      if (string.length === 0) return new Uint8Array(0);\n      var bytes = [0];\n\n      for (var i = 0; i < string.length; i++) {\n        var value = ALPHABET_MAP[string[i]];\n        if (value === undefined) throw new Error(\"invalid char \".concat(string[i]));\n\n        for (var j = 0, carry = value; j < bytes.length; ++j) {\n          carry += bytes[j] * BASE;\n          bytes[j] = carry & 0xff;\n          carry >>= 8;\n        }\n\n        while (carry > 0) {\n          bytes.push(carry & 0xff);\n          carry >>= 8;\n        }\n      } // deal with leading zeros\n\n\n      for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {\n        bytes.push(0);\n      }\n\n      return new Uint8Array(bytes.reverse());\n    }\n\n    function decode(string) {\n      var buffer = decodeUnsafe(string);\n      if (buffer) return buffer;\n      throw new Error('Non-base' + BASE + ' character');\n    }\n\n    return {\n      encode: encode,\n      decodeUnsafe: decodeUnsafe,\n      decode: decode\n    };\n  }\n  /**\n   * \n   * @param {Uint8Array | string | ArrayBuffer} privateKey \n   * @returns {Uint8Array}\n   */\n\n\n  function privateKey2PublicKey(privateKey) {\n    privateKey = decodeHex(privateKey);\n    if (isBytes(privateKey)) privateKey = toU8Arr(privateKey);\n    if (privateKey.length === 64) privateKey = privateKey.slice(32);\n    var pair = new nacl.sign.keyPair.fromSeed(privateKey);\n    return pair.publicKey;\n  }\n  /**\n   * \n   * @param {Uint8Array | string} publicKey \n   * @returns {Uint8Array}\n   */\n\n\n  function publicKey2Hash(publicKey) {\n    publicKey = decodeHex(publicKey);\n    publicKey = digest(publicKey);\n    return rmd160(publicKey);\n  }\n  /**\n   * \n   */\n\n\n  function address2PublicKeyHash(str) {\n    assert(typeof str === 'string', 'address is string');\n    var r5;\n\n    if (str.indexOf(\"1\") == 0) {\n      r5 = base58.decode(str);\n    } else {\n      r5 = base58.decode(str.substr(2));\n    }\n\n    return r5.slice(1, r5.length - 4);\n  }\n  /**\n   * \n   * @param { Uint8Array } hash\n   *  \n   */\n\n\n  function publicKeyHash2Address(hash) {\n    var r2 = concatBytes(new Uint8Array([0]), hash);\n    var r3 = digest(digest(hash));\n    var b4 = r3.slice(0, 4);\n    var b5 = concatBytes(r2, b4);\n    return base58.encode(b5);\n  }\n  /**\n   * 32  64\n   * @param {string} sk \n   */\n\n\n  function extendPrivateKey(sk) {\n    sk = decodeHex(sk);\n    if (sk.length === 64) return sk;\n    return concatBytes(sk, privateKey2PublicKey(sk));\n  }\n  /**\n   * \n   * @param {string} address \n   */\n\n\n  function assertAddress(address) {\n    if (!_typeof(address) === 'string') throw new Error('invalid address not a string');\n\n    if (!address.startsWith('1') && !address.startsWith('WX') && !address.startsWith('WR')) {\n      throw new Error('address should starts with 1, WX or WR');\n    }\n\n    if (address.startsWith('WX') || address.startsWith('WR')) address = address.substr(2);\n\n    var _r5 = base58.decode(address);\n\n    var a = address2PublicKeyHash(address);\n    var c = digest(a);\n    var r3 = digest(c);\n    var b4 = r3.slice(0, 4);\n\n    var _b4 = _r5.slice(21, 25);\n\n    if (compareBytes(b4, _b4) != 0) {\n      throw new Error('invalid address ' + address);\n    }\n  }\n  /**\n   *  \n   * @param {string | Uint8Array | ArrayBuffer} \n   * @returns  {Uint8Array} \n   */\n\n\n  function normalizeAddress(addr) {\n    if (typeof addr === 'string' && isHex(addr)) addr = decodeHex(addr);\n\n    if (isBytes(addr)) {\n      addr = toU8Arr(addr); //  20 \n\n      if (addr.length === 20) return addr; // 32  \n\n      if (addr.length === 32) return publicKey2Hash(addr);\n      throw new Error(\"invalid size \".concat(addr.length));\n    } // \n\n\n    assertAddress(addr);\n    return address2PublicKeyHash(addr);\n  }\n  /**\n   *  keccak256\n   * @param {Uint8Array}\n   * @returns {Uint8Array}\n   */\n\n\n  function digest(msg) {\n    assert(isBytes(msg), 'digest failed msg is not bytes');\n\n    var hasher = _keccak256.create();\n\n    hasher.update(msg);\n    return new Uint8Array(hasher.arrayBuffer());\n  } // \n\n\n  var TX_STATUS = {\n    PENDING: 0,\n    INCLUDED: 1,\n    CONFIRMED: 2,\n    DROPPED: 3\n  };\n\n  function copy(dst, src) {\n    for (var _i = 0, _Object$keys = Object.keys(src); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      dst[key] = src[key];\n    }\n  }\n  /**\n   * \n   * @param {string | number | ArrayBuffer | Uint8Array | BN }\n   * @returns { string | number}\n   */\n\n\n  function toSafeInt(x) {\n    if (typeof x === 'number') return x;\n\n    if (typeof x === 'string') {\n      var hex = x.startsWith('0x');\n      if (hex) x = x.substr(2, x.length - 2);\n      x = new BN(x, hex ? 16 : 10);\n    }\n\n    if (x instanceof ArrayBuffer || x instanceof Uint8Array) x = new BN(x, 'be');\n    if (x.cmp(MAX_SAFE_INTEGER) <= 0 && x.cmp(MIN_SAFE_INTEGER) >= 0) return x.toNumber();\n    return x.toString();\n  }\n\n  var assert = this['assert'] ? this['assert'] : function (truth, msg) {\n    if (!truth) throw new Error(msg || 'assert failed');\n  };\n  var MAX_U64 = new BN('ffffffffffffffff', 16);\n  var MAX_U256 = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\n  var MAX_I64 = new BN('9223372036854775807', 10);\n  var MIN_I64 = new BN('-9223372036854775808', 10);\n  var MAX_SAFE_INTEGER = new BN(Number.MAX_SAFE_INTEGER);\n  var MIN_SAFE_INTEGER = new BN(Number.MIN_SAFE_INTEGER);\n  var ONE = new BN(1);\n  /**\n   *  0\n   * @param { Uint8Array | ArrayBuffer } data \n   */\n\n  function trimLeadingZeros(data) {\n    assert(isBytes(data), 'data is not bytes');\n    data = toU8Arr(data);\n    var k = -1;\n\n    for (var i = 0; i < data.length; i++) {\n      if (data[i] !== 0) {\n        k = i;\n        break;\n      }\n    }\n\n    if (k === -1) return new Uint8Array(0);\n    return data.slice(k, data.length);\n  }\n\n  function hexToInt(x) {\n    if (48 <= x && x <= 57) return x - 48;\n    if (97 <= x && x <= 102) return x - 87;\n    if (65 <= x && x <= 70) return x - 55;\n    return 0;\n  }\n  /**\n   * \n   * decode hex string\n   * @param {string | ArrayBuffer | Uint8Array} s\n   * @returns {Uint8Array}\n   */\n\n\n  function decodeHex(s) {\n    if (isBytes(s)) return toU8Arr(s);\n    if (s.startsWith('0x')) s = s.substr(2, s.length - 2);\n    assert(s.length % 2 === 0, 'invalid char');\n    var ret = new Uint8Array(s.length / 2);\n\n    for (var i = 0; i < s.length / 2; i++) {\n      var h = s.charCodeAt(i * 2);\n      var l = s.charCodeAt(i * 2 + 1);\n      ret[i] = (hexToInt(h) << 4) + hexToInt(l);\n    }\n\n    return ret;\n  }\n  /**\n   * \n   * @param {string} hex\n   * @returns {boolean}\n   */\n\n\n  function isHex(hex) {\n    if (typeof hex === 'string' && hex.startsWith('0x')) hex = hex.substr(2);\n    if (hex.length % 2 !== 0) return false;\n    hex = hex.toLowerCase();\n\n    for (var i = 0; i < hex.length; i++) {\n      var code = hex.charCodeAt(i);\n\n      if (code >= 48 && code <= 57 || code >= 97 && code <= 102) {} else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * convert bytes like objects to hex string \n   * @param {string | ArrayBuffer | Uint8Array } s\n   * @returns {string}\n   */\n\n\n  function bin2hex(s) {\n    if (typeof s === 'string' && s.startsWith('0x')) {\n      s = s.substr(2);\n    }\n\n    if (typeof s === 'string') {\n      assert(isHex(s), \"invalid hex string \".concat(s));\n    }\n\n    if (isBytes(s)) return encodeHex(s);\n    return s;\n  }\n  /**\n   * convert digital like objects to digital string \n   * @param {string | BN | number } s\n   * @returns {string}\n   */\n\n\n  function asDigitalNumberText(s) {\n    if (typeof s === 'string') {\n      if (s.startsWith('0x')) s = new BN(s.substr(2), 16);else return s;\n    }\n\n    return s.toString(10);\n  }\n\n  var TypeDef = /*#__PURE__*/function () {\n    /**\n     *\n     * @param {string} type\n     * @param {string} name\n     */\n    function TypeDef(type, name) {\n      _classCallCheck(this, TypeDef);\n\n      type = type && type.toLowerCase();\n      assert(type === ABI_DATA_TYPE.STRING || type === ABI_DATA_TYPE.U64 || type === ABI_DATA_TYPE.ADDRESS || type === ABI_DATA_TYPE.BYTES || type === ABI_DATA_TYPE.U256 || type === ABI_DATA_TYPE.BOOL || type === ABI_DATA_TYPE.I64 || type === ABI_DATA_TYPE.F64, \"invalid abi type def name = \".concat(name, \" type = \").concat(type));\n      this.type = type;\n      this.name = name;\n    }\n    /**\n     *\n     * @param {Object} o\n     * @return {TypeDef}\n     */\n\n\n    _createClass(TypeDef, null, [{\n      key: \"from\",\n      value: function from(o) {\n        return new TypeDef(o.type, o.name);\n      }\n    }]);\n\n    return TypeDef;\n  }();\n\n  var ABI = /*#__PURE__*/function () {\n    /**\n     *\n     * @param {string} name\n     * @param {string} type\n     * @param {Array<TypeDef> } inputs\n     * @param {Array<TypeDef>} outputs\n     */\n    function ABI(name, type, inputs, outputs) {\n      _classCallCheck(this, ABI);\n\n      type = type && type.toLowerCase();\n      assert(name, 'expect name of abi');\n      assert(type === ABI_TYPE.FUNCTION || type === ABI_TYPE.EVENT, \"invalid abi type \".concat(type));\n      assert(!inputs || Array.isArray(inputs), \"invalid inputs \".concat(inputs));\n      assert(!outputs || Array.isArray(outputs), \"invalid inputs \".concat(outputs));\n      this.name = name;\n      this.type = type;\n      this.inputs = (inputs || []).map(TypeDef.from);\n      this.outputs = (outputs || []).map(TypeDef.from);\n    }\n\n    _createClass(ABI, [{\n      key: \"returnsObj\",\n      value: function returnsObj() {\n        return this.outputs.every(function (v) {\n          return v.name;\n        }) && new Set(this.outputs.map(function (v) {\n          return v.name;\n        })).size === this.outputs.length;\n      }\n    }, {\n      key: \"inputsObj\",\n      value: function inputsObj() {\n        return this.inputs.every(function (v) {\n          return v.name;\n        }) && new Set(this.inputs.map(function (v) {\n          return v.name;\n        })).size === this.inputs.length;\n      }\n    }, {\n      key: \"toObj\",\n      value: function toObj(arr, input) {\n        var p = input ? this.inputs : this.outputs;\n        var o = {};\n\n        for (var i = 0; i < p.length; i++) {\n          o[p[i].name] = arr[i];\n        }\n\n        return o;\n      }\n    }, {\n      key: \"toArr\",\n      value: function toArr(obj, input) {\n        var p = input ? this.inputs : this.outputs;\n        var arr = [];\n\n        for (var i = 0; i < p.length; i++) {\n          arr.push(obj[p[i].name]);\n        }\n\n        return arr;\n      }\n    }], [{\n      key: \"from\",\n      value: function from(o) {\n        return new ABI(o.name, o.type, o.inputs, o.outputs);\n      }\n    }]);\n\n    return ABI;\n  }();\n\n  function normalizeParams(params) {\n    if (params === null || params === undefined) return [];\n    if (typeof params === 'string' || typeof params === 'boolean' || typeof params === 'number' || params instanceof ArrayBuffer || params instanceof Uint8Array || params instanceof BN) return [params];\n    return params;\n  }\n  /**\n   * abi \n   * @param {Array<TypeDef>} outputs\n   * @param {string | ArrayBuffer | Array<Uint8Array> | Uint8Array} buf\n   */\n\n\n  function _abiDecode(outputs, buf) {\n    if (!buf) buf = '';\n    if (typeof buf === 'string') buf = decodeHex(buf);\n    if (buf.length === 0) return [];\n    var arr = Array.isArray(buf) ? buf : RLP.decode(buf);\n    var returnObject = outputs.every(function (v) {\n      return v.name;\n    }) && new Set(outputs.map(function (v) {\n      return v.name;\n    })).size === outputs.length;\n    if (arr.length != outputs.length) throw new Error(\"abi decode failed , expect \".concat(outputs.length, \" returns while \").concat(arr.length, \" found\"));\n    var ret = returnObject ? {} : [];\n\n    for (var i = 0; i < arr.length; i++) {\n      var t = outputs[i].type;\n      var name = outputs[i].name;\n      var val = void 0;\n\n      switch (t) {\n        case ABI_DATA_TYPE.BYTES:\n          val = encodeHex(arr[i]);\n          break;\n\n        case ABI_DATA_TYPE.ADDRESS:\n          val = publicKeyHash2Address(arr[i]);\n          break;\n\n        case ABI_DATA_TYPE.U256:\n        case ABI_DATA_TYPE.U64:\n          {\n            val = new BN(arr[i], 'be');\n            if (t === ABI_DATA_TYPE.U64) assert(val.cmp(MAX_U64) <= 0, \"\".concat(val.toString(10), \" overflows max u64 \").concat(MAX_U64.toString(10)));\n            if (t === ABI_DATA_TYPE.U256) assert(val.cmp(MAX_U256) <= 0, \"\".concat(val.toString(10), \" overflows max u256 \").concat(MAX_U256.toString(10)));\n            val = toSafeInt(val);\n            break;\n          }\n\n        case ABI_DATA_TYPE.I64:\n          {\n            var padded = padPrefix(arr[i], 0, 8);\n            var isneg = padded[0] & 0x80;\n\n            if (!isneg) {\n              val = new BN(arr[i], 'be');\n            } else {\n              val = new BN(inverse(padded), 'be');\n              val = val.add(ONE);\n              val = val.neg();\n            }\n\n            val = toSafeInt(val);\n            break;\n          }\n\n        case ABI_DATA_TYPE.F64:\n          {\n            val = bytesToF64(arr[i]);\n            break;\n          }\n\n        case ABI_DATA_TYPE.STRING:\n          {\n            val = bin2str(arr[i]);\n            break;\n          }\n\n        case ABI_DATA_TYPE.BOOL:\n          {\n            val = arr[i].length > 0;\n            break;\n          }\n      }\n\n      if (returnObject) ret[name] = val;else ret[i] = val;\n    }\n\n    return ret;\n  }\n  /**\n   * \n   */\n\n\n  var Transaction = /*#__PURE__*/function () {\n    /**\n     * constructor of transaction\n     * @param {string | number | BN} [version]\n     * @param {string | number | BN} [type]\n     * @param {string | number | BN} [nonce]\n     * @param {string | Uint8Array | ArrayBuffer} [from]\n     * @param {string | number | BN} [gasPrice]\n     * @param {string | number | BN} [amount]\n     * @param {string | Uint8Array | ArrayBuffer } [payload]\n     * @param {string | Uint8Array | ArrayBuffer} [to]\n     * @param {string | Uint8Array | ArrayBuffer } [signature]\n     * @param { Array<ABI> } [__abi] abi\n     * @param { Array | Object } [__inputs] inputs\n     */\n    function Transaction(version, type, nonce, from, gasPrice, amount, payload, to, signature, __abi, __inputs) {\n      _classCallCheck(this, Transaction);\n\n      this.version = asDigitalNumberText(version || 0);\n      this.type = asDigitalNumberText(type || 0);\n      this.nonce = asDigitalNumberText(nonce || 0);\n      this.from = bin2hex(from || '');\n      this.gasPrice = asDigitalNumberText(gasPrice || 0);\n      this.amount = asDigitalNumberText(amount || 0);\n      this.payload = bin2hex(payload || '');\n      this.to = bin2hex(to || '');\n      this.signature = bin2hex(signature || '');\n      this.__abi = __abi;\n      this.__inputs = __inputs;\n    }\n\n    _createClass(Transaction, [{\n      key: \"getHash\",\n\n      /**\n       * \n       * @returns { Uint8Array } \n       */\n      value: function getHash() {\n        return digest(this.getRaw(false));\n      }\n      /**\n       * \n       * @param {boolean} nullSig\n       * @returns {Uint8Array}\n       */\n\n    }, {\n      key: \"getRaw\",\n      value: function getRaw(nullSig) {\n        var sig = nullSig ? new Uint8Array(64) : decodeHex(this.signature);\n        var p = decodeHex(this.payload);\n        return concatBytes([new Uint8Array([parseInt(this.version)]), new Uint8Array([parseInt(this.type)]), padPrefix(new BN(this.nonce).toArrayLike(Uint8Array, 'be'), 0, 8), decodeHex(this.from), padPrefix(new BN(this.gasPrice).toArrayLike(Uint8Array, 'be'), 0, 8), padPrefix(new BN(this.amount).toArrayLike(Uint8Array, 'be'), 0, 8), sig, decodeHex(this.to), padPrefix(new BN(p.length).toArrayLike(Uint8Array, 'be'), 0, 4), p]);\n      }\n      /**\n       * rlp \n       * @returns { Uint8Array }\n       */\n\n    }, {\n      key: \"getEncoded\",\n      value: function getEncoded() {\n        var arr = this.__toArr();\n\n        return RLP.encode(arr);\n      }\n    }, {\n      key: \"__toArr\",\n      value: function __toArr() {\n        return [convert(this.version || 0, ABI_DATA_TYPE.U64), convert(this.type || 0, ABI_DATA_TYPE.U64), convert(this.nonce || '0', ABI_DATA_TYPE.U64), convert(this.from || EMPTY_BYTES, ABI_DATA_TYPE.BYTES), convert(this.gasPrice || '0', ABI_DATA_TYPE.U256), convert(this.amount || '0', ABI_DATA_TYPE.U256), convert(this.payload || EMPTY_BYTES, ABI_DATA_TYPE.BYTES), decodeHex(this.to), convert(this.signature || EMPTY_BYTES, ABI_DATA_TYPE.BYTES)];\n      }\n      /**\n       * \n       * @param {string | Uint8Array | ArrayBuffer } sk \n       */\n\n    }, {\n      key: \"sign\",\n      value: function sign(sk) {\n        sk = decodeHex(sk);\n        sk = extendPrivateKey(sk);\n        this.signature = encodeHex(nacl.sign(this.getRaw(true), sk).slice(0, 64));\n      }\n    }, {\n      key: \"__setInputs\",\n      value: function __setInputs(__inputs) {\n        var cnv = function cnv(x) {\n          if (x instanceof ArrayBuffer || x instanceof Uint8Array) return encodeHex(x);\n          if (x instanceof BN) return toSafeInt(x);\n          return x;\n        };\n\n        if (Array.isArray(__inputs)) {\n          this.__inputs = __inputs.map(cnv);\n        } else {\n          this.__inputs = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(__inputs); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            this.__inputs[k] = cnv(__inputs[k]);\n          }\n        }\n\n        if (Array.isArray(this.__inputs)) {\n          var c = new Contract('', this.__abi);\n          var a = c.getABI(this.getMethod(), ABI_TYPE.FUNCTION);\n\n          if (a.inputsObj()) {\n            this.__inputs = a.toObj(this.__inputs, true);\n          }\n        }\n      }\n    }, {\n      key: \"getMethod\",\n      value: function getMethod() {\n        var t = parseInt(this.type);\n        return t === constants.WASM_DEPLOY ? 'init' : bin2str(RLP.decode(decodeHex(this.payload))[1]);\n      }\n    }, {\n      key: \"isDeployOrCall\",\n      value: function isDeployOrCall() {\n        var t = parseInt(this.type);\n        return t === constants.WASM_DEPLOY || t === constants.WASM_CALL;\n      }\n    }], [{\n      key: \"clone\",\n      value: function clone(o) {\n        return new Transaction(o.version, o.type, o.nonce, o.from, o.gasPrice, o.amount, o.payload, o.to, o.signature);\n      }\n    }]);\n\n    return Transaction;\n  }();\n  /**\n   * \n   * @param s\n   * @returns {boolean}\n   */\n\n\n  function isBytes(s) {\n    return s instanceof Uint8Array || s instanceof ArrayBuffer;\n  }\n  /**\n   * convert uint8array or array buffer to uint8 array\n   * @param {Uint8Array | ArrayBuffer} data\n   * @returns {Uint8Array}\n   */\n\n\n  function toU8Arr(data) {\n    assert(isBytes(data), \"\".concat(data, \" is not uint8array or arraybuffer\"));\n    if (data instanceof ArrayBuffer) return new Uint8Array(data);\n    return data;\n  }\n  /**\n   *  number\n   * @param {Uint8Array | ArrayBuffer} bytes\n   * @returns {number}\n   */\n\n\n  function byteArrayToInt(bytes) {\n    bytes = toU8Arr(bytes);\n    var ret = 0;\n\n    for (var i = 0; i < bytes.length; i++) {\n      var u = bytes[bytes.length - i - 1];\n      ret += u << i * 8;\n    }\n\n    return ret;\n  }\n  /**\n   * \n   * @param { ArrayBuffer | Uint8Array } buf binary\n   * @returns {string} encoded result\n   */\n\n\n  function encodeHex(buf) {\n    buf = toU8Arr(buf);\n    var out = \"\";\n\n    for (var i = 0; i < buf.length; i++) {\n      var n = buf[i].toString(16);\n      if (n.length === 1) n = '0' + n;\n      out += n;\n    }\n\n    return out;\n  }\n  /**\n   * decode binary as utf8 string\n   * @param { Uint8Array | ArrayBuffer } bin\n   * @returns {string} decoded result\n   */\n\n\n  function bin2str(bin) {\n    bin = toU8Arr(bin);\n    if (isBrowser) return new TextDecoder().decode(bin);\n    return Buffer.from(bin).toString('utf8');\n  }\n  /**\n   * convert string to binary\n   * @param { string } str\n   * @returns {Uint8Array}\n   */\n\n\n  function str2bin(str) {\n    if (isBrowser) return new TextEncoder().encode(str);\n    return Buffer.from(str, 'utf8');\n  }\n  /**\n   * pad prefix to size\n   * @param { Uint8Array } arr\n   * @param {number} prefix\n   * @param {number} size\n   */\n\n\n  function padPrefix(arr, prefix, size) {\n    if (arr.length >= size) return arr;\n    var ret = new Uint8Array(size);\n\n    for (var i = 0; i < ret.length; i++) {\n      ret[i + size - arr.length] = arr[i];\n    }\n\n    if (prefix === 0) return ret;\n\n    for (var _i3 = 0; _i3 < size - arr.length; _i3++) {\n      ret[_i3] = prefix;\n    }\n  }\n  /**\n   * number \n   * @param {number} u\n   * @returns {Uint8Array}\n   */\n\n\n  function numberToByteArray(u) {\n    if (u < 0 || !Number.isInteger(u)) throw new Error(\"cannot convert number \".concat(u, \" to byte array\"));\n    var buf = new Uint8Array(8);\n\n    for (var i = 0; i < 8; i++) {\n      buf[buf.length - 1 - i] = u & 0xff;\n      u = u >>> 8;\n    }\n\n    var k = 8;\n\n    for (var _i4 = 0; _i4 < 8; _i4++) {\n      if (buf[_i4] !== 0) {\n        k = _i4;\n        break;\n      }\n    }\n\n    return buf.slice(k, buf.length);\n  }\n\n  function reverse(arr) {\n    var ret = new Uint8Array(arr.length);\n\n    for (var i = 0; i < arr.length; i++) {\n      ret[i] = arr[arr.length - i - 1];\n    }\n\n    return ret;\n  }\n  /**\n   * \n   * @param {Uint8Array} arr\n   */\n\n\n  function f64ToBytes(f) {\n    var buf = new ArrayBuffer(8);\n\n    var _float = new Float64Array(buf);\n\n    _float[0] = f;\n    buf = new Uint8Array(buf);\n    return trimLeadingZeros(reverse(buf));\n  }\n  /**\n   * \n   * @param {Uint8Array} buf\n   */\n\n\n  function bytesToF64(buf) {\n    return new Float64Array(padPrefix(reverse(buf), 0, 8).buffer)[0];\n  }\n  /**\n   * \n   * @param {Uint8Array} arr\n   */\n\n\n  function inverse(arr) {\n    var ret = new Uint8Array(arr.length);\n\n    for (var i = 0; i < ret.length; i++) {\n      ret[i] = ~arr[i] & 0xff;\n    }\n\n    return ret;\n  }\n\n  function isRLPList(encoded) {\n    return encoded[0] >= OFFSET_SHORT_LIST;\n  }\n  /**\n   * encode bytes to rlp\n   * @param { ArrayBuffer | Uint8Array } bytes\n   * @returns { Uint8Array }\n   */\n\n\n  function _encodeBytes(bytes) {\n    if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);\n\n    if (bytes.length === 0) {\n      var _ret = new Uint8Array(1);\n\n      _ret[0] = OFFSET_SHORT_ITEM;\n      return _ret;\n    }\n\n    if (bytes.length === 1 && (bytes[0] & 0xFF) < OFFSET_SHORT_ITEM) {\n      return bytes;\n    }\n\n    if (bytes.length < SIZE_THRESHOLD) {\n      // length = 8X\n      var prefix = OFFSET_SHORT_ITEM + bytes.length;\n\n      var _ret2 = new Uint8Array(bytes.length + 1);\n\n      for (var i = 0; i < bytes.length; i++) {\n        _ret2[i + 1] = bytes[i];\n      }\n\n      _ret2[0] = prefix;\n      return _ret2;\n    }\n\n    var tmpLength = bytes.length;\n    var lengthOfLength = 0;\n\n    while (tmpLength !== 0) {\n      lengthOfLength = lengthOfLength + 1;\n      tmpLength = tmpLength >> 8;\n    }\n\n    var ret = new Uint8Array(1 + lengthOfLength + bytes.length);\n    ret[0] = OFFSET_LONG_ITEM + lengthOfLength; // copy length after first byte\n\n    tmpLength = bytes.length;\n\n    for (var _i5 = lengthOfLength; _i5 > 0; --_i5) {\n      ret[_i5] = tmpLength & 0xFF;\n      tmpLength = tmpLength >> 8;\n    }\n\n    for (var _i6 = 0; _i6 < bytes.length; _i6++) {\n      ret[_i6 + 1 + lengthOfLength] = bytes[_i6];\n    }\n\n    return ret;\n  }\n  /**\n   * encode elements to rlp list\n   * @param { Array<Uint8Array> } elements\n   * @returns { Uint8Array } rlp encoded\n   */\n\n\n  function encodeElements(elements) {\n    var totalLength = 0;\n\n    for (var i = 0; i < elements.length; i++) {\n      var el = elements[i];\n      totalLength += el.length;\n    }\n\n    var data;\n    var copyPos;\n\n    if (totalLength < SIZE_THRESHOLD) {\n      data = new Uint8Array(1 + totalLength);\n      data[0] = OFFSET_SHORT_LIST + totalLength;\n      copyPos = 1;\n    } else {\n      // length of length = BX\n      // prefix = [BX, [length]]\n      var tmpLength = totalLength;\n      var byteNum = 0;\n\n      while (tmpLength !== 0) {\n        ++byteNum;\n        tmpLength = tmpLength >> 8;\n      }\n\n      tmpLength = totalLength;\n      var lenBytes = new Uint8Array(byteNum);\n\n      for (var _i7 = 0; _i7 < byteNum; ++_i7) {\n        lenBytes[byteNum - 1 - _i7] = tmpLength >> 8 * _i7 & 0xFF;\n      } // first byte = F7 + bytes.length\n\n\n      data = new Uint8Array(1 + lenBytes.length + totalLength);\n      data[0] = OFFSET_LONG_LIST + byteNum;\n\n      for (var _i8 = 0; _i8 < lenBytes.length; _i8++) {\n        data[_i8 + 1] = lenBytes[_i8];\n      }\n\n      copyPos = lenBytes.length + 1;\n    }\n\n    for (var _i9 = 0; _i9 < elements.length; _i9++) {\n      var _el = elements[_i9];\n\n      for (var j = 0; j < _el.length; j++) {\n        data[j + copyPos] = _el[j];\n      }\n\n      copyPos += _el.length;\n    }\n\n    return data;\n  }\n  /**\n   *\n   * @param {Array<Uint8Array> | Uint8Array}x\n   * @param { Uint8Array } [y]\n   * @returns {Uint8Array}\n   */\n\n\n  function concatBytes(x, y) {\n    if (Array.isArray(x)) {\n      assert(y === undefined, \"concat bytes failed, y is not allowed here\");\n      var _ret3 = EMPTY_BYTES;\n\n      var _iterator = _createForOfIteratorHelper(x),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var el = _step.value;\n          _ret3 = concatBytes(_ret3, el);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return _ret3;\n    }\n\n    if (!y) return x;\n    x = toU8Arr(x);\n    y = toU8Arr(y);\n    var ret = new Uint8Array(x.length + y.length);\n\n    for (var i = 0; i < x.length; i++) {\n      ret[i] = x[i];\n    }\n\n    for (var _i10 = 0; _i10 < y.length; _i10++) {\n      ret[x.length + _i10] = y[_i10];\n    }\n\n    return ret;\n  }\n\n  function copyOfRange(bytes, from, to) {\n    var ret = new Uint8Array(to - from);\n    var j = 0;\n\n    for (var i = from; i < to; i++) {\n      ret[j] = bytes[i];\n      j++;\n    }\n\n    return ret;\n  }\n\n  function estimateSize(encoded) {\n    var parser = new RLPParser(encoded, 0, encoded.length);\n    return parser.peekSize();\n  }\n\n  function validateSize(encoded) {\n    assert(encoded.length === estimateSize(encoded), 'invalid rlp format');\n  }\n\n  var RLP = /*#__PURE__*/function () {\n    function RLP() {\n      _classCallCheck(this, RLP);\n    }\n\n    _createClass(RLP, null, [{\n      key: \"encodeString\",\n\n      /**\n       * rlp encode\n       * @param {string} s\n       * @return {Uint8Array}\n       */\n      value: function encodeString(s) {\n        return _encodeBytes(str2bin(s));\n      }\n      /**\n       * rlp encode\n       * @param {Uint8Array | ArrayBuffer} bytes\n       * @return {Uint8Array}\n       */\n\n    }, {\n      key: \"encodeBytes\",\n      value: function encodeBytes(bytes) {\n        return _encodeBytes(bytes);\n      }\n      /**\n       *\n       * @param { Uint8Array | string | Array | ArrayBuffer | number | BN | null | Transaction} o\n       */\n\n    }, {\n      key: \"encode\",\n      value: function encode(o) {\n        if (o && o.getEncoded) {\n          return o.getEncoded();\n        }\n\n        if (o === null || o === undefined) return NULL_RLP;\n        if (o instanceof ArrayBuffer) o = new Uint8Array(o);\n        if (typeof o === 'string') return RLP.encodeString(o);\n\n        if (typeof o === 'number') {\n          assert(o >= 0 && Number.isInteger(o), \"\".concat(o, \" is not a valid non-negative integer\"));\n          return RLP.encodeBytes(numberToByteArray(o));\n        }\n\n        if (typeof o === 'boolean') return o ? new Uint8Array([0x01]) : NULL_RLP;\n\n        if (o instanceof BN) {\n          return RLP.encodeBytes(trimLeadingZeros(o.toArrayLike(Uint8Array, 'be')));\n        }\n\n        if (o instanceof Uint8Array) return RLP.encodeBytes(o);\n\n        if (Array.isArray(o)) {\n          var elements = o.map(function (x) {\n            return RLP.encode(x);\n          });\n          return encodeElements(elements);\n        }\n      }\n      /**\n       * decode\n       * @param { ArrayBuffer | Uint8Array } encoded encoded rlp bytes\n       * @returns { Array | Uint8Array }\n       */\n\n    }, {\n      key: \"decode\",\n      value: function decode(encoded) {\n        if (encoded instanceof ArrayBuffer) encoded = new Uint8Array(encoded);\n        validateSize(encoded);\n\n        if (!isRLPList(encoded)) {\n          var _parser = new RLPParser(encoded, 0, encoded.length);\n\n          if (encoded.length === 1 && encoded[0] === 0x80) return EMPTY_BYTES;\n\n          if (_parser.remained() > 1) {\n            _parser.skip(_parser.prefixLength());\n          }\n\n          return _parser.bytes(_parser.remained());\n        }\n\n        var parser = new RLPParser(encoded, 0, encoded.length);\n        parser.skip(parser.prefixLength());\n        var ret = [];\n\n        while (parser.remained() > 0) {\n          ret.push(RLP.decode(parser.bytes(parser.peekSize())));\n        }\n\n        return ret;\n      }\n    }]);\n\n    return RLP;\n  }();\n\n  var RLPParser = /*#__PURE__*/function () {\n    function RLPParser(buf, offset, limit) {\n      _classCallCheck(this, RLPParser);\n\n      this.buf = buf;\n      this.offset = offset;\n      this.limit = limit;\n    }\n\n    _createClass(RLPParser, [{\n      key: \"prefixLength\",\n      value: function prefixLength() {\n        var prefix = this.buf[this.offset];\n\n        if (prefix <= OFFSET_LONG_ITEM) {\n          return 1;\n        }\n\n        if (prefix < OFFSET_SHORT_LIST) {\n          return 1 + (prefix - OFFSET_LONG_ITEM);\n        }\n\n        if (prefix <= OFFSET_LONG_LIST) {\n          return 1;\n        }\n\n        return 1 + (prefix - OFFSET_LONG_LIST);\n      }\n    }, {\n      key: \"remained\",\n      value: function remained() {\n        return this.limit - this.offset;\n      }\n    }, {\n      key: \"skip\",\n      value: function skip(n) {\n        this.offset += n;\n      }\n    }, {\n      key: \"peekSize\",\n      value: function peekSize() {\n        var prefix = this.buf[this.offset];\n\n        if (prefix < OFFSET_SHORT_ITEM) {\n          return 1;\n        }\n\n        if (prefix <= OFFSET_LONG_ITEM) {\n          return prefix - OFFSET_SHORT_ITEM + 1;\n        }\n\n        if (prefix < OFFSET_SHORT_LIST) {\n          return byteArrayToInt(copyOfRange(this.buf, 1 + this.offset, 1 + this.offset + prefix - OFFSET_LONG_ITEM)) + 1 + prefix - OFFSET_LONG_ITEM;\n        }\n\n        if (prefix <= OFFSET_LONG_LIST) {\n          return prefix - OFFSET_SHORT_LIST + 1;\n        }\n\n        return byteArrayToInt(copyOfRange(this.buf, 1 + this.offset, this.offset + 1 + prefix - OFFSET_LONG_LIST)) + 1 + prefix - OFFSET_LONG_LIST;\n      }\n    }, {\n      key: \"u8\",\n      value: function u8() {\n        var ret = this.buf[this.offset];\n        this.offset++;\n        return ret;\n      }\n    }, {\n      key: \"bytes\",\n      value: function bytes(n) {\n        assert(this.offset + n <= this.limit, 'read overflow');\n        var ret = this.buf.slice(this.offset, this.offset + n);\n        this.offset += n;\n        return ret;\n      }\n    }]);\n\n    return RLPParser;\n  }();\n\n  var ABI_DATA_TYPE = {\n    BOOL: 'bool',\n    // 0\n    I64: 'i64',\n    // 1\n    U64: 'u64',\n    //  2 BN\n    F64: 'f64',\n    STRING: 'string',\n    // 3 string\n    BYTES: 'bytes',\n    // 4\n    ADDRESS: 'address',\n    // 5\n    U256: 'u256' // 6\n\n  };\n  var ABI_DATA_ENUM = {\n    'bool': 0,\n    // 0\n    'i64': 1,\n    // 1\n    'u64': 2,\n    //  2 BN\n    'f64': 3,\n    'string': 4,\n    // 3 string\n    'bytes': 5,\n    // 4\n    'address': 6,\n    // 5\n    'u256': 7 // 6\n\n  };\n  var ABI_TYPE = {\n    EVENT: 'event',\n    FUNCTION: 'function'\n  };\n  /**\n   *\n   * @param {string | Uint8Array | number | BN | ArrayBuffer} o before abi encode\n   * @param type encode target\n   * @returns { Uint8Array | string | BN }\n   */\n\n  function convert(o, type) {\n    if (o instanceof ArrayBuffer) o = toU8Arr(o);\n\n    if (o instanceof Uint8Array) {\n      switch (type) {\n        case ABI_DATA_TYPE.BOOL:\n        case ABI_DATA_TYPE.U256:\n        case ABI_DATA_TYPE.I64:\n        case ABI_DATA_TYPE.U64:\n        case ABI_DATA_TYPE.F64:\n          {\n            throw new Error('cannot convert uint8array to u64, u256 or bool');\n          }\n\n        case ABI_DATA_TYPE.STRING:\n          {\n            throw new Error('cannot convert uint8array to string');\n          }\n\n        case ABI_DATA_TYPE.BYTES:\n          return o;\n\n        case ABI_DATA_TYPE.ADDRESS:\n          return normalizeAddress(o);\n      }\n\n      throw new Error(\"unexpected abi type \" + type);\n    }\n\n    if (typeof o === 'string') {\n      switch (type) {\n        case ABI_DATA_TYPE.U256:\n        case ABI_DATA_TYPE.U64:\n          {\n            var _ret4;\n\n            if (o.substr(0, 2) === '0x') {\n              _ret4 = new BN(o.substr(2, o.length - 2), 16);\n            } else {\n              _ret4 = new BN(o, 10);\n            }\n\n            if (type === ABI_DATA_TYPE.U64) assert(_ret4.cmp(MAX_U64) <= 0 && !_ret4.isNeg(), \"\".concat(_ret4.toString(10), \" overflows max u64 \").concat(MAX_U64.toString(10)));\n            if (type === ABI_DATA_TYPE.U256) assert(_ret4.cmp(MAX_U256) <= 0 && !_ret4.isNeg(), \"\".concat(_ret4.toString(10), \" overflows max u256 \").concat(MAX_U256.toString(10)));\n            return _ret4;\n          }\n\n        case ABI_DATA_TYPE.I64:\n          {\n            if (o.substr(0, 2) === '0x') {\n              var _ret5 = new BN(o.substr(2, o.length - 2), 16);\n\n              assert(_ret5.cmp(MAX_I64) <= 0, \"\".concat(_ret5.toString(10), \" overflows max i64 \").concat(MAX_I64.toString(10)));\n              assert(_ret5.cmp(MIN_I64) >= 0, \"\".concat(_ret5.toString(10), \" overflows min i64 \").concat(MIN_I64.toString(10)));\n              return _ret5;\n            }\n\n            return convert(parseInt(o), ABI_DATA_TYPE.I64);\n          }\n\n        case ABI_DATA_TYPE.F64:\n          {\n            var f = parseFloat(o);\n            return f64ToBytes(f);\n          }\n\n        case ABI_DATA_TYPE.STRING:\n          {\n            return o;\n          }\n\n        case ABI_DATA_TYPE.BOOL:\n          {\n            var l = o.toLowerCase();\n            if ('true' === l) return 1;\n            if ('false' === l) return 0;\n            if (isNaN(o)) throw new Error(\"cannot convert \".concat(o, \" to bool\"));\n            l = parseInt(o);\n            if (1 === l || 0 === l) return l;\n            throw new Error(\"convert \".concat(l, \" to bool failed, provide 1 or 0\"));\n          }\n\n        case ABI_DATA_TYPE.BYTES:\n          return decodeHex(o);\n\n        case ABI_DATA_TYPE.ADDRESS:\n          {\n            return normalizeAddress(o);\n          }\n      }\n\n      throw new Error(\"unexpected abi type \" + type);\n    }\n\n    if (typeof o === 'number') {\n      switch (type) {\n        case ABI_DATA_TYPE.U256:\n        case ABI_DATA_TYPE.U64:\n          {\n            if (o < 0 || !Number.isInteger(o)) throw new Error('o is negative or not a integer');\n            return new BN(o);\n          }\n\n        case ABI_DATA_TYPE.STRING:\n          {\n            return o.toString(10);\n          }\n\n        case ABI_DATA_TYPE.BOOL:\n          {\n            if (1 === o || 0 === o) return o;\n            throw new Error(\"convert \".concat(o, \" to bool failed, provide 1 or 0\"));\n          }\n\n        case ABI_DATA_TYPE.BYTES:\n        case ABI_DATA_TYPE.ADDRESS:\n          {\n            throw new Error(\"cannot convert number to address or bytes\");\n          }\n\n        case ABI_DATA_TYPE.I64:\n          {\n            if (!Number.isInteger(o)) throw new Error('o is negative or not a integer');\n            if (o >= 0) return new BN(o);\n            return convert(new BN(o), ABI_DATA_TYPE.I64);\n          }\n\n        case ABI_DATA_TYPE.F64:\n          {\n            return f64ToBytes(o);\n          }\n      }\n\n      throw new Error(\"unexpected abi type \" + type);\n    }\n\n    if (o instanceof BN) {\n      switch (type) {\n        case ABI_DATA_TYPE.U256:\n        case ABI_DATA_TYPE.U64:\n          {\n            if (o.isNeg()) throw new Error(\"cannot convert negative \".concat(o.toString(), \" to uint\"));\n            return o;\n          }\n\n        case ABI_DATA_TYPE.STRING:\n          {\n            return o.toString(10);\n          }\n\n        case ABI_DATA_TYPE.BYTES:\n        case ABI_DATA_TYPE.ADDRESS:\n          {\n            throw new Error(\"cannot convert big number to address or bytes\");\n          }\n\n        case ABI_DATA_TYPE.BOOL:\n          {\n            if (o.cmp(new BN(1)) === 0 || o.cmp(new BN(0)) === 0) return o;\n            throw new Error(\"convert \".concat(o, \" to bool failed, provide 1 or 0\"));\n          }\n\n        case ABI_DATA_TYPE.I64:\n          {\n            assert(o.cmp(MAX_I64) <= 0, \"\".concat(o.toString(10), \" overflows max i64 \").concat(MAX_I64.toString(10)));\n            assert(o.cmp(MIN_I64) >= 0, \"\".concat(o.toString(10), \" overflows min i64 \").concat(MIN_I64.toString(10)));\n            if (o.cmp(new BN(0)) >= 0) return ret;\n            var buf = o.neg().toArray(Uint8Array, 8);\n            buf = inverse(buf);\n            return new BN(buf, 'be').add(ONE);\n          }\n\n        case ABI_DATA_TYPE.F64:\n          {\n            return f64ToBytes(o.toNumber());\n          }\n      }\n\n      throw new Error(\"unexpected abi type \" + type);\n    }\n\n    if (typeof o === 'boolean') {\n      switch (type) {\n        case ABI_DATA_TYPE.U256:\n        case ABI_DATA_TYPE.I64:\n        case ABI_DATA_TYPE.U64:\n          {\n            return o ? 1 : 0;\n          }\n\n        case ABI_DATA_TYPE.STRING:\n          {\n            return o.toString();\n          }\n\n        case ABI_DATA_TYPE.BYTES:\n        case ABI_DATA_TYPE.ADDRESS:\n          {\n            throw new Error(\"cannot convert boolean to address or bytes\");\n          }\n\n        case ABI_DATA_TYPE.BOOL:\n          {\n            return o ? 1 : 0;\n          }\n\n        case ABI_DATA_TYPE.F64:\n          {\n            return f64ToBytes(o ? 1 : 0);\n          }\n      }\n\n      throw new Error(\"unexpected abi type \" + type);\n    }\n\n    throw new Error(\"unexpected type \" + o);\n  }\n\n  var Contract = /*#__PURE__*/function () {\n    /**\n     *\n     * @param {string} address \n     * @param { Array<ABI> } abi  abi\n     * @param {Uint8Array} [binary] \n     */\n    function Contract(address, abi, binary) {\n      _classCallCheck(this, Contract);\n\n      this.address = address;\n      this.abi = (abi || []).map(ABI.from);\n      this.binary = binary;\n    }\n    /**\n     *\n     * @param {string} name \n     * @param { Array | Object } li \n     * @returns { Array } rlp  \n     */\n\n\n    _createClass(Contract, [{\n      key: \"abiEncode\",\n      value: function abiEncode(name, li) {\n        var func = this.getABI(name, ABI_TYPE.FUNCTION);\n        var retType = func.outputs && func.outputs[0] && func.outputs[0].type;\n        var retTypes = retType ? [ABI_DATA_ENUM[retType]] : [];\n        if (typeof li === 'string' || typeof li === 'number' || li instanceof BN || li instanceof ArrayBuffer || li instanceof Uint8Array || typeof li === 'boolean') return this.abiEncode([li]);\n        if (li === undefined || li === null) return [[], [], retTypes];\n\n        if (Array.isArray(li)) {\n          var _arr = [];\n          var _types = [];\n          if (li.length != func.inputs.length) throw new Error(\"abi encode failed for \".concat(func.name, \", expect \").concat(func.inputs.length, \" parameters while \").concat(li.length, \" found\"));\n\n          for (var i = 0; i < li.length; i++) {\n            _arr[i] = convert(li[i], func.inputs[i].type);\n            _types[i] = ABI_DATA_ENUM[func.inputs[i].type];\n          }\n\n          return [_types, _arr, retTypes];\n        }\n\n        var arr = [];\n        var types = [];\n\n        for (var _i11 = 0; _i11 < func.inputs.length; _i11++) {\n          var input = func.inputs[_i11];\n          types[_i11] = ABI_DATA_ENUM[func.inputs[_i11].type];\n\n          if (!(input.name in li)) {\n            throw new Error(\"key \".concat(input.name, \" not found in parameters\"));\n          }\n\n          arr[_i11] = convert(li[input.name], input.type);\n        }\n\n        return [types, arr, retTypes];\n      }\n      /**\n       *\n       * @param name {string} \n       * @param buf { Uint8Array | string | Array<Uin8Array> }\n       * @returns { Array | Object } rlp \n       * @param {string} [type] \n       */\n\n    }, {\n      key: \"abiDecode\",\n      value: function abiDecode(name, buf, type) {\n        type = type || ABI_TYPE.FUNCTION;\n        if (!buf) buf = '';\n        if (typeof buf === 'string') buf = decodeHex(buf);\n        if (buf.length === 0) return [];\n        var a = this.getABI(name, type);\n\n        var ret = _abiDecode(a.outputs, buf);\n\n        if (type === ABI_TYPE.FUNCTION) return ret && ret[0];\n        return ret;\n      }\n      /**\n       *  paylod\n       */\n\n    }, {\n      key: \"abiToBinary\",\n      value: function abiToBinary() {\n        var ret = [];\n\n        var _iterator2 = _createForOfIteratorHelper(this.abi),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var a = _step2.value;\n            ret.push([a.name, a.type === ABI_TYPE.FUNCTION ? 0 : 1, a.inputs.map(function (x) {\n              return ABI_DATA_ENUM[x.type];\n            }), a.outputs.map(function (x) {\n              return ABI_DATA_ENUM[x.type];\n            })]);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return ret;\n      }\n      /**\n       *\n       * @param {string} name\n       * @param {string} type\n       * @returns {ABI}\n       */\n\n    }, {\n      key: \"getABI\",\n      value: function getABI(name, type) {\n        var funcs = this.abi.filter(function (x) {\n          return x.type === type && x.name === name;\n        });\n        assert(funcs.length === 1, \"exact exists one and only one abi \".concat(name, \", while found \").concat(funcs.length));\n        return funcs[0];\n      }\n    }]);\n\n    return Contract;\n  }();\n\n  var WS_CODES = {\n    NULL: 0,\n    EVENT_EMIT: 1,\n    EVENT_SUBSCRIBE: 2,\n    TRANSACTION_EMIT: 3,\n    TRANSACTION_SUBSCRIBE: 4,\n    TRANSACTION_SEND: 5,\n    ACCOUNT_QUERY: 6,\n    CONTRACT_QUERY: 7\n  };\n\n  var RPC = /*#__PURE__*/function () {\n    /**\n     *\n     * @param {string} host  \n     * @param {string | number} port  \n     */\n    function RPC(host, port) {\n      _classCallCheck(this, RPC);\n\n      this.host = host || 'localhost';\n      this.port = port || 80;\n      this.__callbacks = new Map(); // id -> function\n\n      this.__id2key = new Map(); // id -> address:event\n\n      this.__id2hash = new Map(); // id -> txhash\n\n      this.__eventHandlers = new Map(); // address:event -> [id]\n\n      this.__txObservers = new Map(); // hash -> [id]\n\n      this.__cid = 0;\n      this.__rpcCallbacks = new Map(); // nonce -> cb\n\n      this.__nonce = 0;\n    }\n\n    _createClass(RPC, [{\n      key: \"__tryConnect\",\n      value: function __tryConnect() {\n        var _this = this;\n\n        var WS = isBrowser ? WebSocket : __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\");\n\n        if (this.__ws && this.__ws.readyState === WS.OPEN) {\n          return Promise.resolve(this);\n        }\n\n        if (this.__ws) {\n          var fn = this.__ws.onopen || function () {};\n\n          var _p = new Promise(function (rs, rj) {\n            _this.__ws.onopen = function () {\n              fn(_this.__ws);\n              rs(_this.__ws);\n            };\n          });\n\n          return _p;\n        }\n\n        this.__uuid = uuidv4();\n        this.__ws = new WS(\"ws://\".concat(this.host, \":\").concat(this.port || 80, \"/websocket/\").concat(this.__uuid));\n        this.__ws.onerror = console.error;\n\n        this.__ws.onmessage = function (e) {\n          if (!isBrowser) {\n            _this.__handleData(e.data);\n\n            return;\n          }\n\n          var reader = new FileReader();\n\n          reader.onload = function () {\n            var arrayBuffer = reader.result;\n\n            _this.__handleData(new Uint8Array(arrayBuffer));\n          };\n\n          reader.readAsArrayBuffer(e.data);\n        };\n\n        var p = new Promise(function (rs, rj) {\n          _this.__ws.onopen = rs;\n        });\n        return p;\n      }\n    }, {\n      key: \"__handleData\",\n      value: function __handleData(data) {\n        var decoded = RLP.decode(data);\n        var nonce = byteArrayToInt(decoded[0]);\n        var code = byteArrayToInt(decoded[1]);\n        var body = decoded[2];\n\n        switch (code) {\n          case WS_CODES.TRANSACTION_EMIT:\n            {\n              var h = encodeHex(body[0]);\n              var s = byteArrayToInt(body[1]);\n              var d = null;\n              if (s === TX_STATUS.DROPPED) d = bin2str(body[2]);\n\n              if (s === TX_STATUS.INCLUDED) {\n                var arr = body[2];\n                d = {\n                  blockHeight: toSafeInt(arr[0]),\n                  blockHash: encodeHex(arr[1]),\n                  gasUsed: toSafeInt(arr[2]),\n                  result: arr[3],\n                  events: arr[4]\n                };\n              }\n\n              var funcIds = this.__txObservers.get(h) || [];\n\n              var _iterator3 = _createForOfIteratorHelper(funcIds),\n                  _step3;\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var funcId = _step3.value;\n\n                  var func = this.__callbacks.get(funcId);\n\n                  func(h, s, d);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n\n              return;\n            }\n\n          case WS_CODES.EVENT_EMIT:\n            {\n              var addr = encodeHex(body[0]);\n              var event = bin2str(body[1]);\n\n              var _funcIds = this.__eventHandlers.get(\"\".concat(addr, \":\").concat(event)) || [];\n\n              var _iterator4 = _createForOfIteratorHelper(_funcIds),\n                  _step4;\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var _funcId = _step4.value;\n\n                  var _func = this.__callbacks.get(_funcId);\n\n                  _func(addr, event, body[2]);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n              return;\n            }\n        }\n\n        if (nonce) {\n          var fn = this.__rpcCallbacks.get(nonce);\n\n          if (fn) fn(body);\n\n          this.__rpcCallbacks[\"delete\"](nonce);\n        }\n      }\n      /**\n       * \n       * @param {Contract} contract \n       * @param {string} event \n       * @param {Function} func  {name: event, data: data}\n       * @returns {number}  id\n       */\n\n    }, {\n      key: \"__listen\",\n      value: function __listen(contract, event, func) {\n        var addr = normalizeAddress(contract.address);\n        var addrHex = encodeHex(addr);\n\n        this.__wsRpc(WS_CODES.EVENT_SUBSCRIBE, addr);\n\n        var id = ++this.__cid;\n        var key = \"\".concat(addrHex, \":\").concat(event);\n\n        this.__id2key.set(id, key);\n\n        var fn = function fn(_, event, parameters) {\n          var abiDecoded = contract.abiDecode(event, parameters, ABI_TYPE.EVENT);\n          func(abiDecoded);\n        };\n\n        if (!this.__eventHandlers.has(key)) this.__eventHandlers.set(key, new Set());\n\n        this.__eventHandlers.get(key).add(id);\n\n        this.__callbacks.set(id, fn);\n\n        return id;\n      }\n    }, {\n      key: \"listen\",\n      value: function listen(contract, event, func) {\n        var _this2 = this;\n\n        if (func === undefined) {\n          return new Promise(function (rs, rj) {\n            _this2.__listen(contract, event, rs);\n          });\n        }\n\n        assert(typeof func === 'function', 'callback should be function');\n\n        this.__listen(contract, event, func);\n      }\n      /**\n       * \n       * @param {number} id  id\n       */\n\n    }, {\n      key: \"removeListener\",\n      value: function removeListener(id) {\n        var key = this.__id2key.get(id);\n\n        var h = this.__id2hash.get(id);\n\n        this.__callbacks[\"delete\"](id);\n\n        this.__id2key[\"delete\"](id);\n\n        this.__id2hash[\"delete\"](id);\n\n        if (key) {\n          var set = this.__eventHandlers.get(key);\n\n          set && set[\"delete\"](id);\n          if (set && set.size === 0) this.__eventHandlers[\"delete\"](key);\n        }\n\n        if (h) {\n          var _set = this.__txObservers.get(h);\n\n          _set && _set[\"delete\"](id);\n          if (_set && _set.size === 0) this.__txObservers[\"delete\"](h);\n        }\n      }\n    }, {\n      key: \"listenOnce\",\n      value: function listenOnce(contract, event, func) {\n        var _this3 = this;\n\n        var id = this.__cid + 1;\n        if (func === undefined) return this.listen(contract, event).then(function (r) {\n          _this3.removeListener(id);\n\n          return r;\n        });\n        return this.listen(contract, event, function (p) {\n          func(p);\n\n          _this3.removeListener(id);\n        });\n      }\n      /**\n       * \n       * @param {string | Uint8Array | ArrayBuffer} hash\n       * @param { Function } cb  (hash, status, msg)\n       * @returns {number}\n       */\n\n    }, {\n      key: \"__observe\",\n      value: function __observe(hash, cb) {\n        var _this4 = this;\n\n        var id = ++this.__cid;\n        if (isBytes(hash)) hash = encodeHex(hash);\n        hash = hash.toLowerCase();\n        if (!this.__txObservers.has(hash)) this.__txObservers.set(hash, new Set());\n\n        this.__id2hash.set(id, hash);\n\n        this.__txObservers.get(hash).add(id);\n\n        var fn = function fn(h, s, d) {\n          cb(h, s, d);\n\n          switch (s) {\n            case TX_STATUS.DROPPED:\n            case TX_STATUS.CONFIRMED:\n              _this4.removeListener(id);\n\n              break;\n          }\n        };\n\n        this.__callbacks.set(id, fn);\n\n        return id;\n      }\n      /**\n       * \n       * @param  { Contract } contract \n       * @param {string} method  \n       * @param { Object | Array } parameters  \n       * @returns {Promise<Object>}\n       */\n\n    }, {\n      key: \"viewContract\",\n      value: function viewContract(contract, method, parameters) {\n        if (!contract instanceof Contract) throw new Error('create a instanceof Contract by new tool.Contract(addr, abi)');\n        parameters = normalizeParams(parameters);\n        var addr = contract.address;\n        var params = contract.abiEncode(method, parameters);\n        return this.__wsRpc(WS_CODES.CONTRACT_QUERY, [normalizeAddress(addr), method, params]).then(function (r) {\n          return contract.abiDecode(method, r);\n        });\n      }\n      /**\n       *  websocket \n       * @param tx {Transaction | Array<Transaction> }\n       * @returns {Promise<Object>}\n       */\n\n    }, {\n      key: \"sendTransaction\",\n      value: function sendTransaction(tx) {\n        return this.__wsRpc(WS_CODES.TRANSACTION_SEND, [Array.isArray(tx), tx]);\n      }\n      /**\n       *\n       * @param { Transaction } tx\n       * @param status\n       * @param { number } timeout\n       */\n\n    }, {\n      key: \"observe\",\n      value: function observe(tx, status, timeout) {\n        var _this5 = this;\n\n        status = status === undefined ? TX_STATUS.CONFIRMED : status;\n        return new Promise(function (resolve, reject) {\n          var success = false;\n          if (timeout) setTimeout(function () {\n            if (success) return;\n            reject({\n              reason: 'timeout'\n            });\n          }, timeout);\n          var ret = null;\n          var confirmed = false;\n          var included = false;\n\n          _this5.__observe(tx.getHash(), function (h, s, d) {\n            if (s === TX_STATUS.DROPPED) {\n              var e = {\n                hash: h,\n                reason: d\n              };\n              reject(e);\n              return;\n            }\n\n            if (s === TX_STATUS.CONFIRMED) {\n              if (status === TX_STATUS.INCLUDED) return;\n              confirmed = true;\n\n              if (included) {\n                success = true;\n                resolve(ret);\n                return;\n              }\n            }\n\n            if (s === TX_STATUS.INCLUDED) {\n              included = true;\n              ret = {\n                blockHeight: d.blockHeight,\n                blockHash: d.blockHash,\n                gasUsed: d.gasUsed\n              };\n\n              if (d.result && d.result.length && tx.__abi && tx.isDeployOrCall()) {\n                var decoded = new Contract('', tx.__abi).abiDecode(tx.getMethod(), d.result);\n                ret.result = decoded;\n              }\n\n              if (d.events.length && tx.__abi) {\n                var events = [];\n\n                var _iterator5 = _createForOfIteratorHelper(d.events),\n                    _step5;\n\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    var _e = _step5.value;\n                    var name = bin2str(_e[0]);\n\n                    var _decoded = new Contract('', tx.__abi).abiDecode(name, _e[1], ABI_TYPE.EVENT);\n\n                    events.push({\n                      name: name,\n                      data: _decoded\n                    });\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n\n                ret.events = events;\n              }\n\n              ret.transactionHash = encodeHex(tx.getHash());\n              ret.fee = toSafeInt(new BN(tx.gasPrice).mul(new BN(ret.gasUsed)));\n\n              if (tx.isDeployOrCall()) {\n                ret.method = tx.getMethod();\n                ret.inputs = tx.__inputs;\n              }\n\n              if (status === TX_STATUS.INCLUDED) {\n                success = true;\n                resolve(ret);\n                return;\n              }\n\n              if (confirmed) {\n                success = true;\n                resolve(ret);\n              }\n            }\n          });\n        });\n      }\n    }, {\n      key: \"__wsRpc\",\n      value: function __wsRpc(code, data) {\n        var _this6 = this;\n\n        this.__nonce++;\n        var n = this.__nonce;\n        var ret = new Promise(function (rs, rj) {\n          _this6.__rpcCallbacks.set(n, rs);\n        });\n\n        this.__tryConnect().then(function () {\n          var encoded = RLP.encode([n, code, data]);\n\n          _this6.__ws.send(encoded);\n        });\n\n        return ret;\n      }\n      /**\n       * \n       * @param { Transaction | Array<Transaction> } tx\n       * @returns { Promise<Transaction> }\n       */\n\n    }, {\n      key: \"sendAndObserve\",\n      value: function sendAndObserve(tx, status, timeout) {\n        var _this7 = this;\n\n        var ret;\n        var p;\n        var sub;\n\n        if (Array.isArray(tx)) {\n          p = [];\n          var arr = [];\n          sub = this.__wsRpc(WS_CODES.TRANSACTION_SUBSCRIBE, tx.map(function (t) {\n            return decodeHex(t.getHash());\n          }));\n\n          var _iterator6 = _createForOfIteratorHelper(tx),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var t = _step6.value;\n              arr.push(this.observe(t, status, timeout));\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          p = Promise.all(p);\n          ret = Promise.all(arr);\n        } else {\n          sub = this.__wsRpc(WS_CODES.TRANSACTION_SUBSCRIBE, decodeHex(tx.getHash()));\n          ret = this.observe(tx, status, timeout);\n        }\n\n        return sub.then(function () {\n          return _this7.sendTransaction(tx);\n        }).then(function () {\n          return ret;\n        });\n      }\n      /**\n       * \n       * @param hash \n       * @returns {Promise<Object>}\n       */\n\n    }, {\n      key: \"getTransaction\",\n      value: function (_getTransaction) {\n        function getTransaction(_x) {\n          return _getTransaction.apply(this, arguments);\n        }\n\n        getTransaction.toString = function () {\n          return _getTransaction.toString();\n        };\n\n        return getTransaction;\n      }(function (hash) {\n        return getTransaction(this.host, this.port, hash);\n      })\n      /**\n       *  nonce\n       * @param pkOrAddress {string | Uint8Array | ArrayBuffer } \n       * @returns {Promise<string | number>}\n       */\n\n    }, {\n      key: \"getNonce\",\n      value: function getNonce(pkOrAddress) {\n        pkOrAddress = normalizeAddress(pkOrAddress);\n        return this.__wsRpc(WS_CODES.ACCOUNT_QUERY, pkOrAddress).then(function (resp) {\n          var decoded = resp;\n          return toSafeInt(new BN(decoded[0][2], 'be'));\n        });\n      }\n      /**\n       *  \n       * @param pkOrAddress {string | Uint8Array | ArrayBuffer } \n       * @returns {Promise<string | number>}\n       */\n\n    }, {\n      key: \"getBalance\",\n      value: function getBalance(pkOrAddress) {\n        pkOrAddress = normalizeAddress(pkOrAddress);\n        return this.__wsRpc(WS_CODES.ACCOUNT_QUERY, pkOrAddress).then(function (resp) {\n          var decoded = resp;\n          return toSafeInt(new BN(decoded[0][3], 'be'));\n        });\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (this.__ws) {\n          var __ws = this.__ws;\n          this.__ws = null;\n\n          __ws.close();\n        }\n      }\n    }]);\n\n    return RPC;\n  }();\n\n  var TransactionBuilder = /*#__PURE__*/function () {\n    /**\n     * @param {string | number | BN } version\n     * @param {string | Uint8Array} sk  \n     * @param {string | number | BN } [ gasLimit ]\n     * @param {number | undefined} [ gasPrice ]   *  = \n     * @param { number | string | BN } [ nonce ]  nonce\n     */\n    function TransactionBuilder(version, sk, gasLimit, gasPrice, nonce) {\n      _classCallCheck(this, TransactionBuilder);\n\n      this.version = version;\n      this.sk = sk;\n      this.gasPrice = gasPrice || 0;\n\n      if (nonce) {\n        nonce = typeof nonce === 'string' ? nonce : nonce.toString(10);\n      }\n\n      this.gasLimit = gasLimit || 0;\n      this.nonce = nonce || 0;\n    }\n\n    _createClass(TransactionBuilder, [{\n      key: \"increaseNonce\",\n      value: function increaseNonce() {\n        this.nonce = convert(this.nonce, ABI_DATA_TYPE.U64);\n        this.nonce = this.nonce.add(ONE);\n      }\n      /**\n       *  \n       * @param { Contract } contract \n       * @param { Array | Object } [parameters] \n       * @param amount [number]\n       * @returns { Transaction }\n       */\n\n    }, {\n      key: \"buildDeploy\",\n      value: function buildDeploy(contract, parameters, amount) {\n        if (!contract instanceof Contract) throw new Error('create a instanceof Contract by new tool.Contract(addr, abi)');\n        assert(contract.binary && isBytes(contract.binary), 'contract binary is uint8 array');\n        if (!contract.abi) throw new Error('missing contract abi');\n        parameters = normalizeParams(parameters);\n        var inputs = parameters;\n        var binary = contract.binary;\n        if (contract.abi.filter(function (x) {\n          return x.name === 'init';\n        }).length > 0) parameters = contract.abiEncode('init', parameters);else parameters = [[], [], []];\n        var ret = this.buildCommon(constants.WASM_DEPLOY, amount, RLP.encode([this.gasLimit || 0, binary, parameters, contract.abiToBinary()]), new Uint8Array(20));\n        ret.__abi = contract.abi;\n\n        ret.__setInputs(inputs);\n\n        return ret;\n      }\n      /**\n       * \n       * @param { Contract} contract \n       * @param {string} method \n       * @param { Array | Object } [parameters] \n       * @param amount [number] \n       * @returns { Transaction }\n       */\n\n    }, {\n      key: \"buildContractCall\",\n      value: function buildContractCall(contract, method, parameters, amount) {\n        if (!contract instanceof Contract) throw new Error('create a instanceof Contract by new tool.Contract(addr, abi)');\n        if (!contract.abi) throw new Error('missing contract abi');\n        if (!contract.address) throw new Error('missing contract address');\n        parameters = normalizeParams(parameters);\n        var inputs = parameters;\n        var addr = normalizeAddress(contract.address);\n        parameters = contract.abiEncode(method, parameters);\n        var ret = this.buildCommon(constants.WASM_CALL, amount, RLP.encode([this.gasLimit || 0, method, parameters]), encodeHex(addr));\n        ret.__abi = contract.abi;\n\n        ret.__setInputs(inputs);\n\n        return ret;\n      }\n      /**\n       * \n       * @param type {number | string | BN} \n       * @param amount {number | BN | string} \n       * @param payload {string | Uint8Array | ArrayBuffer}\n       * @param to {string | Uint8Array | ArrayBuffer } \n       * @returns { Transaction } \n       */\n\n    }, {\n      key: \"buildCommon\",\n      value: function buildCommon(type, amount, payload, to) {\n        var ret = new Transaction(this.version, type, 0, privateKey2PublicKey(this.sk), this.gasPrice, amount || 0, payload || EMPTY_BYTES, to);\n\n        if (this.nonce) {\n          ret.nonce = asDigitalNumberText(this.nonce);\n          this.increaseNonce();\n          ret.sign(this.sk);\n        }\n\n        return ret;\n      }\n    }]);\n\n    return TransactionBuilder;\n  }();\n\n  var constants = {\n    DEFAULT_TX_VERSION: 1,\n    WASM_DEPLOY: 16,\n    WASM_CALL: 17\n  };\n  /**\n   * \n   * @param ascPath {string}  node_modules/.bin/asc \n   * @param src {string} \n   * @returns {Promise<Uint8Array>}\n   */\n\n  function compileContract(ascPath, src, opts) {\n    var cmd = ascPath + ' ' + src + ' -b '; // \n\n    if (opts && opts.debug) cmd += ' --debug ';\n    if (opts && opts.optimize) cmd += ' --optimize ';\n    if (isBrowser) throw new Error('compile contract is available in node environment');\n    return new Promise(function (resolve, reject) {\n      var child_process = __webpack_require__(/*! child_process */ \"?df8b\");\n\n      child_process.exec(cmd, {\n        encoding: 'buffer'\n      }, function (err, stdout, stderr) {\n        if (err) {\n          // err.code  exit code 0 \n          // err.signal \n          reject(stderr.toString('ascii'));\n        }\n\n        resolve(stdout);\n      });\n    });\n  }\n\n  function rpcPost(host, port, path, data) {\n    if (!path.startsWith('/')) path = '/' + path;\n    data = typeof data === 'string' ? data : JSON.stringify(data);\n\n    if (!isBrowser) {\n      return new Promise(function (resolve, reject) {\n        var opt = {\n          host: host,\n          port: port,\n          path: path,\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Content-Length': data.length\n          }\n        };\n\n        var http = __webpack_require__(/*! http */ \"?d356\");\n\n        var req = http.request(opt, function (res) {\n          var data = \"\";\n          res.on(\"data\", function (d) {\n            data += d;\n          });\n          res.on(\"end\", function () {\n            var d = JSON.parse(data);\n\n            if (d.code === 200) {\n              resolve(d.data);\n              return;\n            }\n\n            reject(d.message);\n          });\n        }).on('error', reject);\n        req.write(data);\n        req.end();\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n          if (xhr.status !== 200) {\n            reject('server error');\n            return;\n          }\n\n          var resp = JSON.parse(xhr.responseText);\n          if (resp.code === 200) resolve(resp.data);else {\n            reject(resp.message);\n          }\n        };\n\n        xhr.open('POST', \"http://\".concat(host, \":\").concat(port).concat(path));\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.send(data);\n      });\n    }\n  }\n  /**\n   * \n   * @param hash {string | Uint8Array} \n   * @param nonce {string | number | BN}  nonce\n   * @returns {string} \n   */\n\n\n  function getContractAddress(hash) {\n    var buf = RLP.encode([decodeHex(hash), 0]);\n    buf = rmd160(buf);\n    return publicKeyHash2Address(buf);\n  }\n\n  var tool = (_tool = {\n    privateKey2PublicKey: privateKey2PublicKey,\n    publicKey2Hash: publicKey2Hash,\n    bin2hex: bin2hex,\n    encodeHex: encodeHex\n  }, _defineProperty(_tool, \"encodeHex\", encodeHex), _defineProperty(_tool, \"rmd160\", rmd160), _defineProperty(_tool, \"address2PublicKeyHash\", address2PublicKeyHash), _defineProperty(_tool, \"assertAddress\", assertAddress), _defineProperty(_tool, \"TransactionBuilder\", TransactionBuilder), _defineProperty(_tool, \"RPC\", RPC), _defineProperty(_tool, \"compileContract\", compileContract), _defineProperty(_tool, \"compileABI\", compileABI), _defineProperty(_tool, \"getContractAddress\", getContractAddress), _defineProperty(_tool, \"Contract\", Contract), _defineProperty(_tool, \"TX_STATUS\", TX_STATUS), _defineProperty(_tool, \"publicKeyHash2Address\", publicKeyHash2Address), _defineProperty(_tool, \"RLP\", RLP), _tool);\n  if (!isBrowser) module.exports = tool;else {\n    window.contractTool = tool;\n  }\n  /**\n   *\n   * @param { ArrayBuffer | Uint8Array | string } str\n   */\n\n  function compileABI(str) {\n    if (isBytes(str)) str = bin2str(str);\n    var TYPES = {\n      u64: 'u64',\n      i64: 'i64',\n      f64: 'f64',\n      bool: 'bool',\n      string: 'string',\n      ArrayBuffer: 'bytes',\n      Address: 'address',\n      U256: 'u256',\n      String: 'string',\n      \"boolean\": 'bool'\n    };\n\n    function getOutputs(str) {\n      if (str === 'void') return [];\n      var ret = TYPES[str];\n      if (!ret) throw new Error(\"invalid type: \".concat(str));\n      return [{\n        \"type\": ret\n      }];\n    }\n\n    function getInputs(str, event) {\n      var ret = [];\n\n      var _iterator7 = _createForOfIteratorHelper(str.split(',')),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var p = _step7.value;\n          if (!p) continue;\n          var lr = p.split(':');\n          var l = lr[0].trim();\n\n          if (event) {\n            if (!l.startsWith('readonly')) throw new Error(\"event constructor field \".concat(l, \" should starts with readonly\"));\n            l = l.split(' ')[1];\n          }\n\n          var r = lr[1].trim();\n          var o = {\n            name: l,\n            type: TYPES[r]\n          };\n          if (!o.type) throw new Error(\"invalid type: \".concat(r));\n          ret.push(o);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return ret;\n    }\n\n    var ret = [];\n    var funRe = /export[\\s\\n\\t]+function[\\s\\n\\t]+([a-zA-Z_][a-zA-Z0-9_]*)[\\s\\n\\t]*\\(([a-z\\n\\s\\tA-Z0-9_,:]*)\\)[\\s\\n\\t]*:[\\s\\n\\t]*([a-zA-Z_][a-zA-Z0-9_]*)[\\s\\n\\t]*{/g;\n    var eventRe = /@unmanaged[\\s\\n\\t]+class[\\s\\n\\t]+([a-zA-Z_][a-zA-Z0-9]*)[\\s\\n\\t]*\\{[\\s\\n\\t]*constructor[\\s\\n\\t]*\\(([a-z\\n\\s\\tA-Z0-9_,:]*)\\)/g;\n    var contains__idof = false;\n\n    var _iterator8 = _createForOfIteratorHelper(str.match(funRe) || []),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var m = _step8.value;\n        funRe.lastIndex = 0;\n        var r = funRe.exec(m);\n\n        if (r[1] === '__idof') {\n          contains__idof = true;\n          continue;\n        }\n\n        ret.push({\n          type: 'function',\n          name: r[1],\n          inputs: getInputs(r[2]),\n          outputs: getOutputs(r[3])\n        });\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    var _iterator9 = _createForOfIteratorHelper(str.match(eventRe) || []),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _m = _step9.value;\n        eventRe.lastIndex = 0;\n\n        var _r = eventRe.exec(_m);\n\n        ret.push({\n          type: 'event',\n          name: _r[1],\n          inputs: [],\n          outputs: getInputs(_r[2], true)\n        });\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    if (!contains__idof) throw new Error('any contract must contains an __idof function');\n    return ret;\n  }\n\n  function uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = Math.random() * 16 | 0,\n          v = c === 'x' ? r : r & 0x3 | 0x8;\n      return v.toString(16);\n    });\n  }\n})();\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract.js?");

/***/ }),

/***/ "./hashes.js":
/*!*******************!*\
  !*** ./hashes.js ***!
  \*******************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, module.loaded, module.id, module, __webpack_require__.nmd, __webpack_require__.g, __webpack_require__.amdO, __webpack_require__, __webpack_require__.* */
/*! CommonJS bailout: exports is used directly at 1805:64-71 */
/*! CommonJS bailout: exports is used directly at 1806:20-27 */
/*! CommonJS bailout: exports is used directly at 1808:10-17 */
/*! CommonJS bailout: module.exports is used directly at 1820:100-114 */
/*! CommonJS bailout: module.exports is used directly at 1821:8-22 */
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * jshashes - https://github.com/h2non/jshashes\n * Released under the \"New BSD\" license\n *\n * Algorithms specification:\n *\n * MD5 - http://www.ietf.org/rfc/rfc1321.txt\n * RIPEMD-160 - http://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * SHA1   - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n * SHA256 - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n * SHA512 - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n * HMAC - http://www.ietf.org/rfc/rfc2104.txt\n */\n(function () {\n  var Hashes;\n\n  function utf8Encode(str) {\n    var x,\n        y,\n        output = '',\n        i = -1,\n        l;\n\n    if (str && str.length) {\n      l = str.length;\n\n      while ((i += 1) < l) {\n        /* Decode utf-16 surrogate pairs */\n        x = str.charCodeAt(i);\n        y = i + 1 < l ? str.charCodeAt(i + 1) : 0;\n\n        if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {\n          x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n          i += 1;\n        }\n        /* Encode output as utf-8 */\n\n\n        if (x <= 0x7F) {\n          output += String.fromCharCode(x);\n        } else if (x <= 0x7FF) {\n          output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);\n        } else if (x <= 0xFFFF) {\n          output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);\n        } else if (x <= 0x1FFFFF) {\n          output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);\n        }\n      }\n    }\n\n    return output;\n  }\n\n  function utf8Decode(str) {\n    var i,\n        ac,\n        c1,\n        c2,\n        c3,\n        arr = [],\n        l;\n    i = ac = c1 = c2 = c3 = 0;\n\n    if (str && str.length) {\n      l = str.length;\n      str += '';\n\n      while (i < l) {\n        c1 = str.charCodeAt(i);\n        ac += 1;\n\n        if (c1 < 128) {\n          arr[ac] = String.fromCharCode(c1);\n          i += 1;\n        } else if (c1 > 191 && c1 < 224) {\n          c2 = str.charCodeAt(i + 1);\n          arr[ac] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n          i += 2;\n        } else {\n          c2 = str.charCodeAt(i + 1);\n          c3 = str.charCodeAt(i + 2);\n          arr[ac] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n          i += 3;\n        }\n      }\n    }\n\n    return arr.join('');\n  }\n  /**\n   * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n   * to work around bugs in some JS interpreters.\n   */\n\n\n  function safe_add(x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n        msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return msw << 16 | lsw & 0xFFFF;\n  }\n  /**\n   * Bitwise rotate a 32-bit number to the left.\n   */\n\n\n  function bit_rol(num, cnt) {\n    return num << cnt | num >>> 32 - cnt;\n  }\n  /**\n   * Convert a raw string to a hex string\n   */\n\n\n  function rstr2hex(input, hexcase) {\n    var hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef',\n        output = '',\n        x,\n        i = 0,\n        l = input.length;\n\n    for (; i < l; i += 1) {\n      x = input.charCodeAt(i);\n      output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);\n    }\n\n    return output;\n  }\n  /**\n   * Encode a string as utf-16\n   */\n\n\n  function str2rstr_utf16le(input) {\n    var i,\n        l = input.length,\n        output = '';\n\n    for (i = 0; i < l; i += 1) {\n      output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);\n    }\n\n    return output;\n  }\n\n  function str2rstr_utf16be(input) {\n    var i,\n        l = input.length,\n        output = '';\n\n    for (i = 0; i < l; i += 1) {\n      output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);\n    }\n\n    return output;\n  }\n  /**\n   * Convert an array of big-endian words to a string\n   */\n\n\n  function binb2rstr(input) {\n    var i,\n        l = input.length * 32,\n        output = '';\n\n    for (i = 0; i < l; i += 8) {\n      output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);\n    }\n\n    return output;\n  }\n  /**\n   * Convert an array of little-endian words to a string\n   */\n\n\n  function binl2rstr(input) {\n    var i,\n        l = input.length * 32,\n        output = '';\n\n    for (i = 0; i < l; i += 8) {\n      output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xFF);\n    }\n\n    return output;\n  }\n  /**\n   * Convert a raw string to an array of little-endian words\n   * Characters >255 have their high-byte silently ignored.\n   */\n\n\n  function rstr2binl(input) {\n    var i,\n        l = input.length * 8,\n        output = Array(input.length >> 2),\n        lo = output.length;\n\n    for (i = 0; i < lo; i += 1) {\n      output[i] = 0;\n    }\n\n    for (i = 0; i < l; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << i % 32;\n    }\n\n    return output;\n  }\n  /**\n   * Convert a raw string to an array of big-endian words\n   * Characters >255 have their high-byte silently ignored.\n   */\n\n\n  function rstr2binb(input) {\n    var i,\n        l = input.length * 8,\n        output = Array(input.length >> 2),\n        lo = output.length;\n\n    for (i = 0; i < lo; i += 1) {\n      output[i] = 0;\n    }\n\n    for (i = 0; i < l; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;\n    }\n\n    return output;\n  }\n  /**\n   * Convert a raw string to an arbitrary string encoding\n   */\n\n\n  function rstr2any(input, encoding) {\n    var divisor = encoding.length,\n        remainders = Array(),\n        i,\n        q,\n        x,\n        ld,\n        quotient,\n        dividend,\n        output,\n        full_length;\n    /* Convert to an array of 16-bit big-endian values, forming the dividend */\n\n    dividend = Array(Math.ceil(input.length / 2));\n    ld = dividend.length;\n\n    for (i = 0; i < ld; i += 1) {\n      dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);\n    }\n    /**\n     * Repeatedly perform a long division. The binary array forms the dividend,\n     * the length of the encoding is the divisor. Once computed, the quotient\n     * forms the dividend for the next step. We stop when the dividend is zerHashes.\n     * All remainders are stored for later use.\n     */\n\n\n    while (dividend.length > 0) {\n      quotient = Array();\n      x = 0;\n\n      for (i = 0; i < dividend.length; i += 1) {\n        x = (x << 16) + dividend[i];\n        q = Math.floor(x / divisor);\n        x -= q * divisor;\n\n        if (quotient.length > 0 || q > 0) {\n          quotient[quotient.length] = q;\n        }\n      }\n\n      remainders[remainders.length] = x;\n      dividend = quotient;\n    }\n    /* Convert the remainders to the output string */\n\n\n    output = '';\n\n    for (i = remainders.length - 1; i >= 0; i--) {\n      output += encoding.charAt(remainders[i]);\n    }\n    /* Append leading zero equivalents */\n\n\n    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));\n\n    for (i = output.length; i < full_length; i += 1) {\n      output = encoding[0] + output;\n    }\n\n    return output;\n  }\n  /**\n   * Convert a raw string to a base-64 string\n   */\n\n\n  function rstr2b64(input, b64pad) {\n    var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n        output = '',\n        len = input.length,\n        i,\n        j,\n        triplet;\n    b64pad = b64pad || '=';\n\n    for (i = 0; i < len; i += 3) {\n      triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);\n\n      for (j = 0; j < 4; j += 1) {\n        if (i * 8 + j * 6 > input.length * 8) {\n          output += b64pad;\n        } else {\n          output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);\n        }\n      }\n    }\n\n    return output;\n  }\n\n  Hashes = {\n    /**\n     * @property {String} version\n     * @readonly\n     */\n    VERSION: '1.0.6',\n\n    /**\n     * @member Hashes\n     * @class Base64\n     * @constructor\n     */\n    Base64: function Base64() {\n      // private properties\n      var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n          pad = '=',\n          // default pad according with the RFC standard\n      url = false,\n          // URL encoding support @todo\n      utf8 = true; // by default enable UTF-8 support encoding\n      // public method for encoding\n\n      this.encode = function (input) {\n        var i,\n            j,\n            triplet,\n            output = '',\n            len = input.length;\n        pad = pad || '=';\n        input = utf8 ? utf8Encode(input) : input;\n\n        for (i = 0; i < len; i += 3) {\n          triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);\n\n          for (j = 0; j < 4; j += 1) {\n            if (i * 8 + j * 6 > len * 8) {\n              output += pad;\n            } else {\n              output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);\n            }\n          }\n        }\n\n        return output;\n      }; // public method for decoding\n\n\n      this.decode = function (input) {\n        // var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        var i,\n            o1,\n            o2,\n            o3,\n            h1,\n            h2,\n            h3,\n            h4,\n            bits,\n            ac,\n            dec = '',\n            arr = [];\n\n        if (!input) {\n          return input;\n        }\n\n        i = ac = 0;\n        input = input.replace(new RegExp('\\\\' + pad, 'gi'), ''); // use '='\n        //input += '';\n\n        do {\n          // unpack four hexets into three octets using index points in b64\n          h1 = tab.indexOf(input.charAt(i += 1));\n          h2 = tab.indexOf(input.charAt(i += 1));\n          h3 = tab.indexOf(input.charAt(i += 1));\n          h4 = tab.indexOf(input.charAt(i += 1));\n          bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n          o1 = bits >> 16 & 0xff;\n          o2 = bits >> 8 & 0xff;\n          o3 = bits & 0xff;\n          ac += 1;\n\n          if (h3 === 64) {\n            arr[ac] = String.fromCharCode(o1);\n          } else if (h4 === 64) {\n            arr[ac] = String.fromCharCode(o1, o2);\n          } else {\n            arr[ac] = String.fromCharCode(o1, o2, o3);\n          }\n        } while (i < input.length);\n\n        dec = arr.join('');\n        dec = utf8 ? utf8Decode(dec) : dec;\n        return dec;\n      }; // set custom pad string\n\n\n      this.setPad = function (str) {\n        pad = str || pad;\n        return this;\n      }; // set custom tab string characters\n\n\n      this.setTab = function (str) {\n        tab = str || tab;\n        return this;\n      };\n\n      this.setUTF8 = function (bool) {\n        if (typeof bool === 'boolean') {\n          utf8 = bool;\n        }\n\n        return this;\n      };\n    },\n\n    /**\n     * CRC-32 calculation\n     * @member Hashes\n     * @method CRC32\n     * @static\n     * @param {String} str Input String\n     * @return {String}\n     */\n    CRC32: function CRC32(str) {\n      var crc = 0,\n          x = 0,\n          y = 0,\n          table,\n          i,\n          iTop;\n      str = utf8Encode(str);\n      table = ['00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 ', '79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 ', '84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F ', '63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD ', 'A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC ', '51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 ', 'B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 ', '06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 ', 'E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 ', '12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 ', 'D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 ', '33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 ', 'CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 ', '9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E ', '7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D ', '806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 ', '60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA ', 'AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 ', '5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 ', 'B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 ', '05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 ', 'F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA ', '11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 ', 'D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F ', '30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E ', 'C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D'].join('');\n      crc = crc ^ -1;\n\n      for (i = 0, iTop = str.length; i < iTop; i += 1) {\n        y = (crc ^ str.charCodeAt(i)) & 0xFF;\n        x = '0x' + table.substr(y * 9, 8);\n        crc = crc >>> 8 ^ x;\n      } // always return a positive number (that's what >>> 0 does)\n\n\n      return (crc ^ -1) >>> 0;\n    },\n\n    /**\n     * @member Hashes\n     * @class MD5\n     * @constructor\n     * @param {Object} [config]\n     *\n     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n     * Digest Algorithm, as defined in RFC 1321.\n     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * See <http://pajhome.org.uk/crypt/md5> for more infHashes.\n     */\n    MD5: function MD5(options) {\n      /**\n       * Private config properties. You may need to tweak these to be compatible with\n       * the server-side, but the defaults work in most cases.\n       * See {@link Hashes.MD5#method-setUpperCase} and {@link Hashes.SHA1#method-setUpperCase}\n       */\n      var hexcase = options && typeof options.uppercase === 'boolean' ? options.uppercase : false,\n          // hexadecimal output case format. false - lowercase; true - uppercase\n      b64pad = options && typeof options.pad === 'string' ? options.pad : '=',\n          // base-64 pad character. Defaults to '=' for strict RFC compliance\n      utf8 = options && typeof options.utf8 === 'boolean' ? options.utf8 : true; // enable/disable utf8 encoding\n      // privileged (public) methods\n\n      this.hex = function (s) {\n        return rstr2hex(rstr(s, utf8), hexcase);\n      };\n\n      this.b64 = function (s) {\n        return rstr2b64(rstr(s), b64pad);\n      };\n\n      this.any = function (s, e) {\n        return rstr2any(rstr(s, utf8), e);\n      };\n\n      this.raw = function (s) {\n        return rstr(s, utf8);\n      };\n\n      this.hex_hmac = function (k, d) {\n        return rstr2hex(rstr_hmac(k, d), hexcase);\n      };\n\n      this.b64_hmac = function (k, d) {\n        return rstr2b64(rstr_hmac(k, d), b64pad);\n      };\n\n      this.any_hmac = function (k, d, e) {\n        return rstr2any(rstr_hmac(k, d), e);\n      };\n      /**\n       * Perform a simple self-test to see if the VM is working\n       * @return {String} Hexadecimal hash sample\n       */\n\n\n      this.vm_test = function () {\n        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';\n      };\n      /**\n       * Enable/disable uppercase hexadecimal returned string\n       * @param {Boolean}\n       * @return {Object} this\n       */\n\n\n      this.setUpperCase = function (a) {\n        if (typeof a === 'boolean') {\n          hexcase = a;\n        }\n\n        return this;\n      };\n      /**\n       * Defines a base64 pad string\n       * @param {String} Pad\n       * @return {Object} this\n       */\n\n\n      this.setPad = function (a) {\n        b64pad = a || b64pad;\n        return this;\n      };\n      /**\n       * Defines a base64 pad string\n       * @param {Boolean}\n       * @return {Object} [this]\n       */\n\n\n      this.setUTF8 = function (a) {\n        if (typeof a === 'boolean') {\n          utf8 = a;\n        }\n\n        return this;\n      }; // private methods\n\n      /**\n       * Calculate the MD5 of a raw string\n       */\n\n\n      function rstr(s) {\n        s = utf8 ? utf8Encode(s) : s;\n        return binl2rstr(binl(rstr2binl(s), s.length * 8));\n      }\n      /**\n       * Calculate the HMAC-MD5, of a key and some data (raw strings)\n       */\n\n\n      function rstr_hmac(key, data) {\n        var bkey, ipad, opad, hash, i;\n        key = utf8 ? utf8Encode(key) : key;\n        data = utf8 ? utf8Encode(data) : data;\n        bkey = rstr2binl(key);\n\n        if (bkey.length > 16) {\n          bkey = binl(bkey, key.length * 8);\n        }\n\n        ipad = Array(16), opad = Array(16);\n\n        for (i = 0; i < 16; i += 1) {\n          ipad[i] = bkey[i] ^ 0x36363636;\n          opad[i] = bkey[i] ^ 0x5C5C5C5C;\n        }\n\n        hash = binl(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\n        return binl2rstr(binl(opad.concat(hash), 512 + 128));\n      }\n      /**\n       * Calculate the MD5 of an array of little-endian words, and a bit length.\n       */\n\n\n      function binl(x, len) {\n        var i,\n            olda,\n            oldb,\n            oldc,\n            oldd,\n            a = 1732584193,\n            b = -271733879,\n            c = -1732584194,\n            d = 271733878;\n        /* append padding */\n\n        x[len >> 5] |= 0x80 << len % 32;\n        x[(len + 64 >>> 9 << 4) + 14] = len;\n\n        for (i = 0; i < x.length; i += 16) {\n          olda = a;\n          oldb = b;\n          oldc = c;\n          oldd = d;\n          a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\n          d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n          c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n          b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n          a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n          d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n          c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n          b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n          a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n          d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n          c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n          b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n          a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n          d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n          c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n          b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n          a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n          d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n          c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n          b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\n          a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n          d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n          c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n          b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n          a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n          d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n          c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n          b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n          a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n          d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n          c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n          b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n          a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n          d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n          c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n          b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n          a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n          d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n          c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n          b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n          a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n          d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\n          c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n          b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n          a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n          d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n          c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n          b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n          a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\n          d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n          c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n          b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n          a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n          d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n          c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n          b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n          a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n          d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n          c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n          b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n          a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n          d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n          c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n          b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n          a = safe_add(a, olda);\n          b = safe_add(b, oldb);\n          c = safe_add(c, oldc);\n          d = safe_add(d, oldd);\n        }\n\n        return Array(a, b, c, d);\n      }\n      /**\n       * These functions implement the four basic operations the algorithm uses.\n       */\n\n\n      function md5_cmn(q, a, b, x, s, t) {\n        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n      }\n\n      function md5_ff(a, b, c, d, x, s, t) {\n        return md5_cmn(b & c | ~b & d, a, b, x, s, t);\n      }\n\n      function md5_gg(a, b, c, d, x, s, t) {\n        return md5_cmn(b & d | c & ~d, a, b, x, s, t);\n      }\n\n      function md5_hh(a, b, c, d, x, s, t) {\n        return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n      }\n\n      function md5_ii(a, b, c, d, x, s, t) {\n        return md5_cmn(c ^ (b | ~d), a, b, x, s, t);\n      }\n    },\n\n    /**\n     * @member Hashes\n     * @class Hashes.SHA1\n     * @param {Object} [config]\n     * @constructor\n     *\n     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined in FIPS 180-1\n     * Version 2.2 Copyright Paul Johnston 2000 - 2009.\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * See http://pajhome.org.uk/crypt/md5 for details.\n     */\n    SHA1: function SHA1(options) {\n      /**\n       * Private config properties. You may need to tweak these to be compatible with\n       * the server-side, but the defaults work in most cases.\n       * See {@link Hashes.MD5#method-setUpperCase} and {@link Hashes.SHA1#method-setUpperCase}\n       */\n      var hexcase = options && typeof options.uppercase === 'boolean' ? options.uppercase : false,\n          // hexadecimal output case format. false - lowercase; true - uppercase\n      b64pad = options && typeof options.pad === 'string' ? options.pad : '=',\n          // base-64 pad character. Defaults to '=' for strict RFC compliance\n      utf8 = options && typeof options.utf8 === 'boolean' ? options.utf8 : true; // enable/disable utf8 encoding\n      // public methods\n\n      this.hex = function (s) {\n        return rstr2hex(rstr(s, utf8), hexcase);\n      };\n\n      this.b64 = function (s) {\n        return rstr2b64(rstr(s, utf8), b64pad);\n      };\n\n      this.any = function (s, e) {\n        return rstr2any(rstr(s, utf8), e);\n      };\n\n      this.raw = function (s) {\n        return rstr(s, utf8);\n      };\n\n      this.hex_hmac = function (k, d) {\n        return rstr2hex(rstr_hmac(k, d));\n      };\n\n      this.b64_hmac = function (k, d) {\n        return rstr2b64(rstr_hmac(k, d), b64pad);\n      };\n\n      this.any_hmac = function (k, d, e) {\n        return rstr2any(rstr_hmac(k, d), e);\n      };\n      /**\n       * Perform a simple self-test to see if the VM is working\n       * @return {String} Hexadecimal hash sample\n       * @public\n       */\n\n\n      this.vm_test = function () {\n        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';\n      };\n      /**\n       * @description Enable/disable uppercase hexadecimal returned string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUpperCase = function (a) {\n        if (typeof a === 'boolean') {\n          hexcase = a;\n        }\n\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {string} Pad\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setPad = function (a) {\n        b64pad = a || b64pad;\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUTF8 = function (a) {\n        if (typeof a === 'boolean') {\n          utf8 = a;\n        }\n\n        return this;\n      }; // private methods\n\n      /**\n       * Calculate the SHA-512 of a raw string\n       */\n\n\n      function rstr(s) {\n        s = utf8 ? utf8Encode(s) : s;\n        return binb2rstr(binb(rstr2binb(s), s.length * 8));\n      }\n      /**\n       * Calculate the HMAC-SHA1 of a key and some data (raw strings)\n       */\n\n\n      function rstr_hmac(key, data) {\n        var bkey, ipad, opad, i, hash;\n        key = utf8 ? utf8Encode(key) : key;\n        data = utf8 ? utf8Encode(data) : data;\n        bkey = rstr2binb(key);\n\n        if (bkey.length > 16) {\n          bkey = binb(bkey, key.length * 8);\n        }\n\n        ipad = Array(16), opad = Array(16);\n\n        for (i = 0; i < 16; i += 1) {\n          ipad[i] = bkey[i] ^ 0x36363636;\n          opad[i] = bkey[i] ^ 0x5C5C5C5C;\n        }\n\n        hash = binb(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\n        return binb2rstr(binb(opad.concat(hash), 512 + 160));\n      }\n      /**\n       * Calculate the SHA-1 of an array of big-endian words, and a bit length\n       */\n\n\n      function binb(x, len) {\n        var i,\n            j,\n            t,\n            olda,\n            oldb,\n            oldc,\n            oldd,\n            olde,\n            w = Array(80),\n            a = 1732584193,\n            b = -271733879,\n            c = -1732584194,\n            d = 271733878,\n            e = -1009589776;\n        /* append padding */\n\n        x[len >> 5] |= 0x80 << 24 - len % 32;\n        x[(len + 64 >> 9 << 4) + 15] = len;\n\n        for (i = 0; i < x.length; i += 16) {\n          olda = a;\n          oldb = b;\n          oldc = c;\n          oldd = d;\n          olde = e;\n\n          for (j = 0; j < 80; j += 1) {\n            if (j < 16) {\n              w[j] = x[i + j];\n            } else {\n              w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n\n            t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\n            e = d;\n            d = c;\n            c = bit_rol(b, 30);\n            b = a;\n            a = t;\n          }\n\n          a = safe_add(a, olda);\n          b = safe_add(b, oldb);\n          c = safe_add(c, oldc);\n          d = safe_add(d, oldd);\n          e = safe_add(e, olde);\n        }\n\n        return Array(a, b, c, d, e);\n      }\n      /**\n       * Perform the appropriate triplet combination function for the current\n       * iteration\n       */\n\n\n      function sha1_ft(t, b, c, d) {\n        if (t < 20) {\n          return b & c | ~b & d;\n        }\n\n        if (t < 40) {\n          return b ^ c ^ d;\n        }\n\n        if (t < 60) {\n          return b & c | b & d | c & d;\n        }\n\n        return b ^ c ^ d;\n      }\n      /**\n       * Determine the appropriate additive constant for the current iteration\n       */\n\n\n      function sha1_kt(t) {\n        return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;\n      }\n    },\n\n    /**\n     * @class Hashes.SHA256\n     * @param {config}\n     *\n     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined in FIPS 180-2\n     * Version 2.2 Copyright Angel Marin, Paul Johnston 2000 - 2009.\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * See http://pajhome.org.uk/crypt/md5 for details.\n     * Also http://anmar.eu.org/projects/jssha2/\n     */\n    SHA256: function SHA256(options) {\n      /**\n       * Private properties configuration variables. You may need to tweak these to be compatible with\n       * the server-side, but the defaults work in most cases.\n       * @see this.setUpperCase() method\n       * @see this.setPad() method\n       */\n      var hexcase = options && typeof options.uppercase === 'boolean' ? options.uppercase : false,\n          // hexadecimal output case format. false - lowercase; true - uppercase  */\n      b64pad = options && typeof options.pad === 'string' ? options.pad : '=',\n\n      /* base-64 pad character. Default '=' for strict RFC compliance   */\n      utf8 = options && typeof options.utf8 === 'boolean' ? options.utf8 : true,\n\n      /* enable/disable utf8 encoding */\n      sha256_K;\n      /* privileged (public) methods */\n\n      this.hex = function (s) {\n        return rstr2hex(rstr(s, utf8));\n      };\n\n      this.b64 = function (s) {\n        return rstr2b64(rstr(s, utf8), b64pad);\n      };\n\n      this.any = function (s, e) {\n        return rstr2any(rstr(s, utf8), e);\n      };\n\n      this.raw = function (s) {\n        return rstr(s, utf8);\n      };\n\n      this.hex_hmac = function (k, d) {\n        return rstr2hex(rstr_hmac(k, d));\n      };\n\n      this.b64_hmac = function (k, d) {\n        return rstr2b64(rstr_hmac(k, d), b64pad);\n      };\n\n      this.any_hmac = function (k, d, e) {\n        return rstr2any(rstr_hmac(k, d), e);\n      };\n      /**\n       * Perform a simple self-test to see if the VM is working\n       * @return {String} Hexadecimal hash sample\n       * @public\n       */\n\n\n      this.vm_test = function () {\n        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';\n      };\n      /**\n       * Enable/disable uppercase hexadecimal returned string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUpperCase = function (a) {\n        if (typeof a === 'boolean') {\n          hexcase = a;\n        }\n\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {string} Pad\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setPad = function (a) {\n        b64pad = a || b64pad;\n        return this;\n      };\n      /**\n       * Defines a base64 pad string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUTF8 = function (a) {\n        if (typeof a === 'boolean') {\n          utf8 = a;\n        }\n\n        return this;\n      }; // private methods\n\n      /**\n       * Calculate the SHA-512 of a raw string\n       */\n\n\n      function rstr(s, utf8) {\n        s = utf8 ? utf8Encode(s) : s;\n        return binb2rstr(binb(rstr2binb(s), s.length * 8));\n      }\n      /**\n       * Calculate the HMAC-sha256 of a key and some data (raw strings)\n       */\n\n\n      function rstr_hmac(key, data) {\n        key = utf8 ? utf8Encode(key) : key;\n        data = utf8 ? utf8Encode(data) : data;\n        var hash,\n            i = 0,\n            bkey = rstr2binb(key),\n            ipad = Array(16),\n            opad = Array(16);\n\n        if (bkey.length > 16) {\n          bkey = binb(bkey, key.length * 8);\n        }\n\n        for (; i < 16; i += 1) {\n          ipad[i] = bkey[i] ^ 0x36363636;\n          opad[i] = bkey[i] ^ 0x5C5C5C5C;\n        }\n\n        hash = binb(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\n        return binb2rstr(binb(opad.concat(hash), 512 + 256));\n      }\n      /*\n       * Main sha256 function, with its support functions\n       */\n\n\n      function sha256_S(X, n) {\n        return X >>> n | X << 32 - n;\n      }\n\n      function sha256_R(X, n) {\n        return X >>> n;\n      }\n\n      function sha256_Ch(x, y, z) {\n        return x & y ^ ~x & z;\n      }\n\n      function sha256_Maj(x, y, z) {\n        return x & y ^ x & z ^ y & z;\n      }\n\n      function sha256_Sigma0256(x) {\n        return sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22);\n      }\n\n      function sha256_Sigma1256(x) {\n        return sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25);\n      }\n\n      function sha256_Gamma0256(x) {\n        return sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3);\n      }\n\n      function sha256_Gamma1256(x) {\n        return sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10);\n      }\n\n      function sha256_Sigma0512(x) {\n        return sha256_S(x, 28) ^ sha256_S(x, 34) ^ sha256_S(x, 39);\n      }\n\n      function sha256_Sigma1512(x) {\n        return sha256_S(x, 14) ^ sha256_S(x, 18) ^ sha256_S(x, 41);\n      }\n\n      function sha256_Gamma0512(x) {\n        return sha256_S(x, 1) ^ sha256_S(x, 8) ^ sha256_R(x, 7);\n      }\n\n      function sha256_Gamma1512(x) {\n        return sha256_S(x, 19) ^ sha256_S(x, 61) ^ sha256_R(x, 6);\n      }\n\n      sha256_K = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998];\n\n      function binb(m, l) {\n        var HASH = [1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225];\n        var W = new Array(64);\n        var a, b, c, d, e, f, g, h;\n        var i, j, T1, T2;\n        /* append padding */\n\n        m[l >> 5] |= 0x80 << 24 - l % 32;\n        m[(l + 64 >> 9 << 4) + 15] = l;\n\n        for (i = 0; i < m.length; i += 16) {\n          a = HASH[0];\n          b = HASH[1];\n          c = HASH[2];\n          d = HASH[3];\n          e = HASH[4];\n          f = HASH[5];\n          g = HASH[6];\n          h = HASH[7];\n\n          for (j = 0; j < 64; j += 1) {\n            if (j < 16) {\n              W[j] = m[j + i];\n            } else {\n              W[j] = safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]), sha256_Gamma0256(W[j - 15])), W[j - 16]);\n            }\n\n            T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)), sha256_K[j]), W[j]);\n            T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));\n            h = g;\n            g = f;\n            f = e;\n            e = safe_add(d, T1);\n            d = c;\n            c = b;\n            b = a;\n            a = safe_add(T1, T2);\n          }\n\n          HASH[0] = safe_add(a, HASH[0]);\n          HASH[1] = safe_add(b, HASH[1]);\n          HASH[2] = safe_add(c, HASH[2]);\n          HASH[3] = safe_add(d, HASH[3]);\n          HASH[4] = safe_add(e, HASH[4]);\n          HASH[5] = safe_add(f, HASH[5]);\n          HASH[6] = safe_add(g, HASH[6]);\n          HASH[7] = safe_add(h, HASH[7]);\n        }\n\n        return HASH;\n      }\n    },\n\n    /**\n     * @class Hashes.SHA512\n     * @param {config}\n     *\n     * A JavaScript implementation of the Secure Hash Algorithm, SHA-512, as defined in FIPS 180-2\n     * Version 2.2 Copyright Anonymous Contributor, Paul Johnston 2000 - 2009.\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * See http://pajhome.org.uk/crypt/md5 for details.\n     */\n    SHA512: function SHA512(options) {\n      /**\n       * Private properties configuration variables. You may need to tweak these to be compatible with\n       * the server-side, but the defaults work in most cases.\n       * @see this.setUpperCase() method\n       * @see this.setPad() method\n       */\n      var hexcase = options && typeof options.uppercase === 'boolean' ? options.uppercase : false,\n\n      /* hexadecimal output case format. false - lowercase; true - uppercase  */\n      b64pad = options && typeof options.pad === 'string' ? options.pad : '=',\n\n      /* base-64 pad character. Default '=' for strict RFC compliance   */\n      utf8 = options && typeof options.utf8 === 'boolean' ? options.utf8 : true,\n\n      /* enable/disable utf8 encoding */\n      sha512_k;\n      /* privileged (public) methods */\n\n      this.hex = function (s) {\n        return rstr2hex(rstr(s));\n      };\n\n      this.b64 = function (s) {\n        return rstr2b64(rstr(s), b64pad);\n      };\n\n      this.any = function (s, e) {\n        return rstr2any(rstr(s), e);\n      };\n\n      this.raw = function (s) {\n        return rstr(s, utf8);\n      };\n\n      this.hex_hmac = function (k, d) {\n        return rstr2hex(rstr_hmac(k, d));\n      };\n\n      this.b64_hmac = function (k, d) {\n        return rstr2b64(rstr_hmac(k, d), b64pad);\n      };\n\n      this.any_hmac = function (k, d, e) {\n        return rstr2any(rstr_hmac(k, d), e);\n      };\n      /**\n       * Perform a simple self-test to see if the VM is working\n       * @return {String} Hexadecimal hash sample\n       * @public\n       */\n\n\n      this.vm_test = function () {\n        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';\n      };\n      /**\n       * @description Enable/disable uppercase hexadecimal returned string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUpperCase = function (a) {\n        if (typeof a === 'boolean') {\n          hexcase = a;\n        }\n\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {string} Pad\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setPad = function (a) {\n        b64pad = a || b64pad;\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUTF8 = function (a) {\n        if (typeof a === 'boolean') {\n          utf8 = a;\n        }\n\n        return this;\n      };\n      /* private methods */\n\n      /**\n       * Calculate the SHA-512 of a raw string\n       */\n\n\n      function rstr(s) {\n        s = utf8 ? utf8Encode(s) : s;\n        return binb2rstr(binb(rstr2binb(s), s.length * 8));\n      }\n      /*\n       * Calculate the HMAC-SHA-512 of a key and some data (raw strings)\n       */\n\n\n      function rstr_hmac(key, data) {\n        key = utf8 ? utf8Encode(key) : key;\n        data = utf8 ? utf8Encode(data) : data;\n        var hash,\n            i = 0,\n            bkey = rstr2binb(key),\n            ipad = Array(32),\n            opad = Array(32);\n\n        if (bkey.length > 32) {\n          bkey = binb(bkey, key.length * 8);\n        }\n\n        for (; i < 32; i += 1) {\n          ipad[i] = bkey[i] ^ 0x36363636;\n          opad[i] = bkey[i] ^ 0x5C5C5C5C;\n        }\n\n        hash = binb(ipad.concat(rstr2binb(data)), 1024 + data.length * 8);\n        return binb2rstr(binb(opad.concat(hash), 1024 + 512));\n      }\n      /**\n       * Calculate the SHA-512 of an array of big-endian dwords, and a bit length\n       */\n\n\n      function binb(x, len) {\n        var j,\n            i,\n            l,\n            W = new Array(80),\n            hash = new Array(16),\n            //Initial hash values\n        H = [new int64(0x6a09e667, -205731576), new int64(-1150833019, -2067093701), new int64(0x3c6ef372, -23791573), new int64(-1521486534, 0x5f1d36f1), new int64(0x510e527f, -1377402159), new int64(-1694144372, 0x2b3e6c1f), new int64(0x1f83d9ab, -79577749), new int64(0x5be0cd19, 0x137e2179)],\n            T1 = new int64(0, 0),\n            T2 = new int64(0, 0),\n            a = new int64(0, 0),\n            b = new int64(0, 0),\n            c = new int64(0, 0),\n            d = new int64(0, 0),\n            e = new int64(0, 0),\n            f = new int64(0, 0),\n            g = new int64(0, 0),\n            h = new int64(0, 0),\n            //Temporary variables not specified by the document\n        s0 = new int64(0, 0),\n            s1 = new int64(0, 0),\n            Ch = new int64(0, 0),\n            Maj = new int64(0, 0),\n            r1 = new int64(0, 0),\n            r2 = new int64(0, 0),\n            r3 = new int64(0, 0);\n\n        if (sha512_k === undefined) {\n          //SHA512 constants\n          sha512_k = [new int64(0x428a2f98, -685199838), new int64(0x71374491, 0x23ef65cd), new int64(-1245643825, -330482897), new int64(-373957723, -2121671748), new int64(0x3956c25b, -213338824), new int64(0x59f111f1, -1241133031), new int64(-1841331548, -1357295717), new int64(-1424204075, -630357736), new int64(-670586216, -1560083902), new int64(0x12835b01, 0x45706fbe), new int64(0x243185be, 0x4ee4b28c), new int64(0x550c7dc3, -704662302), new int64(0x72be5d74, -226784913), new int64(-2132889090, 0x3b1696b1), new int64(-1680079193, 0x25c71235), new int64(-1046744716, -815192428), new int64(-459576895, -1628353838), new int64(-272742522, 0x384f25e3), new int64(0xfc19dc6, -1953704523), new int64(0x240ca1cc, 0x77ac9c65), new int64(0x2de92c6f, 0x592b0275), new int64(0x4a7484aa, 0x6ea6e483), new int64(0x5cb0a9dc, -1119749164), new int64(0x76f988da, -2096016459), new int64(-1740746414, -295247957), new int64(-1473132947, 0x2db43210), new int64(-1341970488, -1728372417), new int64(-1084653625, -1091629340), new int64(-958395405, 0x3da88fc2), new int64(-710438585, -1828018395), new int64(0x6ca6351, -536640913), new int64(0x14292967, 0xa0e6e70), new int64(0x27b70a85, 0x46d22ffc), new int64(0x2e1b2138, 0x5c26c926), new int64(0x4d2c6dfc, 0x5ac42aed), new int64(0x53380d13, -1651133473), new int64(0x650a7354, -1951439906), new int64(0x766a0abb, 0x3c77b2a8), new int64(-2117940946, 0x47edaee6), new int64(-1838011259, 0x1482353b), new int64(-1564481375, 0x4cf10364), new int64(-1474664885, -1136513023), new int64(-1035236496, -789014639), new int64(-949202525, 0x654be30), new int64(-778901479, -688958952), new int64(-694614492, 0x5565a910), new int64(-200395387, 0x5771202a), new int64(0x106aa070, 0x32bbd1b8), new int64(0x19a4c116, -1194143544), new int64(0x1e376c08, 0x5141ab53), new int64(0x2748774c, -544281703), new int64(0x34b0bcb5, -509917016), new int64(0x391c0cb3, -976659869), new int64(0x4ed8aa4a, -482243893), new int64(0x5b9cca4f, 0x7763e373), new int64(0x682e6ff3, -692930397), new int64(0x748f82ee, 0x5defb2fc), new int64(0x78a5636f, 0x43172f60), new int64(-2067236844, -1578062990), new int64(-1933114872, 0x1a6439ec), new int64(-1866530822, 0x23631e28), new int64(-1538233109, -561857047), new int64(-1090935817, -1295615723), new int64(-965641998, -479046869), new int64(-903397682, -366583396), new int64(-779700025, 0x21c0c207), new int64(-354779690, -840897762), new int64(-176337025, -294727304), new int64(0x6f067aa, 0x72176fba), new int64(0xa637dc5, -1563912026), new int64(0x113f9804, -1090974290), new int64(0x1b710b35, 0x131c471b), new int64(0x28db77f5, 0x23047d84), new int64(0x32caab7b, 0x40c72493), new int64(0x3c9ebe0a, 0x15c9bebc), new int64(0x431d67c4, -1676669620), new int64(0x4cc5d4be, -885112138), new int64(0x597f299c, -60457430), new int64(0x5fcb6fab, 0x3ad6faec), new int64(0x6c44198c, 0x4a475817)];\n        }\n\n        for (i = 0; i < 80; i += 1) {\n          W[i] = new int64(0, 0);\n        } // append padding to the source string. The format is described in the FIPS.\n\n\n        x[len >> 5] |= 0x80 << 24 - (len & 0x1f);\n        x[(len + 128 >> 10 << 5) + 31] = len;\n        l = x.length;\n\n        for (i = 0; i < l; i += 32) {\n          //32 dwords is the block size\n          int64copy(a, H[0]);\n          int64copy(b, H[1]);\n          int64copy(c, H[2]);\n          int64copy(d, H[3]);\n          int64copy(e, H[4]);\n          int64copy(f, H[5]);\n          int64copy(g, H[6]);\n          int64copy(h, H[7]);\n\n          for (j = 0; j < 16; j += 1) {\n            W[j].h = x[i + 2 * j];\n            W[j].l = x[i + 2 * j + 1];\n          }\n\n          for (j = 16; j < 80; j += 1) {\n            //sigma1\n            int64rrot(r1, W[j - 2], 19);\n            int64revrrot(r2, W[j - 2], 29);\n            int64shr(r3, W[j - 2], 6);\n            s1.l = r1.l ^ r2.l ^ r3.l;\n            s1.h = r1.h ^ r2.h ^ r3.h; //sigma0\n\n            int64rrot(r1, W[j - 15], 1);\n            int64rrot(r2, W[j - 15], 8);\n            int64shr(r3, W[j - 15], 7);\n            s0.l = r1.l ^ r2.l ^ r3.l;\n            s0.h = r1.h ^ r2.h ^ r3.h;\n            int64add4(W[j], s1, W[j - 7], s0, W[j - 16]);\n          }\n\n          for (j = 0; j < 80; j += 1) {\n            //Ch\n            Ch.l = e.l & f.l ^ ~e.l & g.l;\n            Ch.h = e.h & f.h ^ ~e.h & g.h; //Sigma1\n\n            int64rrot(r1, e, 14);\n            int64rrot(r2, e, 18);\n            int64revrrot(r3, e, 9);\n            s1.l = r1.l ^ r2.l ^ r3.l;\n            s1.h = r1.h ^ r2.h ^ r3.h; //Sigma0\n\n            int64rrot(r1, a, 28);\n            int64revrrot(r2, a, 2);\n            int64revrrot(r3, a, 7);\n            s0.l = r1.l ^ r2.l ^ r3.l;\n            s0.h = r1.h ^ r2.h ^ r3.h; //Maj\n\n            Maj.l = a.l & b.l ^ a.l & c.l ^ b.l & c.l;\n            Maj.h = a.h & b.h ^ a.h & c.h ^ b.h & c.h;\n            int64add5(T1, h, s1, Ch, sha512_k[j], W[j]);\n            int64add(T2, s0, Maj);\n            int64copy(h, g);\n            int64copy(g, f);\n            int64copy(f, e);\n            int64add(e, d, T1);\n            int64copy(d, c);\n            int64copy(c, b);\n            int64copy(b, a);\n            int64add(a, T1, T2);\n          }\n\n          int64add(H[0], H[0], a);\n          int64add(H[1], H[1], b);\n          int64add(H[2], H[2], c);\n          int64add(H[3], H[3], d);\n          int64add(H[4], H[4], e);\n          int64add(H[5], H[5], f);\n          int64add(H[6], H[6], g);\n          int64add(H[7], H[7], h);\n        } //represent the hash as an array of 32-bit dwords\n\n\n        for (i = 0; i < 8; i += 1) {\n          hash[2 * i] = H[i].h;\n          hash[2 * i + 1] = H[i].l;\n        }\n\n        return hash;\n      } //A constructor for 64-bit numbers\n\n\n      function int64(h, l) {\n        this.h = h;\n        this.l = l; //this.toString = int64toString;\n      } //Copies src into dst, assuming both are 64-bit numbers\n\n\n      function int64copy(dst, src) {\n        dst.h = src.h;\n        dst.l = src.l;\n      } //Right-rotates a 64-bit number by shift\n      //Won't handle cases of shift>=32\n      //The function revrrot() is for that\n\n\n      function int64rrot(dst, x, shift) {\n        dst.l = x.l >>> shift | x.h << 32 - shift;\n        dst.h = x.h >>> shift | x.l << 32 - shift;\n      } //Reverses the dwords of the source and then rotates right by shift.\n      //This is equivalent to rotation by 32+shift\n\n\n      function int64revrrot(dst, x, shift) {\n        dst.l = x.h >>> shift | x.l << 32 - shift;\n        dst.h = x.l >>> shift | x.h << 32 - shift;\n      } //Bitwise-shifts right a 64-bit number by shift\n      //Won't handle shift>=32, but it's never needed in SHA512\n\n\n      function int64shr(dst, x, shift) {\n        dst.l = x.l >>> shift | x.h << 32 - shift;\n        dst.h = x.h >>> shift;\n      } //Adds two 64-bit numbers\n      //Like the original implementation, does not rely on 32-bit operations\n\n\n      function int64add(dst, x, y) {\n        var w0 = (x.l & 0xffff) + (y.l & 0xffff);\n        var w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16);\n        var w2 = (x.h & 0xffff) + (y.h & 0xffff) + (w1 >>> 16);\n        var w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);\n        dst.l = w0 & 0xffff | w1 << 16;\n        dst.h = w2 & 0xffff | w3 << 16;\n      } //Same, except with 4 addends. Works faster than adding them one by one.\n\n\n      function int64add4(dst, a, b, c, d) {\n        var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff);\n        var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16);\n        var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (w1 >>> 16);\n        var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);\n        dst.l = w0 & 0xffff | w1 << 16;\n        dst.h = w2 & 0xffff | w3 << 16;\n      } //Same, except with 5 addends\n\n\n      function int64add5(dst, a, b, c, d, e) {\n        var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff) + (e.l & 0xffff),\n            w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16),\n            w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (e.h & 0xffff) + (w1 >>> 16),\n            w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);\n        dst.l = w0 & 0xffff | w1 << 16;\n        dst.h = w2 & 0xffff | w3 << 16;\n      }\n    },\n\n    /**\n     * @class Hashes.RMD160\n     * @constructor\n     * @param {Object} [config]\n     *\n     * A JavaScript implementation of the RIPEMD-160 Algorithm\n     * Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * See http://pajhome.org.uk/crypt/md5 for details.\n     * Also http://www.ocf.berkeley.edu/~jjlin/jsotp/\n     */\n    RMD160: function RMD160(options) {\n      /**\n       * Private properties configuration variables. You may need to tweak these to be compatible with\n       * the server-side, but the defaults work in most cases.\n       * @see this.setUpperCase() method\n       * @see this.setPad() method\n       */\n      var hexcase = options && typeof options.uppercase === 'boolean' ? options.uppercase : false,\n\n      /* hexadecimal output case format. false - lowercase; true - uppercase  */\n      b64pad = options && typeof options.pad === 'string' ? options.pa : '=',\n\n      /* base-64 pad character. Default '=' for strict RFC compliance   */\n      utf8 = options && typeof options.utf8 === 'boolean' ? options.utf8 : true,\n\n      /* enable/disable utf8 encoding */\n      rmd160_r1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],\n          rmd160_r2 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],\n          rmd160_s1 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],\n          rmd160_s2 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];\n      /* privileged (public) methods */\n\n      this.hex = function (s) {\n        return rstr2hex(rstr(s, utf8));\n      };\n\n      this.b64 = function (s) {\n        return rstr2b64(rstr(s, utf8), b64pad);\n      };\n\n      this.any = function (s, e) {\n        return rstr2any(rstr(s, utf8), e);\n      };\n\n      this.raw = function (s) {\n        return rstr(s, utf8);\n      };\n\n      this.hex_hmac = function (k, d) {\n        return rstr2hex(rstr_hmac(k, d));\n      };\n\n      this.b64_hmac = function (k, d) {\n        return rstr2b64(rstr_hmac(k, d), b64pad);\n      };\n\n      this.any_hmac = function (k, d, e) {\n        return rstr2any(rstr_hmac(k, d), e);\n      };\n      /**\n       * Perform a simple self-test to see if the VM is working\n       * @return {String} Hexadecimal hash sample\n       * @public\n       */\n\n\n      this.vm_test = function () {\n        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';\n      };\n      /**\n       * @description Enable/disable uppercase hexadecimal returned string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUpperCase = function (a) {\n        if (typeof a === 'boolean') {\n          hexcase = a;\n        }\n\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {string} Pad\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setPad = function (a) {\n        if (typeof a !== 'undefined') {\n          b64pad = a;\n        }\n\n        return this;\n      };\n      /**\n       * @description Defines a base64 pad string\n       * @param {boolean}\n       * @return {Object} this\n       * @public\n       */\n\n\n      this.setUTF8 = function (a) {\n        if (typeof a === 'boolean') {\n          utf8 = a;\n        }\n\n        return this;\n      };\n      /* private methods */\n\n      /**\n       * Calculate the rmd160 of a raw string\n       */\n\n\n      function rstr(s) {\n        s = utf8 ? utf8Encode(s) : s;\n        return binl2rstr(binl(rstr2binl(s), s.length * 8));\n      }\n      /**\n       * Calculate the HMAC-rmd160 of a key and some data (raw strings)\n       */\n\n\n      function rstr_hmac(key, data) {\n        key = utf8 ? utf8Encode(key) : key;\n        data = utf8 ? utf8Encode(data) : data;\n        var i,\n            hash,\n            bkey = rstr2binl(key),\n            ipad = Array(16),\n            opad = Array(16);\n\n        if (bkey.length > 16) {\n          bkey = binl(bkey, key.length * 8);\n        }\n\n        for (i = 0; i < 16; i += 1) {\n          ipad[i] = bkey[i] ^ 0x36363636;\n          opad[i] = bkey[i] ^ 0x5C5C5C5C;\n        }\n\n        hash = binl(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\n        return binl2rstr(binl(opad.concat(hash), 512 + 160));\n      }\n      /**\n       * Convert an array of little-endian words to a string\n       */\n\n\n      function binl2rstr(input) {\n        var i,\n            output = '',\n            l = input.length * 32;\n\n        for (i = 0; i < l; i += 8) {\n          output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xFF);\n        }\n\n        return output;\n      }\n      /**\n       * Calculate the RIPE-MD160 of an array of little-endian words, and a bit length.\n       */\n\n\n      function binl(x, len) {\n        var T,\n            j,\n            i,\n            l,\n            h0 = 0x67452301,\n            h1 = 0xefcdab89,\n            h2 = 0x98badcfe,\n            h3 = 0x10325476,\n            h4 = 0xc3d2e1f0,\n            A1,\n            B1,\n            C1,\n            D1,\n            E1,\n            A2,\n            B2,\n            C2,\n            D2,\n            E2;\n        /* append padding */\n\n        x[len >> 5] |= 0x80 << len % 32;\n        x[(len + 64 >>> 9 << 4) + 14] = len;\n        l = x.length;\n\n        for (i = 0; i < l; i += 16) {\n          A1 = A2 = h0;\n          B1 = B2 = h1;\n          C1 = C2 = h2;\n          D1 = D2 = h3;\n          E1 = E2 = h4;\n\n          for (j = 0; j <= 79; j += 1) {\n            T = safe_add(A1, rmd160_f(j, B1, C1, D1));\n            T = safe_add(T, x[i + rmd160_r1[j]]);\n            T = safe_add(T, rmd160_K1(j));\n            T = safe_add(bit_rol(T, rmd160_s1[j]), E1);\n            A1 = E1;\n            E1 = D1;\n            D1 = bit_rol(C1, 10);\n            C1 = B1;\n            B1 = T;\n            T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));\n            T = safe_add(T, x[i + rmd160_r2[j]]);\n            T = safe_add(T, rmd160_K2(j));\n            T = safe_add(bit_rol(T, rmd160_s2[j]), E2);\n            A2 = E2;\n            E2 = D2;\n            D2 = bit_rol(C2, 10);\n            C2 = B2;\n            B2 = T;\n          }\n\n          T = safe_add(h1, safe_add(C1, D2));\n          h1 = safe_add(h2, safe_add(D1, E2));\n          h2 = safe_add(h3, safe_add(E1, A2));\n          h3 = safe_add(h4, safe_add(A1, B2));\n          h4 = safe_add(h0, safe_add(B1, C2));\n          h0 = T;\n        }\n\n        return [h0, h1, h2, h3, h4];\n      } // specific algorithm methods\n\n\n      function rmd160_f(j, x, y, z) {\n        return 0 <= j && j <= 15 ? x ^ y ^ z : 16 <= j && j <= 31 ? x & y | ~x & z : 32 <= j && j <= 47 ? (x | ~y) ^ z : 48 <= j && j <= 63 ? x & z | y & ~z : 64 <= j && j <= 79 ? x ^ (y | ~z) : 'rmd160_f: j out of range';\n      }\n\n      function rmd160_K1(j) {\n        return 0 <= j && j <= 15 ? 0x00000000 : 16 <= j && j <= 31 ? 0x5a827999 : 32 <= j && j <= 47 ? 0x6ed9eba1 : 48 <= j && j <= 63 ? 0x8f1bbcdc : 64 <= j && j <= 79 ? 0xa953fd4e : 'rmd160_K1: j out of range';\n      }\n\n      function rmd160_K2(j) {\n        return 0 <= j && j <= 15 ? 0x50a28be6 : 16 <= j && j <= 31 ? 0x5c4dd124 : 32 <= j && j <= 47 ? 0x6d703ef3 : 48 <= j && j <= 63 ? 0x7a6d76e9 : 64 <= j && j <= 79 ? 0x00000000 : 'rmd160_K2: j out of range';\n      }\n    }\n  }; // exposes Hashes\n\n  (function (window, undefined) {\n    var freeExports = false;\n\n    if (( false ? 0 : _typeof(exports)) === 'object') {\n      freeExports = exports;\n\n      if (exports && (typeof __webpack_require__.g === \"undefined\" ? \"undefined\" : _typeof(__webpack_require__.g)) === 'object' && __webpack_require__.g && __webpack_require__.g === __webpack_require__.g.global) {\n        window = __webpack_require__.g;\n      }\n    }\n\n    if ( true && _typeof(__webpack_require__.amdO) === 'object' && __webpack_require__.amdO) {\n      // define as an anonymous module, so, through path mapping, it can be aliased\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return Hashes;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (freeExports) {\n      // in Node.js or RingoJS v0.8.0+\n      if (( false ? 0 : _typeof(module)) === 'object' && module && module.exports === freeExports) {\n        module.exports = Hashes;\n      } // in Narwhal or RingoJS v0.7.0-\n      else {\n          freeExports.Hashes = Hashes;\n        }\n    } else {\n      // in a browser or Rhino\n      window.Hashes = Hashes;\n    }\n  })(this);\n})(); // IIFE\n\n//# sourceURL=webpack://keystore_wdc_contract/./hashes.js?");

/***/ }),

/***/ "./nacl.min.js":
/*!*********************!*\
  !*** ./nacl.min.js ***!
  \*********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/*! CommonJS bailout: module.exports is used directly at 1049:34-48 */
/*! CommonJS bailout: module.exports is used directly at 1049:51-65 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("!function (r) {\n  \"use strict\";\n\n  function n(r, n) {\n    return r << n | r >>> 32 - n;\n  }\n\n  function e(r, n) {\n    var e = 255 & r[n + 3];\n    return e = e << 8 | 255 & r[n + 2], e = e << 8 | 255 & r[n + 1], e << 8 | 255 & r[n + 0];\n  }\n\n  function t(r, n) {\n    var e = r[n] << 24 | r[n + 1] << 16 | r[n + 2] << 8 | r[n + 3],\n        t = r[n + 4] << 24 | r[n + 5] << 16 | r[n + 6] << 8 | r[n + 7];\n    return new sr(e, t);\n  }\n\n  function o(r, n, e) {\n    var t;\n\n    for (t = 0; t < 4; t++) {\n      r[n + t] = 255 & e, e >>>= 8;\n    }\n  }\n\n  function i(r, n, e) {\n    r[n] = e.hi >> 24 & 255, r[n + 1] = e.hi >> 16 & 255, r[n + 2] = e.hi >> 8 & 255, r[n + 3] = 255 & e.hi, r[n + 4] = e.lo >> 24 & 255, r[n + 5] = e.lo >> 16 & 255, r[n + 6] = e.lo >> 8 & 255, r[n + 7] = 255 & e.lo;\n  }\n\n  function f(r, n, e, t, o) {\n    var i,\n        f = 0;\n\n    for (i = 0; i < o; i++) {\n      f |= r[n + i] ^ e[t + i];\n    }\n\n    return (1 & f - 1 >>> 8) - 1;\n  }\n\n  function a(r, n, e, t) {\n    return f(r, n, e, t, 16);\n  }\n\n  function u(r, n, e, t) {\n    return f(r, n, e, t, 32);\n  }\n\n  function c(r, t, i, f, a) {\n    var u,\n        c,\n        w,\n        y = new Uint32Array(16),\n        l = new Uint32Array(16),\n        s = new Uint32Array(16),\n        h = new Uint32Array(4);\n\n    for (u = 0; u < 4; u++) {\n      l[5 * u] = e(f, 4 * u), l[1 + u] = e(i, 4 * u), l[6 + u] = e(t, 4 * u), l[11 + u] = e(i, 16 + 4 * u);\n    }\n\n    for (u = 0; u < 16; u++) {\n      s[u] = l[u];\n    }\n\n    for (u = 0; u < 20; u++) {\n      for (c = 0; c < 4; c++) {\n        for (w = 0; w < 4; w++) {\n          h[w] = l[(5 * c + 4 * w) % 16];\n        }\n\n        for (h[1] ^= n(h[0] + h[3] | 0, 7), h[2] ^= n(h[1] + h[0] | 0, 9), h[3] ^= n(h[2] + h[1] | 0, 13), h[0] ^= n(h[3] + h[2] | 0, 18), w = 0; w < 4; w++) {\n          y[4 * c + (c + w) % 4] = h[w];\n        }\n      }\n\n      for (w = 0; w < 16; w++) {\n        l[w] = y[w];\n      }\n    }\n\n    if (a) {\n      for (u = 0; u < 16; u++) {\n        l[u] = l[u] + s[u] | 0;\n      }\n\n      for (u = 0; u < 4; u++) {\n        l[5 * u] = l[5 * u] - e(f, 4 * u) | 0, l[6 + u] = l[6 + u] - e(t, 4 * u) | 0;\n      }\n\n      for (u = 0; u < 4; u++) {\n        o(r, 4 * u, l[5 * u]), o(r, 16 + 4 * u, l[6 + u]);\n      }\n    } else for (u = 0; u < 16; u++) {\n      o(r, 4 * u, l[u] + s[u] | 0);\n    }\n  }\n\n  function w(r, n, e, t) {\n    return c(r, n, e, t, !1), 0;\n  }\n\n  function y(r, n, e, t) {\n    return c(r, n, e, t, !0), 0;\n  }\n\n  function l(r, n, e, t, o, i, f) {\n    var a,\n        u,\n        c = new Uint8Array(16),\n        y = new Uint8Array(64);\n    if (!o) return 0;\n\n    for (u = 0; u < 16; u++) {\n      c[u] = 0;\n    }\n\n    for (u = 0; u < 8; u++) {\n      c[u] = i[u];\n    }\n\n    for (; o >= 64;) {\n      for (w(y, c, f, Br), u = 0; u < 64; u++) {\n        r[n + u] = (e ? e[t + u] : 0) ^ y[u];\n      }\n\n      for (a = 1, u = 8; u < 16; u++) {\n        a = a + (255 & c[u]) | 0, c[u] = 255 & a, a >>>= 8;\n      }\n\n      o -= 64, n += 64, e && (t += 64);\n    }\n\n    if (o > 0) for (w(y, c, f, Br), u = 0; u < o; u++) {\n      r[n + u] = (e ? e[t + u] : 0) ^ y[u];\n    }\n    return 0;\n  }\n\n  function s(r, n, e, t, o) {\n    return l(r, n, null, 0, e, t, o);\n  }\n\n  function h(r, n, e, t, o) {\n    var i = new Uint8Array(32);\n    return y(i, t, o, Br), s(r, n, e, t.subarray(16), i);\n  }\n\n  function v(r, n, e, t, o, i, f) {\n    var a = new Uint8Array(32);\n    return y(a, i, f, Br), l(r, n, e, t, o, i.subarray(16), a);\n  }\n\n  function g(r, n) {\n    var e,\n        t = 0;\n\n    for (e = 0; e < 17; e++) {\n      t = t + (r[e] + n[e] | 0) | 0, r[e] = 255 & t, t >>>= 8;\n    }\n  }\n\n  function b(r, n, e, t, o, i) {\n    var f,\n        a,\n        u,\n        c,\n        w = new Uint32Array(17),\n        y = new Uint32Array(17),\n        l = new Uint32Array(17),\n        s = new Uint32Array(17),\n        h = new Uint32Array(17);\n\n    for (u = 0; u < 17; u++) {\n      y[u] = l[u] = 0;\n    }\n\n    for (u = 0; u < 16; u++) {\n      y[u] = i[u];\n    }\n\n    for (y[3] &= 15, y[4] &= 252, y[7] &= 15, y[8] &= 252, y[11] &= 15, y[12] &= 252, y[15] &= 15; o > 0;) {\n      for (u = 0; u < 17; u++) {\n        s[u] = 0;\n      }\n\n      for (u = 0; u < 16 && u < o; ++u) {\n        s[u] = e[t + u];\n      }\n\n      for (s[u] = 1, t += u, o -= u, g(l, s), a = 0; a < 17; a++) {\n        for (w[a] = 0, u = 0; u < 17; u++) {\n          w[a] = w[a] + l[u] * (u <= a ? y[a - u] : 320 * y[a + 17 - u] | 0) | 0 | 0;\n        }\n      }\n\n      for (a = 0; a < 17; a++) {\n        l[a] = w[a];\n      }\n\n      for (c = 0, u = 0; u < 16; u++) {\n        c = c + l[u] | 0, l[u] = 255 & c, c >>>= 8;\n      }\n\n      for (c = c + l[16] | 0, l[16] = 3 & c, c = 5 * (c >>> 2) | 0, u = 0; u < 16; u++) {\n        c = c + l[u] | 0, l[u] = 255 & c, c >>>= 8;\n      }\n\n      c = c + l[16] | 0, l[16] = c;\n    }\n\n    for (u = 0; u < 17; u++) {\n      h[u] = l[u];\n    }\n\n    for (g(l, Sr), f = 0 | -(l[16] >>> 7), u = 0; u < 17; u++) {\n      l[u] ^= f & (h[u] ^ l[u]);\n    }\n\n    for (u = 0; u < 16; u++) {\n      s[u] = i[u + 16];\n    }\n\n    for (s[16] = 0, g(l, s), u = 0; u < 16; u++) {\n      r[n + u] = l[u];\n    }\n\n    return 0;\n  }\n\n  function p(r, n, e, t, o, i) {\n    var f = new Uint8Array(16);\n    return b(f, 0, e, t, o, i), a(r, n, f, 0);\n  }\n\n  function _(r, n, e, t, o) {\n    var i;\n    if (e < 32) return -1;\n\n    for (v(r, 0, n, 0, e, t, o), b(r, 16, r, 32, e - 32, r), i = 0; i < 16; i++) {\n      r[i] = 0;\n    }\n\n    return 0;\n  }\n\n  function A(r, n, e, t, o) {\n    var i,\n        f = new Uint8Array(32);\n    if (e < 32) return -1;\n    if (h(f, 0, 32, t, o), 0 !== p(n, 16, n, 32, e - 32, f)) return -1;\n\n    for (v(r, 0, n, 0, e, t, o), i = 0; i < 32; i++) {\n      r[i] = 0;\n    }\n\n    return 0;\n  }\n\n  function U(r, n) {\n    var e;\n\n    for (e = 0; e < 16; e++) {\n      r[e] = 0 | n[e];\n    }\n  }\n\n  function E(r) {\n    var n, e;\n\n    for (e = 0; e < 16; e++) {\n      r[e] += 65536, n = Math.floor(r[e] / 65536), r[(e + 1) * (e < 15 ? 1 : 0)] += n - 1 + 37 * (n - 1) * (15 === e ? 1 : 0), r[e] -= 65536 * n;\n    }\n  }\n\n  function x(r, n, e) {\n    for (var t, o = ~(e - 1), i = 0; i < 16; i++) {\n      t = o & (r[i] ^ n[i]), r[i] ^= t, n[i] ^= t;\n    }\n  }\n\n  function d(r, n) {\n    var e,\n        t,\n        o,\n        i = hr(),\n        f = hr();\n\n    for (e = 0; e < 16; e++) {\n      f[e] = n[e];\n    }\n\n    for (E(f), E(f), E(f), t = 0; t < 2; t++) {\n      for (i[0] = f[0] - 65517, e = 1; e < 15; e++) {\n        i[e] = f[e] - 65535 - (i[e - 1] >> 16 & 1), i[e - 1] &= 65535;\n      }\n\n      i[15] = f[15] - 32767 - (i[14] >> 16 & 1), o = i[15] >> 16 & 1, i[14] &= 65535, x(f, i, 1 - o);\n    }\n\n    for (e = 0; e < 16; e++) {\n      r[2 * e] = 255 & f[e], r[2 * e + 1] = f[e] >> 8;\n    }\n  }\n\n  function m(r, n) {\n    var e = new Uint8Array(32),\n        t = new Uint8Array(32);\n    return d(e, r), d(t, n), u(e, 0, t, 0);\n  }\n\n  function B(r) {\n    var n = new Uint8Array(32);\n    return d(n, r), 1 & n[0];\n  }\n\n  function S(r, n) {\n    var e;\n\n    for (e = 0; e < 16; e++) {\n      r[e] = n[2 * e] + (n[2 * e + 1] << 8);\n    }\n\n    r[15] &= 32767;\n  }\n\n  function K(r, n, e) {\n    var t;\n\n    for (t = 0; t < 16; t++) {\n      r[t] = n[t] + e[t] | 0;\n    }\n  }\n\n  function Y(r, n, e) {\n    var t;\n\n    for (t = 0; t < 16; t++) {\n      r[t] = n[t] - e[t] | 0;\n    }\n  }\n\n  function T(r, n, e) {\n    var t,\n        o,\n        i = new Float64Array(31);\n\n    for (t = 0; t < 31; t++) {\n      i[t] = 0;\n    }\n\n    for (t = 0; t < 16; t++) {\n      for (o = 0; o < 16; o++) {\n        i[t + o] += n[t] * e[o];\n      }\n    }\n\n    for (t = 0; t < 15; t++) {\n      i[t] += 38 * i[t + 16];\n    }\n\n    for (t = 0; t < 16; t++) {\n      r[t] = i[t];\n    }\n\n    E(r), E(r);\n  }\n\n  function L(r, n) {\n    T(r, n, n);\n  }\n\n  function k(r, n) {\n    var e,\n        t = hr();\n\n    for (e = 0; e < 16; e++) {\n      t[e] = n[e];\n    }\n\n    for (e = 253; e >= 0; e--) {\n      L(t, t), 2 !== e && 4 !== e && T(t, t, n);\n    }\n\n    for (e = 0; e < 16; e++) {\n      r[e] = t[e];\n    }\n  }\n\n  function z(r, n) {\n    var e,\n        t = hr();\n\n    for (e = 0; e < 16; e++) {\n      t[e] = n[e];\n    }\n\n    for (e = 250; e >= 0; e--) {\n      L(t, t), 1 !== e && T(t, t, n);\n    }\n\n    for (e = 0; e < 16; e++) {\n      r[e] = t[e];\n    }\n  }\n\n  function R(r, n, e) {\n    var t,\n        o,\n        i = new Uint8Array(32),\n        f = new Float64Array(80),\n        a = hr(),\n        u = hr(),\n        c = hr(),\n        w = hr(),\n        y = hr(),\n        l = hr();\n\n    for (o = 0; o < 31; o++) {\n      i[o] = n[o];\n    }\n\n    for (i[31] = 127 & n[31] | 64, i[0] &= 248, S(f, e), o = 0; o < 16; o++) {\n      u[o] = f[o], w[o] = a[o] = c[o] = 0;\n    }\n\n    for (a[0] = w[0] = 1, o = 254; o >= 0; --o) {\n      t = i[o >>> 3] >>> (7 & o) & 1, x(a, u, t), x(c, w, t), K(y, a, c), Y(a, a, c), K(c, u, w), Y(u, u, w), L(w, y), L(l, a), T(a, c, a), T(c, u, y), K(y, a, c), Y(a, a, c), L(u, a), Y(c, w, l), T(a, c, Ar), K(a, a, w), T(c, c, a), T(a, w, l), T(w, u, f), L(u, y), x(a, u, t), x(c, w, t);\n    }\n\n    for (o = 0; o < 16; o++) {\n      f[o + 16] = a[o], f[o + 32] = c[o], f[o + 48] = u[o], f[o + 64] = w[o];\n    }\n\n    var s = f.subarray(32),\n        h = f.subarray(16);\n    return k(s, s), T(h, h, s), d(r, h), 0;\n  }\n\n  function P(r, n) {\n    return R(r, n, br);\n  }\n\n  function N(r, n) {\n    return vr(n, 32), P(r, n);\n  }\n\n  function O(r, n, e) {\n    var t = new Uint8Array(32);\n    return R(t, e, n), y(r, gr, t, Br);\n  }\n\n  function C(r, n, e, t, o, i) {\n    var f = new Uint8Array(32);\n    return O(f, o, i), Kr(r, n, e, t, f);\n  }\n\n  function F(r, n, e, t, o, i) {\n    var f = new Uint8Array(32);\n    return O(f, o, i), Yr(r, n, e, t, f);\n  }\n\n  function M() {\n    var r,\n        n,\n        e,\n        t = 0,\n        o = 0,\n        i = 0,\n        f = 0,\n        a = 65535;\n\n    for (e = 0; e < arguments.length; e++) {\n      r = arguments[e].lo, n = arguments[e].hi, t += r & a, o += r >>> 16, i += n & a, f += n >>> 16;\n    }\n\n    return o += t >>> 16, i += o >>> 16, f += i >>> 16, new sr(i & a | f << 16, t & a | o << 16);\n  }\n\n  function G(r, n) {\n    return new sr(r.hi >>> n, r.lo >>> n | r.hi << 32 - n);\n  }\n\n  function Z() {\n    var r,\n        n = 0,\n        e = 0;\n\n    for (r = 0; r < arguments.length; r++) {\n      n ^= arguments[r].lo, e ^= arguments[r].hi;\n    }\n\n    return new sr(e, n);\n  }\n\n  function q(r, n) {\n    var e,\n        t,\n        o = 32 - n;\n    return n < 32 ? (e = r.hi >>> n | r.lo << o, t = r.lo >>> n | r.hi << o) : n < 64 && (e = r.lo >>> n | r.hi << o, t = r.hi >>> n | r.lo << o), new sr(e, t);\n  }\n\n  function I(r, n, e) {\n    var t = r.hi & n.hi ^ ~r.hi & e.hi,\n        o = r.lo & n.lo ^ ~r.lo & e.lo;\n    return new sr(t, o);\n  }\n\n  function V(r, n, e) {\n    var t = r.hi & n.hi ^ r.hi & e.hi ^ n.hi & e.hi,\n        o = r.lo & n.lo ^ r.lo & e.lo ^ n.lo & e.lo;\n    return new sr(t, o);\n  }\n\n  function X(r) {\n    return Z(q(r, 28), q(r, 34), q(r, 39));\n  }\n\n  function D(r) {\n    return Z(q(r, 14), q(r, 18), q(r, 41));\n  }\n\n  function j(r) {\n    return Z(q(r, 1), q(r, 8), G(r, 7));\n  }\n\n  function H(r) {\n    return Z(q(r, 19), q(r, 61), G(r, 6));\n  }\n\n  function J(r, n, e) {\n    var o,\n        f,\n        a,\n        u = [],\n        c = [],\n        w = [],\n        y = [];\n\n    for (f = 0; f < 8; f++) {\n      u[f] = w[f] = t(r, 8 * f);\n    }\n\n    for (var l = 0; e >= 128;) {\n      for (f = 0; f < 16; f++) {\n        y[f] = t(n, 8 * f + l);\n      }\n\n      for (f = 0; f < 80; f++) {\n        for (a = 0; a < 8; a++) {\n          c[a] = w[a];\n        }\n\n        for (o = M(w[7], D(w[4]), I(w[4], w[5], w[6]), Tr[f], y[f % 16]), c[7] = M(o, X(w[0]), V(w[0], w[1], w[2])), c[3] = M(c[3], o), a = 0; a < 8; a++) {\n          w[(a + 1) % 8] = c[a];\n        }\n\n        if (f % 16 === 15) for (a = 0; a < 16; a++) {\n          y[a] = M(y[a], y[(a + 9) % 16], j(y[(a + 1) % 16]), H(y[(a + 14) % 16]));\n        }\n      }\n\n      for (f = 0; f < 8; f++) {\n        w[f] = M(w[f], u[f]), u[f] = w[f];\n      }\n\n      l += 128, e -= 128;\n    }\n\n    for (f = 0; f < 8; f++) {\n      i(r, 8 * f, u[f]);\n    }\n\n    return e;\n  }\n\n  function Q(r, n, e) {\n    var t,\n        o = new Uint8Array(64),\n        f = new Uint8Array(256),\n        a = e;\n\n    for (t = 0; t < 64; t++) {\n      o[t] = Lr[t];\n    }\n\n    for (J(o, n, e), e %= 128, t = 0; t < 256; t++) {\n      f[t] = 0;\n    }\n\n    for (t = 0; t < e; t++) {\n      f[t] = n[a - e + t];\n    }\n\n    for (f[e] = 128, e = 256 - 128 * (e < 112 ? 1 : 0), f[e - 9] = 0, i(f, e - 8, new sr(a / 536870912 | 0, a << 3)), J(o, f, e), t = 0; t < 64; t++) {\n      r[t] = o[t];\n    }\n\n    return 0;\n  }\n\n  function W(r, n) {\n    var e = hr(),\n        t = hr(),\n        o = hr(),\n        i = hr(),\n        f = hr(),\n        a = hr(),\n        u = hr(),\n        c = hr(),\n        w = hr();\n    Y(e, r[1], r[0]), Y(w, n[1], n[0]), T(e, e, w), K(t, r[0], r[1]), K(w, n[0], n[1]), T(t, t, w), T(o, r[3], n[3]), T(o, o, Er), T(i, r[2], n[2]), K(i, i, i), Y(f, t, e), Y(a, i, o), K(u, i, o), K(c, t, e), T(r[0], f, a), T(r[1], c, u), T(r[2], u, a), T(r[3], f, c);\n  }\n\n  function $(r, n, e) {\n    var t;\n\n    for (t = 0; t < 4; t++) {\n      x(r[t], n[t], e);\n    }\n  }\n\n  function rr(r, n) {\n    var e = hr(),\n        t = hr(),\n        o = hr();\n    k(o, n[2]), T(e, n[0], o), T(t, n[1], o), d(r, t), r[31] ^= B(e) << 7;\n  }\n\n  function nr(r, n, e) {\n    var t, o;\n\n    for (U(r[0], pr), U(r[1], _r), U(r[2], _r), U(r[3], pr), o = 255; o >= 0; --o) {\n      t = e[o / 8 | 0] >> (7 & o) & 1, $(r, n, t), W(n, r), W(r, r), $(r, n, t);\n    }\n  }\n\n  function er(r, n) {\n    var e = [hr(), hr(), hr(), hr()];\n    U(e[0], xr), U(e[1], dr), U(e[2], _r), T(e[3], xr, dr), nr(r, e, n);\n  }\n\n  function tr(r, n, e) {\n    var t,\n        o = new Uint8Array(64),\n        i = [hr(), hr(), hr(), hr()];\n\n    for (e || vr(n, 32), Q(o, n, 32), o[0] &= 248, o[31] &= 127, o[31] |= 64, er(i, o), rr(r, i), t = 0; t < 32; t++) {\n      n[t + 32] = r[t];\n    }\n\n    return 0;\n  }\n\n  function or(r, n) {\n    var e, t, o, i;\n\n    for (t = 63; t >= 32; --t) {\n      for (e = 0, o = t - 32, i = t - 12; o < i; ++o) {\n        n[o] += e - 16 * n[t] * kr[o - (t - 32)], e = n[o] + 128 >> 8, n[o] -= 256 * e;\n      }\n\n      n[o] += e, n[t] = 0;\n    }\n\n    for (e = 0, o = 0; o < 32; o++) {\n      n[o] += e - (n[31] >> 4) * kr[o], e = n[o] >> 8, n[o] &= 255;\n    }\n\n    for (o = 0; o < 32; o++) {\n      n[o] -= e * kr[o];\n    }\n\n    for (t = 0; t < 32; t++) {\n      n[t + 1] += n[t] >> 8, r[t] = 255 & n[t];\n    }\n  }\n\n  function ir(r) {\n    var n,\n        e = new Float64Array(64);\n\n    for (n = 0; n < 64; n++) {\n      e[n] = r[n];\n    }\n\n    for (n = 0; n < 64; n++) {\n      r[n] = 0;\n    }\n\n    or(r, e);\n  }\n\n  function fr(r, n, e, t) {\n    var o,\n        i,\n        f = new Uint8Array(64),\n        a = new Uint8Array(64),\n        u = new Uint8Array(64),\n        c = new Float64Array(64),\n        w = [hr(), hr(), hr(), hr()];\n    Q(f, t, 32), f[0] &= 248, f[31] &= 127, f[31] |= 64;\n    var y = e + 64;\n\n    for (o = 0; o < e; o++) {\n      r[64 + o] = n[o];\n    }\n\n    for (o = 0; o < 32; o++) {\n      r[32 + o] = f[32 + o];\n    }\n\n    for (Q(u, r.subarray(32), e + 32), ir(u), er(w, u), rr(r, w), o = 32; o < 64; o++) {\n      r[o] = t[o];\n    }\n\n    for (Q(a, r, e + 64), ir(a), o = 0; o < 64; o++) {\n      c[o] = 0;\n    }\n\n    for (o = 0; o < 32; o++) {\n      c[o] = u[o];\n    }\n\n    for (o = 0; o < 32; o++) {\n      for (i = 0; i < 32; i++) {\n        c[o + i] += a[o] * f[i];\n      }\n    }\n\n    return or(r.subarray(32), c), y;\n  }\n\n  function ar(r, n) {\n    var e = hr(),\n        t = hr(),\n        o = hr(),\n        i = hr(),\n        f = hr(),\n        a = hr(),\n        u = hr();\n    return U(r[2], _r), S(r[1], n), L(o, r[1]), T(i, o, Ur), Y(o, o, r[2]), K(i, r[2], i), L(f, i), L(a, f), T(u, a, f), T(e, u, o), T(e, e, i), z(e, e), T(e, e, o), T(e, e, i), T(e, e, i), T(r[0], e, i), L(t, r[0]), T(t, t, i), m(t, o) && T(r[0], r[0], mr), L(t, r[0]), T(t, t, i), m(t, o) ? -1 : (B(r[0]) === n[31] >> 7 && Y(r[0], pr, r[0]), T(r[3], r[0], r[1]), 0);\n  }\n\n  function ur(r, n, e, t) {\n    var o,\n        i,\n        f = new Uint8Array(32),\n        a = new Uint8Array(64),\n        c = [hr(), hr(), hr(), hr()],\n        w = [hr(), hr(), hr(), hr()];\n    if (i = -1, e < 64) return -1;\n    if (ar(w, t)) return -1;\n\n    for (o = 0; o < e; o++) {\n      r[o] = n[o];\n    }\n\n    for (o = 0; o < 32; o++) {\n      r[o + 32] = t[o];\n    }\n\n    if (Q(a, r, e), ir(a), nr(c, w, a), er(w, n.subarray(32)), W(c, w), rr(f, c), e -= 64, u(n, 0, f, 0)) {\n      for (o = 0; o < e; o++) {\n        r[o] = 0;\n      }\n\n      return -1;\n    }\n\n    for (o = 0; o < e; o++) {\n      r[o] = n[o + 64];\n    }\n\n    return i = e;\n  }\n\n  function cr(r, n) {\n    if (r.length !== zr) throw new Error(\"bad key size\");\n    if (n.length !== Rr) throw new Error(\"bad nonce size\");\n  }\n\n  function wr(r, n) {\n    if (r.length !== Fr) throw new Error(\"bad public key size\");\n    if (n.length !== Mr) throw new Error(\"bad secret key size\");\n  }\n\n  function yr() {\n    for (var r = 0; r < arguments.length; r++) {\n      if (!(arguments[r] instanceof Uint8Array)) throw new TypeError(\"unexpected type, use Uint8Array\");\n    }\n  }\n\n  function lr(r) {\n    for (var n = 0; n < r.length; n++) {\n      r[n] = 0;\n    }\n  }\n\n  var sr = function sr(r, n) {\n    this.hi = 0 | r, this.lo = 0 | n;\n  },\n      hr = function hr(r) {\n    var n,\n        e = new Float64Array(16);\n    if (r) for (n = 0; n < r.length; n++) {\n      e[n] = r[n];\n    }\n    return e;\n  },\n      vr = function vr() {\n    throw new Error(\"no PRNG\");\n  },\n      gr = new Uint8Array(16),\n      br = new Uint8Array(32);\n\n  br[0] = 9;\n\n  var pr = hr(),\n      _r = hr([1]),\n      Ar = hr([56129, 1]),\n      Ur = hr([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),\n      Er = hr([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),\n      xr = hr([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),\n      dr = hr([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),\n      mr = hr([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]),\n      Br = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]),\n      Sr = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]),\n      Kr = _,\n      Yr = A,\n      Tr = [new sr(1116352408, 3609767458), new sr(1899447441, 602891725), new sr(3049323471, 3964484399), new sr(3921009573, 2173295548), new sr(961987163, 4081628472), new sr(1508970993, 3053834265), new sr(2453635748, 2937671579), new sr(2870763221, 3664609560), new sr(3624381080, 2734883394), new sr(310598401, 1164996542), new sr(607225278, 1323610764), new sr(1426881987, 3590304994), new sr(1925078388, 4068182383), new sr(2162078206, 991336113), new sr(2614888103, 633803317), new sr(3248222580, 3479774868), new sr(3835390401, 2666613458), new sr(4022224774, 944711139), new sr(264347078, 2341262773), new sr(604807628, 2007800933), new sr(770255983, 1495990901), new sr(1249150122, 1856431235), new sr(1555081692, 3175218132), new sr(1996064986, 2198950837), new sr(2554220882, 3999719339), new sr(2821834349, 766784016), new sr(2952996808, 2566594879), new sr(3210313671, 3203337956), new sr(3336571891, 1034457026), new sr(3584528711, 2466948901), new sr(113926993, 3758326383), new sr(338241895, 168717936), new sr(666307205, 1188179964), new sr(773529912, 1546045734), new sr(1294757372, 1522805485), new sr(1396182291, 2643833823), new sr(1695183700, 2343527390), new sr(1986661051, 1014477480), new sr(2177026350, 1206759142), new sr(2456956037, 344077627), new sr(2730485921, 1290863460), new sr(2820302411, 3158454273), new sr(3259730800, 3505952657), new sr(3345764771, 106217008), new sr(3516065817, 3606008344), new sr(3600352804, 1432725776), new sr(4094571909, 1467031594), new sr(275423344, 851169720), new sr(430227734, 3100823752), new sr(506948616, 1363258195), new sr(659060556, 3750685593), new sr(883997877, 3785050280), new sr(958139571, 3318307427), new sr(1322822218, 3812723403), new sr(1537002063, 2003034995), new sr(1747873779, 3602036899), new sr(1955562222, 1575990012), new sr(2024104815, 1125592928), new sr(2227730452, 2716904306), new sr(2361852424, 442776044), new sr(2428436474, 593698344), new sr(2756734187, 3733110249), new sr(3204031479, 2999351573), new sr(3329325298, 3815920427), new sr(3391569614, 3928383900), new sr(3515267271, 566280711), new sr(3940187606, 3454069534), new sr(4118630271, 4000239992), new sr(116418474, 1914138554), new sr(174292421, 2731055270), new sr(289380356, 3203993006), new sr(460393269, 320620315), new sr(685471733, 587496836), new sr(852142971, 1086792851), new sr(1017036298, 365543100), new sr(1126000580, 2618297676), new sr(1288033470, 3409855158), new sr(1501505948, 4234509866), new sr(1607167915, 987167468), new sr(1816402316, 1246189591)],\n      Lr = new Uint8Array([106, 9, 230, 103, 243, 188, 201, 8, 187, 103, 174, 133, 132, 202, 167, 59, 60, 110, 243, 114, 254, 148, 248, 43, 165, 79, 245, 58, 95, 29, 54, 241, 81, 14, 82, 127, 173, 230, 130, 209, 155, 5, 104, 140, 43, 62, 108, 31, 31, 131, 217, 171, 251, 65, 189, 107, 91, 224, 205, 25, 19, 126, 33, 121]),\n      kr = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]),\n      zr = 32,\n      Rr = 24,\n      Pr = 32,\n      Nr = 16,\n      Or = 32,\n      Cr = 32,\n      Fr = 32,\n      Mr = 32,\n      Gr = 32,\n      Zr = Rr,\n      qr = Pr,\n      Ir = Nr,\n      Vr = 64,\n      Xr = 32,\n      Dr = 64,\n      jr = 32,\n      Hr = 64;\n\n  r.lowlevel = {\n    crypto_core_hsalsa20: y,\n    crypto_stream_xor: v,\n    crypto_stream: h,\n    crypto_stream_salsa20_xor: l,\n    crypto_stream_salsa20: s,\n    crypto_onetimeauth: b,\n    crypto_onetimeauth_verify: p,\n    crypto_verify_16: a,\n    crypto_verify_32: u,\n    crypto_secretbox: _,\n    crypto_secretbox_open: A,\n    crypto_scalarmult: R,\n    crypto_scalarmult_base: P,\n    crypto_box_beforenm: O,\n    crypto_box_afternm: Kr,\n    crypto_box: C,\n    crypto_box_open: F,\n    crypto_box_keypair: N,\n    crypto_hash: Q,\n    crypto_sign: fr,\n    crypto_sign_keypair: tr,\n    crypto_sign_open: ur,\n    crypto_secretbox_KEYBYTES: zr,\n    crypto_secretbox_NONCEBYTES: Rr,\n    crypto_secretbox_ZEROBYTES: Pr,\n    crypto_secretbox_BOXZEROBYTES: Nr,\n    crypto_scalarmult_BYTES: Or,\n    crypto_scalarmult_SCALARBYTES: Cr,\n    crypto_box_PUBLICKEYBYTES: Fr,\n    crypto_box_SECRETKEYBYTES: Mr,\n    crypto_box_BEFORENMBYTES: Gr,\n    crypto_box_NONCEBYTES: Zr,\n    crypto_box_ZEROBYTES: qr,\n    crypto_box_BOXZEROBYTES: Ir,\n    crypto_sign_BYTES: Vr,\n    crypto_sign_PUBLICKEYBYTES: Xr,\n    crypto_sign_SECRETKEYBYTES: Dr,\n    crypto_sign_SEEDBYTES: jr,\n    crypto_hash_BYTES: Hr\n  }, r.randomBytes = function (r) {\n    var n = new Uint8Array(r);\n    return vr(n, r), n;\n  }, r.secretbox = function (r, n, e) {\n    yr(r, n, e), cr(e, n);\n\n    for (var t = new Uint8Array(Pr + r.length), o = new Uint8Array(t.length), i = 0; i < r.length; i++) {\n      t[i + Pr] = r[i];\n    }\n\n    return _(o, t, t.length, n, e), o.subarray(Nr);\n  }, r.secretbox.open = function (r, n, e) {\n    yr(r, n, e), cr(e, n);\n\n    for (var t = new Uint8Array(Nr + r.length), o = new Uint8Array(t.length), i = 0; i < r.length; i++) {\n      t[i + Nr] = r[i];\n    }\n\n    return t.length < 32 ? null : 0 !== A(o, t, t.length, n, e) ? null : o.subarray(Pr);\n  }, r.secretbox.keyLength = zr, r.secretbox.nonceLength = Rr, r.secretbox.overheadLength = Nr, r.scalarMult = function (r, n) {\n    if (yr(r, n), r.length !== Cr) throw new Error(\"bad n size\");\n    if (n.length !== Or) throw new Error(\"bad p size\");\n    var e = new Uint8Array(Or);\n    return R(e, r, n), e;\n  }, r.scalarMult.base = function (r) {\n    if (yr(r), r.length !== Cr) throw new Error(\"bad n size\");\n    var n = new Uint8Array(Or);\n    return P(n, r), n;\n  }, r.scalarMult.scalarLength = Cr, r.scalarMult.groupElementLength = Or, r.box = function (n, e, t, o) {\n    var i = r.box.before(t, o);\n    return r.secretbox(n, e, i);\n  }, r.box.before = function (r, n) {\n    yr(r, n), wr(r, n);\n    var e = new Uint8Array(Gr);\n    return O(e, r, n), e;\n  }, r.box.after = r.secretbox, r.box.open = function (n, e, t, o) {\n    var i = r.box.before(t, o);\n    return r.secretbox.open(n, e, i);\n  }, r.box.open.after = r.secretbox.open, r.box.keyPair = function () {\n    var r = new Uint8Array(Fr),\n        n = new Uint8Array(Mr);\n    return N(r, n), {\n      publicKey: r,\n      secretKey: n\n    };\n  }, r.box.keyPair.fromSecretKey = function (r) {\n    if (yr(r), r.length !== Mr) throw new Error(\"bad secret key size\");\n    var n = new Uint8Array(Fr);\n    return P(n, r), {\n      publicKey: n,\n      secretKey: new Uint8Array(r)\n    };\n  }, r.box.publicKeyLength = Fr, r.box.secretKeyLength = Mr, r.box.sharedKeyLength = Gr, r.box.nonceLength = Zr, r.box.overheadLength = r.secretbox.overheadLength, r.sign = function (r, n) {\n    if (yr(r, n), n.length !== Dr) throw new Error(\"bad secret key size\");\n    var e = new Uint8Array(Vr + r.length);\n    return fr(e, r, r.length, n), e;\n  }, r.sign.open = function (r, n) {\n    if (yr(r, n), n.length !== Xr) throw new Error(\"bad public key size\");\n    var e = new Uint8Array(r.length),\n        t = ur(e, r, r.length, n);\n    if (t < 0) return null;\n\n    for (var o = new Uint8Array(t), i = 0; i < o.length; i++) {\n      o[i] = e[i];\n    }\n\n    return o;\n  }, r.sign.detached = function (n, e) {\n    for (var t = r.sign(n, e), o = new Uint8Array(Vr), i = 0; i < o.length; i++) {\n      o[i] = t[i];\n    }\n\n    return o;\n  }, r.sign.detached.verify = function (r, n, e) {\n    if (yr(r, n, e), n.length !== Vr) throw new Error(\"bad signature size\");\n    if (e.length !== Xr) throw new Error(\"bad public key size\");\n    var t,\n        o = new Uint8Array(Vr + r.length),\n        i = new Uint8Array(Vr + r.length);\n\n    for (t = 0; t < Vr; t++) {\n      o[t] = n[t];\n    }\n\n    for (t = 0; t < r.length; t++) {\n      o[t + Vr] = r[t];\n    }\n\n    return ur(i, o, o.length, e) >= 0;\n  }, r.sign.keyPair = function () {\n    var r = new Uint8Array(Xr),\n        n = new Uint8Array(Dr);\n    return tr(r, n), {\n      publicKey: r,\n      secretKey: n\n    };\n  }, r.sign.keyPair.fromSecretKey = function (r) {\n    if (yr(r), r.length !== Dr) throw new Error(\"bad secret key size\");\n\n    for (var n = new Uint8Array(Xr), e = 0; e < n.length; e++) {\n      n[e] = r[32 + e];\n    }\n\n    return {\n      publicKey: n,\n      secretKey: new Uint8Array(r)\n    };\n  }, r.sign.keyPair.fromSeed = function (r) {\n    if (yr(r), r.length !== jr) throw new Error(\"bad seed size\");\n\n    for (var n = new Uint8Array(Xr), e = new Uint8Array(Dr), t = 0; t < 32; t++) {\n      e[t] = r[t];\n    }\n\n    return tr(n, e, !0), {\n      publicKey: n,\n      secretKey: e\n    };\n  }, r.sign.publicKeyLength = Xr, r.sign.secretKeyLength = Dr, r.sign.seedLength = jr, r.sign.signatureLength = Vr, r.hash = function (r) {\n    yr(r);\n    var n = new Uint8Array(Hr);\n    return Q(n, r, r.length), n;\n  }, r.hash.hashLength = Hr, r.verify = function (r, n) {\n    return yr(r, n), 0 !== r.length && 0 !== n.length && r.length === n.length && 0 === f(r, 0, n, 0, r.length);\n  }, r.setPRNG = function (r) {\n    vr = r;\n  }, function () {\n    var n = \"undefined\" != typeof self ? self.crypto || self.msCrypto : null;\n\n    if (n && n.getRandomValues) {\n      var e = 65536;\n      r.setPRNG(function (r, t) {\n        var o,\n            i = new Uint8Array(t);\n\n        for (o = 0; o < t; o += e) {\n          n.getRandomValues(i.subarray(o, o + Math.min(t - o, e)));\n        }\n\n        for (o = 0; o < t; o++) {\n          r[o] = i[o];\n        }\n\n        lr(i);\n      });\n    } else  true && (n = __webpack_require__(/*! crypto */ \"?8465\"), n && n.randomBytes && r.setPRNG(function (r, e) {\n      var t,\n          o = n.randomBytes(e);\n\n      for (t = 0; t < e; t++) {\n        r[t] = o[t];\n      }\n\n      lr(o);\n    }));\n  }();\n}( true && module.exports ? module.exports : self.nacl = self.nacl || {});\n\n//# sourceURL=webpack://keystore_wdc_contract/./nacl.min.js?");

/***/ }),

/***/ "./sha3.js":
/*!*****************!*\
  !*** ./sha3.js ***!
  \*****************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module.loaded, module.id, module, __webpack_require__.nmd, __webpack_require__.g, __webpack_require__.amdO, __webpack_require__, __webpack_exports__, __webpack_require__.* */
/*! CommonJS bailout: module.exports is used directly at 34:128-142 */
/*! CommonJS bailout: module.exports is used directly at 745:4-18 */
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object';\n  var root = WINDOW ? window : {};\n\n  if (root.JS_SHA3_NO_WINDOW) {\n    WINDOW = false;\n  }\n\n  var WEB_WORKER = !WINDOW && (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object';\n  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && process.versions && process.versions.node;\n\n  if (NODE_JS) {\n    root = __webpack_require__.g;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n\n  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && ( false ? 0 : _typeof(module)) === 'object' && module.exports;\n  var AMD =  true && __webpack_require__.amdO;\n  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n  var PADDING = [6, 1536, 393216, 100663296];\n  var SHIFT = [0, 8, 16, 24];\n  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n  var BITS = [224, 256, 384, 512];\n  var SHAKE_BITS = [128, 256];\n  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n  var CSHAKE_BYTEPAD = {\n    '128': 168,\n    '256': 136\n  };\n\n  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return _typeof(obj) === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function createOutputMethod(bits, padding, outputType) {\n    return function (message) {\n      return new Keccak(bits, padding, bits).update(message)[outputType]();\n    };\n  };\n\n  var createShakeOutputMethod = function createShakeOutputMethod(bits, padding, outputType) {\n    return function (message, outputBits) {\n      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n    };\n  };\n\n  var createCshakeOutputMethod = function createCshakeOutputMethod(bits, padding, outputType) {\n    return function (message, outputBits, n, s) {\n      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n    };\n  };\n\n  var createKmacOutputMethod = function createKmacOutputMethod(bits, padding, outputType) {\n    return function (key, message, outputBits, s) {\n      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n    };\n  };\n\n  var createOutputMethods = function createOutputMethods(method, createMethod, bits, padding) {\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createMethod(bits, padding, type);\n    }\n\n    return method;\n  };\n\n  var createMethod = function createMethod(bits, padding) {\n    var method = createOutputMethod(bits, padding, 'hex');\n\n    method.create = function () {\n      return new Keccak(bits, padding, bits);\n    };\n\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n\n    return createOutputMethods(method, createOutputMethod, bits, padding);\n  };\n\n  var createShakeMethod = function createShakeMethod(bits, padding) {\n    var method = createShakeOutputMethod(bits, padding, 'hex');\n\n    method.create = function (outputBits) {\n      return new Keccak(bits, padding, outputBits);\n    };\n\n    method.update = function (message, outputBits) {\n      return method.create(outputBits).update(message);\n    };\n\n    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n  };\n\n  var createCshakeMethod = function createCshakeMethod(bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createCshakeOutputMethod(bits, padding, 'hex');\n\n    method.create = function (outputBits, n, s) {\n      if (!n && !s) {\n        return methods['shake' + bits].create(outputBits);\n      } else {\n        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n      }\n    };\n\n    method.update = function (message, outputBits, n, s) {\n      return method.create(outputBits, n, s).update(message);\n    };\n\n    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n  };\n\n  var createKmacMethod = function createKmacMethod(bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createKmacOutputMethod(bits, padding, 'hex');\n\n    method.create = function (key, outputBits, s) {\n      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n    };\n\n    method.update = function (key, message, outputBits, s) {\n      return method.create(key, outputBits, s).update(message);\n    };\n\n    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n  };\n\n  var algorithms = [{\n    name: 'keccak',\n    padding: KECCAK_PADDING,\n    bits: BITS,\n    createMethod: createMethod\n  }, {\n    name: 'sha3',\n    padding: PADDING,\n    bits: BITS,\n    createMethod: createMethod\n  }, {\n    name: 'shake',\n    padding: SHAKE_PADDING,\n    bits: SHAKE_BITS,\n    createMethod: createShakeMethod\n  }, {\n    name: 'cshake',\n    padding: CSHAKE_PADDING,\n    bits: SHAKE_BITS,\n    createMethod: createCshakeMethod\n  }, {\n    name: 'kmac',\n    padding: CSHAKE_PADDING,\n    bits: SHAKE_BITS,\n    createMethod: createKmacMethod\n  }];\n  var methods = {},\n      methodNames = [];\n\n  for (var i = 0; i < algorithms.length; ++i) {\n    var algorithm = algorithms[i];\n    var bits = algorithm.bits;\n\n    for (var j = 0; j < bits.length; ++j) {\n      var methodName = algorithm.name + '_' + bits[j];\n      methodNames.push(methodName);\n      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n\n      if (algorithm.name !== 'sha3') {\n        var newMethodName = algorithm.name + bits[j];\n        methodNames.push(newMethodName);\n        methods[newMethodName] = methods[methodName];\n      }\n    }\n  }\n\n  function Keccak(bits, padding, outputBits) {\n    this.blocks = [];\n    this.s = [];\n    this.padding = padding;\n    this.outputBits = outputBits;\n    this.reset = true;\n    this.finalized = false;\n    this.block = 0;\n    this.start = 0;\n    this.blockCount = 1600 - (bits << 1) >> 5;\n    this.byteCount = this.blockCount << 2;\n    this.outputBlocks = outputBits >> 5;\n    this.extraBytes = (outputBits & 31) >> 3;\n\n    for (var i = 0; i < 50; ++i) {\n      this.s[i] = 0;\n    }\n  }\n\n  Keccak.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n\n    var notString,\n        type = _typeof(message);\n\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n\n      notString = true;\n    }\n\n    var blocks = this.blocks,\n        byteCount = this.byteCount,\n        length = message.length,\n        blockCount = this.blockCount,\n        index = 0,\n        s = this.s,\n        i,\n        code;\n\n    while (index < length) {\n      if (this.reset) {\n        this.reset = false;\n        blocks[0] = this.block;\n\n        for (i = 1; i < blockCount + 1; ++i) {\n          blocks[i] = 0;\n        }\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          code = message.charCodeAt(index);\n\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);\n            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n\n      if (i >= byteCount) {\n        this.start = i - byteCount;\n        this.block = blocks[blockCount];\n\n        for (i = 0; i < blockCount; ++i) {\n          s[i] ^= blocks[i];\n        }\n\n        f(s);\n        this.reset = true;\n      } else {\n        this.start = i;\n      }\n    }\n\n    return this;\n  };\n\n  Keccak.prototype.encode = function (x, right) {\n    var o = x & 255,\n        n = 1;\n    var bytes = [o];\n    x = x >> 8;\n    o = x & 255;\n\n    while (o > 0) {\n      bytes.unshift(o);\n      x = x >> 8;\n      o = x & 255;\n      ++n;\n    }\n\n    if (right) {\n      bytes.push(n);\n    } else {\n      bytes.unshift(n);\n    }\n\n    this.update(bytes);\n    return bytes.length;\n  };\n\n  Keccak.prototype.encodeString = function (str) {\n    var notString,\n        type = _typeof(str);\n\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (str === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n          str = new Uint8Array(str);\n        } else if (!Array.isArray(str)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n\n      notString = true;\n    }\n\n    var bytes = 0,\n        length = str.length;\n\n    if (notString) {\n      bytes = length;\n    } else {\n      for (var i = 0; i < str.length; ++i) {\n        var code = str.charCodeAt(i);\n\n        if (code < 0x80) {\n          bytes += 1;\n        } else if (code < 0x800) {\n          bytes += 2;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes += 3;\n        } else {\n          code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);\n          bytes += 4;\n        }\n      }\n    }\n\n    bytes += this.encode(bytes * 8);\n    this.update(str);\n    return bytes;\n  };\n\n  Keccak.prototype.bytepad = function (strs, w) {\n    var bytes = this.encode(w);\n\n    for (var i = 0; i < strs.length; ++i) {\n      bytes += this.encodeString(strs[i]);\n    }\n\n    var paddingBytes = w - bytes % w;\n    var zeros = [];\n    zeros.length = paddingBytes;\n    this.update(zeros);\n    return this;\n  };\n\n  Keccak.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n\n    this.finalized = true;\n    var blocks = this.blocks,\n        i = this.lastByteIndex,\n        blockCount = this.blockCount,\n        s = this.s;\n    blocks[i >> 2] |= this.padding[i & 3];\n\n    if (this.lastByteIndex === this.byteCount) {\n      blocks[0] = blocks[blockCount];\n\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n\n    blocks[blockCount - 1] |= 0x80000000;\n\n    for (i = 0; i < blockCount; ++i) {\n      s[i] ^= blocks[i];\n    }\n\n    f(s);\n  };\n\n  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n    this.finalize();\n    var blockCount = this.blockCount,\n        s = this.s,\n        outputBlocks = this.outputBlocks,\n        extraBytes = this.extraBytes,\n        i = 0,\n        j = 0;\n    var hex = '',\n        block;\n\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        block = s[i];\n        hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];\n      }\n\n      if (j % blockCount === 0) {\n        f(s);\n        i = 0;\n      }\n    }\n\n    if (extraBytes) {\n      block = s[i];\n      hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];\n\n      if (extraBytes > 1) {\n        hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];\n      }\n\n      if (extraBytes > 2) {\n        hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];\n      }\n    }\n\n    return hex;\n  };\n\n  Keccak.prototype.arrayBuffer = function () {\n    this.finalize();\n    var blockCount = this.blockCount,\n        s = this.s,\n        outputBlocks = this.outputBlocks,\n        extraBytes = this.extraBytes,\n        i = 0,\n        j = 0;\n    var bytes = this.outputBits >> 3;\n    var buffer;\n\n    if (extraBytes) {\n      buffer = new ArrayBuffer(outputBlocks + 1 << 2);\n    } else {\n      buffer = new ArrayBuffer(bytes);\n    }\n\n    var array = new Uint32Array(buffer);\n\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        array[j] = s[i];\n      }\n\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n\n    if (extraBytes) {\n      array[i] = s[i];\n      buffer = buffer.slice(0, bytes);\n    }\n\n    return buffer;\n  };\n\n  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n  Keccak.prototype.digest = Keccak.prototype.array = function () {\n    this.finalize();\n    var blockCount = this.blockCount,\n        s = this.s,\n        outputBlocks = this.outputBlocks,\n        extraBytes = this.extraBytes,\n        i = 0,\n        j = 0;\n    var array = [],\n        offset,\n        block;\n\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        offset = j << 2;\n        block = s[i];\n        array[offset] = block & 0xFF;\n        array[offset + 1] = block >> 8 & 0xFF;\n        array[offset + 2] = block >> 16 & 0xFF;\n        array[offset + 3] = block >> 24 & 0xFF;\n      }\n\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n\n    if (extraBytes) {\n      offset = j << 2;\n      block = s[i];\n      array[offset] = block & 0xFF;\n\n      if (extraBytes > 1) {\n        array[offset + 1] = block >> 8 & 0xFF;\n      }\n\n      if (extraBytes > 2) {\n        array[offset + 2] = block >> 16 & 0xFF;\n      }\n    }\n\n    return array;\n  };\n\n  function Kmac(bits, padding, outputBits) {\n    Keccak.call(this, bits, padding, outputBits);\n  }\n\n  Kmac.prototype = new Keccak();\n\n  Kmac.prototype.finalize = function () {\n    this.encode(this.outputBits, true);\n    return Keccak.prototype.finalize.call(this);\n  };\n\n  var f = function f(s) {\n    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n\n    for (n = 0; n < 48; n += 2) {\n      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n      h = c8 ^ (c2 << 1 | c3 >>> 31);\n      l = c9 ^ (c3 << 1 | c2 >>> 31);\n      s[0] ^= h;\n      s[1] ^= l;\n      s[10] ^= h;\n      s[11] ^= l;\n      s[20] ^= h;\n      s[21] ^= l;\n      s[30] ^= h;\n      s[31] ^= l;\n      s[40] ^= h;\n      s[41] ^= l;\n      h = c0 ^ (c4 << 1 | c5 >>> 31);\n      l = c1 ^ (c5 << 1 | c4 >>> 31);\n      s[2] ^= h;\n      s[3] ^= l;\n      s[12] ^= h;\n      s[13] ^= l;\n      s[22] ^= h;\n      s[23] ^= l;\n      s[32] ^= h;\n      s[33] ^= l;\n      s[42] ^= h;\n      s[43] ^= l;\n      h = c2 ^ (c6 << 1 | c7 >>> 31);\n      l = c3 ^ (c7 << 1 | c6 >>> 31);\n      s[4] ^= h;\n      s[5] ^= l;\n      s[14] ^= h;\n      s[15] ^= l;\n      s[24] ^= h;\n      s[25] ^= l;\n      s[34] ^= h;\n      s[35] ^= l;\n      s[44] ^= h;\n      s[45] ^= l;\n      h = c4 ^ (c8 << 1 | c9 >>> 31);\n      l = c5 ^ (c9 << 1 | c8 >>> 31);\n      s[6] ^= h;\n      s[7] ^= l;\n      s[16] ^= h;\n      s[17] ^= l;\n      s[26] ^= h;\n      s[27] ^= l;\n      s[36] ^= h;\n      s[37] ^= l;\n      s[46] ^= h;\n      s[47] ^= l;\n      h = c6 ^ (c0 << 1 | c1 >>> 31);\n      l = c7 ^ (c1 << 1 | c0 >>> 31);\n      s[8] ^= h;\n      s[9] ^= l;\n      s[18] ^= h;\n      s[19] ^= l;\n      s[28] ^= h;\n      s[29] ^= l;\n      s[38] ^= h;\n      s[39] ^= l;\n      s[48] ^= h;\n      s[49] ^= l;\n      b0 = s[0];\n      b1 = s[1];\n      b32 = s[11] << 4 | s[10] >>> 28;\n      b33 = s[10] << 4 | s[11] >>> 28;\n      b14 = s[20] << 3 | s[21] >>> 29;\n      b15 = s[21] << 3 | s[20] >>> 29;\n      b46 = s[31] << 9 | s[30] >>> 23;\n      b47 = s[30] << 9 | s[31] >>> 23;\n      b28 = s[40] << 18 | s[41] >>> 14;\n      b29 = s[41] << 18 | s[40] >>> 14;\n      b20 = s[2] << 1 | s[3] >>> 31;\n      b21 = s[3] << 1 | s[2] >>> 31;\n      b2 = s[13] << 12 | s[12] >>> 20;\n      b3 = s[12] << 12 | s[13] >>> 20;\n      b34 = s[22] << 10 | s[23] >>> 22;\n      b35 = s[23] << 10 | s[22] >>> 22;\n      b16 = s[33] << 13 | s[32] >>> 19;\n      b17 = s[32] << 13 | s[33] >>> 19;\n      b48 = s[42] << 2 | s[43] >>> 30;\n      b49 = s[43] << 2 | s[42] >>> 30;\n      b40 = s[5] << 30 | s[4] >>> 2;\n      b41 = s[4] << 30 | s[5] >>> 2;\n      b22 = s[14] << 6 | s[15] >>> 26;\n      b23 = s[15] << 6 | s[14] >>> 26;\n      b4 = s[25] << 11 | s[24] >>> 21;\n      b5 = s[24] << 11 | s[25] >>> 21;\n      b36 = s[34] << 15 | s[35] >>> 17;\n      b37 = s[35] << 15 | s[34] >>> 17;\n      b18 = s[45] << 29 | s[44] >>> 3;\n      b19 = s[44] << 29 | s[45] >>> 3;\n      b10 = s[6] << 28 | s[7] >>> 4;\n      b11 = s[7] << 28 | s[6] >>> 4;\n      b42 = s[17] << 23 | s[16] >>> 9;\n      b43 = s[16] << 23 | s[17] >>> 9;\n      b24 = s[26] << 25 | s[27] >>> 7;\n      b25 = s[27] << 25 | s[26] >>> 7;\n      b6 = s[36] << 21 | s[37] >>> 11;\n      b7 = s[37] << 21 | s[36] >>> 11;\n      b38 = s[47] << 24 | s[46] >>> 8;\n      b39 = s[46] << 24 | s[47] >>> 8;\n      b30 = s[8] << 27 | s[9] >>> 5;\n      b31 = s[9] << 27 | s[8] >>> 5;\n      b12 = s[18] << 20 | s[19] >>> 12;\n      b13 = s[19] << 20 | s[18] >>> 12;\n      b44 = s[29] << 7 | s[28] >>> 25;\n      b45 = s[28] << 7 | s[29] >>> 25;\n      b26 = s[38] << 8 | s[39] >>> 24;\n      b27 = s[39] << 8 | s[38] >>> 24;\n      b8 = s[48] << 14 | s[49] >>> 18;\n      b9 = s[49] << 14 | s[48] >>> 18;\n      s[0] = b0 ^ ~b2 & b4;\n      s[1] = b1 ^ ~b3 & b5;\n      s[10] = b10 ^ ~b12 & b14;\n      s[11] = b11 ^ ~b13 & b15;\n      s[20] = b20 ^ ~b22 & b24;\n      s[21] = b21 ^ ~b23 & b25;\n      s[30] = b30 ^ ~b32 & b34;\n      s[31] = b31 ^ ~b33 & b35;\n      s[40] = b40 ^ ~b42 & b44;\n      s[41] = b41 ^ ~b43 & b45;\n      s[2] = b2 ^ ~b4 & b6;\n      s[3] = b3 ^ ~b5 & b7;\n      s[12] = b12 ^ ~b14 & b16;\n      s[13] = b13 ^ ~b15 & b17;\n      s[22] = b22 ^ ~b24 & b26;\n      s[23] = b23 ^ ~b25 & b27;\n      s[32] = b32 ^ ~b34 & b36;\n      s[33] = b33 ^ ~b35 & b37;\n      s[42] = b42 ^ ~b44 & b46;\n      s[43] = b43 ^ ~b45 & b47;\n      s[4] = b4 ^ ~b6 & b8;\n      s[5] = b5 ^ ~b7 & b9;\n      s[14] = b14 ^ ~b16 & b18;\n      s[15] = b15 ^ ~b17 & b19;\n      s[24] = b24 ^ ~b26 & b28;\n      s[25] = b25 ^ ~b27 & b29;\n      s[34] = b34 ^ ~b36 & b38;\n      s[35] = b35 ^ ~b37 & b39;\n      s[44] = b44 ^ ~b46 & b48;\n      s[45] = b45 ^ ~b47 & b49;\n      s[6] = b6 ^ ~b8 & b0;\n      s[7] = b7 ^ ~b9 & b1;\n      s[16] = b16 ^ ~b18 & b10;\n      s[17] = b17 ^ ~b19 & b11;\n      s[26] = b26 ^ ~b28 & b20;\n      s[27] = b27 ^ ~b29 & b21;\n      s[36] = b36 ^ ~b38 & b30;\n      s[37] = b37 ^ ~b39 & b31;\n      s[46] = b46 ^ ~b48 & b40;\n      s[47] = b47 ^ ~b49 & b41;\n      s[8] = b8 ^ ~b0 & b2;\n      s[9] = b9 ^ ~b1 & b3;\n      s[18] = b18 ^ ~b10 & b12;\n      s[19] = b19 ^ ~b11 & b13;\n      s[28] = b28 ^ ~b20 & b22;\n      s[29] = b29 ^ ~b21 & b23;\n      s[38] = b38 ^ ~b30 & b32;\n      s[39] = b39 ^ ~b31 & b33;\n      s[48] = b48 ^ ~b40 & b42;\n      s[49] = b49 ^ ~b41 & b43;\n      s[0] ^= RC[n];\n      s[1] ^= RC[n + 1];\n    }\n  };\n\n  if (COMMON_JS) {\n    module.exports = methods;\n  } else {\n    for (i = 0; i < methodNames.length; ++i) {\n      root[methodNames[i]] = methods[methodNames[i]];\n    }\n\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return methods;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n\n//# sourceURL=webpack://keystore_wdc_contract/./sha3.js?");

/***/ }),

/***/ "./contract-src/base58.ts":
/*!********************************!*\
  !*** ./contract-src/base58.ts ***!
  \********************************/
/*! flagged exports */
/*! export Base [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Base58 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Base58 = exports.Base = void 0;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar Base = /** @class */ (function () {\n    function Base(ALPHABET) {\n        this.ALPHABET_MAP = {};\n        this.BASE = ALPHABET.length;\n        this.LEADER = ALPHABET.charAt(0);\n        // pre-compute lookup table\n        for (var z = 0; z < ALPHABET.length; z++) {\n            var x = ALPHABET.charAt(z);\n            if (this.ALPHABET_MAP[x] !== undefined)\n                throw new TypeError(x + ' is ambiguous');\n            this.ALPHABET_MAP[x] = z;\n        }\n        this.ALPHABET = ALPHABET;\n    }\n    Base.prototype.encode = function (src) {\n        var source = utils_1.hex2bin(src);\n        if (source.length === 0)\n            return '';\n        var digits = [0];\n        for (var i = 0; i < source.length; ++i) {\n            var carry = source[i];\n            for (var j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.BASE;\n                carry = (carry / this.BASE) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.BASE);\n                carry = (carry / this.BASE) | 0;\n            }\n        }\n        var string = '';\n        // deal with leading zeros\n        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k)\n            string += this.LEADER;\n        // convert digits to a string\n        for (var q = digits.length - 1; q >= 0; --q)\n            string += this.ALPHABET[digits[q]];\n        return string;\n    };\n    Base.prototype.decodeUnsafe = function (str) {\n        if (typeof str !== 'string')\n            throw new TypeError('Expected String');\n        if (str.length === 0)\n            return new Uint8Array(0);\n        var bytes = [0];\n        for (var i = 0; i < str.length; i++) {\n            var value = this.ALPHABET_MAP[str[i]];\n            if (value === undefined)\n                throw new Error(\"invalid char \" + str[i]);\n            var carry = value;\n            for (var j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.BASE;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (var k = 0; str[k] === this.LEADER && k < str.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return new Uint8Array(bytes.reverse());\n    };\n    Base.prototype.decode = function (str) {\n        var buffer = this.decodeUnsafe(str);\n        if (buffer)\n            return buffer;\n        throw new Error('Non-base' + this.BASE + ' character');\n    };\n    return Base;\n}());\nexports.Base = Base;\nexports.Base58 = new Base('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/base58.ts?");

/***/ }),

/***/ "./contract-src/builder.ts":
/*!*********************************!*\
  !*** ./contract-src/builder.ts ***!
  \*********************************/
/*! flagged exports */
/*! export TransactionBuilder [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransactionBuilder = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"./contract-src/types.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar contract_1 = __webpack_require__(/*! ../contract */ \"./contract.js\");\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\nvar contract_2 = __webpack_require__(/*! ./contract */ \"./contract-src/contract.ts\");\nvar tx_1 = __webpack_require__(/*! ./tx */ \"./contract-src/tx.ts\");\nvar rlp = __webpack_require__(/*! ./rlp */ \"./contract-src/rlp.ts\");\nvar TransactionBuilder = /** @class */ (function () {\n    function TransactionBuilder(version, sk, gasLimit, gasPrice, nonce) {\n        this.version = utils_1.dig2str(version || '1');\n        this.sk = contract_1.bin2hex(sk || '');\n        this.gasPrice = utils_1.dig2str(gasPrice || 200000);\n        this.nonce = utils_1.dig2str(nonce || 0);\n        this.gasLimit = utils_1.dig2str(gasLimit || 0);\n    }\n    TransactionBuilder.prototype.increaseNonce = function () {\n        var nonce = new BN(this.nonce);\n        nonce = nonce.add(types_1.ONE);\n        this.nonce = nonce.toString(10);\n    };\n    /**\n     * \n     */\n    TransactionBuilder.prototype.buildDeploy = function (contract, _parameters, amount) {\n        utils_1.assert(contract instanceof contract_2.Contract, 'create a instanceof Contract by new tool.Contract(addr, abi)');\n        utils_1.assert(utils_1.isBin(contract.binary), 'contract binary should be uint8 array');\n        utils_1.assert(contract.abi, 'missing contract abi');\n        var parameters = contract_2.normalizeParams(_parameters);\n        var inputs;\n        var binary = contract.binary;\n        if (contract.abi.filter(function (x) { return x.name === 'init'; }).length > 0)\n            inputs = contract.abiEncode('init', parameters);\n        else\n            inputs = [[], [], []];\n        var ret = this.buildCommon(types_1.constants.WASM_DEPLOY, amount, rlp.encode([this.gasLimit || 0, utils_1.hex2bin(binary), inputs, contract.abiToBinary()]), new Uint8Array(20));\n        ret.__abi = contract.abi;\n        ret.__setInputs(parameters);\n        return ret;\n    };\n    /**\n     * \n     * @param { Contract} contract \n     * @param {string} method \n     * @param { Array | Object } [parameters] \n     * @param amount [number] \n     * @returns { Transaction }\n     */\n    TransactionBuilder.prototype.buildContractCall = function (contract, method, _parameters, amount) {\n        utils_1.assert(contract instanceof contract_2.Contract, 'create a instanceof Contract by new tool.Contract(addr, abi)');\n        utils_1.assert(contract.abi, 'missing contract abi');\n        utils_1.assert(contract.address, 'missing contract address');\n        var parameters = contract_2.normalizeParams(_parameters);\n        var addr = utils_1.normalizeAddress(contract.address);\n        var inputs = contract.abiEncode(method, parameters);\n        var ret = this.buildCommon(types_1.constants.WASM_CALL, amount, rlp.encode([this.gasLimit || 0, method, inputs]), contract_1.bin2hex(addr));\n        ret.__abi = contract.abi;\n        ret.__setInputs(parameters);\n        return ret;\n    };\n    /**\n     * \n     */\n    TransactionBuilder.prototype.buildCommon = function (type, amount, payload, to) {\n        var ret = new tx_1.Transaction(this.version, type, 0, utils_1.privateKey2PublicKey(this.sk), this.gasPrice, amount || 0, payload || '', to);\n        if (this.nonce) {\n            ret.nonce = utils_1.dig2str(this.nonce);\n            this.increaseNonce();\n            ret.sign(this.sk);\n        }\n        return ret;\n    };\n    return TransactionBuilder;\n}());\nexports.TransactionBuilder = TransactionBuilder;\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/builder.ts?");

/***/ }),

/***/ "./contract-src/contract.ts":
/*!**********************************!*\
  !*** ./contract-src/contract.ts ***!
  \**********************************/
/*! flagged exports */
/*! export ABI [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Contract [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TypeDef [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compileABI [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compileContract [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getContractAddress [provided] [no usage info] [missing usage info prevents renaming] */
/*! export normalizeParams [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Contract = exports.normalizeParams = exports.ABI = exports.TypeDef = exports.compileABI = exports.compileContract = exports.getContractAddress = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"./contract-src/types.ts\");\nvar child_process = __webpack_require__(/*! child_process */ \"?df8b\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\nvar contract_1 = __webpack_require__(/*! ../contract */ \"./contract.js\");\nvar rlp = __webpack_require__(/*! ./rlp */ \"./contract-src/rlp.ts\");\n/**\n * \n */\nfunction getContractAddress(hash) {\n    var buf = rlp.encode([utils_1.hex2bin(hash), 0]);\n    buf = utils_1.rmd160(buf);\n    return utils_1.publicKeyHash2Address(buf);\n}\nexports.getContractAddress = getContractAddress;\nfunction compileContract(ascPath, src, opts) {\n    var cmd = ascPath + ' ' + src + ' -b '; // \n    if (opts && opts.debug)\n        cmd += ' --debug ';\n    if (opts && opts.optimize)\n        cmd += ' --optimize ';\n    return new Promise(function (resolve, reject) {\n        child_process.exec(cmd, { encoding: 'buffer' }, function (err, stdout, stderr) {\n            if (err) {\n                // err.code  exit code 0 \n                // err.signal \n                reject(stderr.toString('ascii'));\n            }\n            resolve(stdout);\n        });\n    });\n}\nexports.compileContract = compileContract;\n/**\n *  ABI\n */\nfunction compileABI(_str) {\n    var str = utils_1.bin2str(_str);\n    var TYPES = {\n        u64: 'u64',\n        i64: 'i64',\n        f64: 'f64',\n        bool: 'bool',\n        string: 'string',\n        ArrayBuffer: 'bytes',\n        Address: 'address',\n        U256: 'u256',\n        String: 'string',\n        boolean: 'bool'\n    };\n    function getOutputs(str) {\n        if (str === 'void')\n            return [];\n        var ret = TYPES[str];\n        if (!ret)\n            throw new Error(\"invalid type: \" + str);\n        return [new TypeDef(ret)];\n    }\n    function getInputs(str, event) {\n        var ret = [];\n        for (var _i = 0, _a = str.split(','); _i < _a.length; _i++) {\n            var p = _a[_i];\n            if (!p)\n                continue;\n            var lr = p.split(':');\n            var l = lr[0].trim();\n            if (event) {\n                if (!l.startsWith('readonly'))\n                    throw new Error(\"event constructor field \" + l + \" should starts with readonly\");\n                l = l.split(' ')[1];\n            }\n            var r = lr[1].trim();\n            var o = new TypeDef(TYPES[r], l);\n            if (!o.type)\n                throw new Error(\"invalid type: \" + r);\n            ret.push(o);\n        }\n        return ret;\n    }\n    var ret = [];\n    var funRe = /export[\\s\\n\\t]+function[\\s\\n\\t]+([a-zA-Z_][a-zA-Z0-9_]*)[\\s\\n\\t]*\\(([a-z\\n\\s\\tA-Z0-9_,:]*)\\)[\\s\\n\\t]*:[\\s\\n\\t]*([a-zA-Z_][a-zA-Z0-9_]*)[\\s\\n\\t]*{/g;\n    var eventRe = /@unmanaged[\\s\\n\\t]+class[\\s\\n\\t]+([a-zA-Z_][a-zA-Z0-9]*)[\\s\\n\\t]*\\{[\\s\\n\\t]*constructor[\\s\\n\\t]*\\(([a-z\\n\\s\\tA-Z0-9_,:]*)\\)/g;\n    var contains__idof = false;\n    for (var _i = 0, _a = (str.match(funRe) || []); _i < _a.length; _i++) {\n        var m = _a[_i];\n        funRe.lastIndex = 0;\n        var r = funRe.exec(m);\n        if (r[1] === '__idof') {\n            contains__idof = true;\n            continue;\n        }\n        ret.push(new ABI(r[1], 'function', getInputs(r[2]), getOutputs(r[3])));\n    }\n    for (var _b = 0, _c = (str.match(eventRe) || []); _b < _c.length; _b++) {\n        var m = _c[_b];\n        eventRe.lastIndex = 0;\n        var r = eventRe.exec(m);\n        ret.push(new ABI(r[1], 'event', [], getInputs(r[2], true)));\n    }\n    if (!contains__idof)\n        throw new Error('any contract must contains an __idof function');\n    return ret;\n}\nexports.compileABI = compileABI;\nvar TypeDef = /** @class */ (function () {\n    function TypeDef(type, name) {\n        type = type && type.toLocaleLowerCase();\n        utils_1.assert(types_1.ABI_DATA_TYPE_TABLE.indexOf(type) >= 0, \"invalid abi type def name = \" + name + \" type = \" + type);\n        this.type = type;\n        this.name = name;\n    }\n    TypeDef.from = function (o) {\n        return new TypeDef(o.type, o.name);\n    };\n    return TypeDef;\n}());\nexports.TypeDef = TypeDef;\nvar ABI = /** @class */ (function () {\n    function ABI(name, type, inputs, outputs) {\n        utils_1.assert(name, 'expect name of abi');\n        utils_1.assert(type === 'function' || type === 'event', \"invalid abi type \" + type);\n        utils_1.assert(!inputs || Array.isArray(inputs), \"invalid inputs \" + inputs);\n        utils_1.assert(!outputs || Array.isArray(outputs), \"invalid inputs \" + outputs);\n        this.name = name;\n        this.type = type;\n        this.inputs = (inputs || []).map(TypeDef.from);\n        this.outputs = (outputs || []).map(TypeDef.from);\n    }\n    ABI.from = function (o) {\n        return new ABI(o.name, o.type, o.inputs, o.outputs);\n    };\n    // able to return object instead of array\n    ABI.prototype.returnsObj = function () {\n        return this.outputs.every(function (v) { return v.name; }) && ((new Set(this.outputs.map(function (v) { return v.name; }))).size === this.outputs.length);\n    };\n    // able to input object instead of array\n    ABI.prototype.inputsObj = function () {\n        return this.inputs.every(function (v) { return v.name; }) && ((new Set(this.inputs.map(function (v) { return v.name; }))).size === this.inputs.length);\n    };\n    ABI.prototype.toObj = function (arr, input) {\n        var p = input ? this.inputs : this.outputs;\n        var o = {};\n        for (var i = 0; i < p.length; i++) {\n            o[p[i].name] = arr[i];\n        }\n        return o;\n    };\n    ABI.prototype.toArr = function (obj, input) {\n        var p = input ? this.inputs : this.outputs;\n        var arr = [];\n        for (var i = 0; i < p.length; i++) {\n            arr.push(obj[p[i].name]);\n        }\n        return arr;\n    };\n    return ABI;\n}());\nexports.ABI = ABI;\nfunction normalizeParams(params) {\n    if (params === null || params === undefined)\n        return [];\n    if (typeof params === 'string' || typeof params === 'boolean' || typeof params === 'number' || params instanceof ArrayBuffer || params instanceof Uint8Array || params instanceof BN)\n        return [params];\n    return params;\n}\nexports.normalizeParams = normalizeParams;\nfunction abiDecode(outputs, buf) {\n    buf = buf || [];\n    var len = buf.length;\n    if (len === 0)\n        return [];\n    var arr = buf;\n    var returnObject = outputs.every(function (v) { return v.name; }) && ((new Set(outputs.map(function (v) { return v.name; }))).size === outputs.length);\n    if (arr.length != outputs.length)\n        throw new Error(\"abi decode failed , expect \" + outputs.length + \" returns while \" + arr.length + \" found\");\n    var ret = returnObject ? {} : [];\n    for (var i = 0; i < arr.length; i++) {\n        var t = outputs[i].type;\n        var name_1 = outputs[i].name;\n        var val = void 0;\n        switch (t) {\n            case 'bytes': {\n                val = contract_1.bin2hex(arr[i]);\n                break;\n            }\n            case 'address': {\n                val = utils_1.publicKeyHash2Address(arr[i]);\n                break;\n            }\n            case 'u256':\n            case 'u64': {\n                var n = new BN(arr[i]);\n                if (t === 'u64')\n                    utils_1.assert(n.cmp(types_1.MAX_U64) <= 0, n.toString(10) + \" overflows max u64 \" + types_1.MAX_U64.toString(10));\n                if (t === 'u256')\n                    utils_1.assert(n.cmp(types_1.MAX_U256) <= 0, n.toString(10) + \" overflows max u256 \" + types_1.MAX_U256.toString(10));\n                val = utils_1.toSafeInt(n);\n                break;\n            }\n            case 'i64': {\n                var n = void 0;\n                var padded = utils_1.padPrefix(arr[i], 0, 8);\n                var isneg = padded[0] & 0x80;\n                if (!isneg) {\n                    n = new BN(arr[i]);\n                }\n                else {\n                    n = new BN(utils_1.inverse(padded));\n                    n = n.add(types_1.ONE);\n                    n = n.neg();\n                }\n                val = utils_1.toSafeInt(n);\n                break;\n            }\n            case 'f64': {\n                val = utils_1.bytesToF64(arr[i]);\n                break;\n            }\n            case 'string': {\n                val = utils_1.bin2str(arr[i]);\n                break;\n            }\n            case 'bool': {\n                val = arr[i].length > 0;\n                break;\n            }\n        }\n        if (returnObject)\n            ret[name_1] = val;\n        else\n            ret[i] = val;\n    }\n    return ret;\n}\nvar Contract = /** @class */ (function () {\n    function Contract(address, abi, binary) {\n        if (address)\n            this.address = contract_1.bin2hex(address);\n        this.abi = (abi || []).map(ABI.from);\n        if (binary)\n            this.binary = utils_1.hex2bin(binary);\n    }\n    Contract.prototype.abiEncode = function (name, li) {\n        var func = this.getABI(name, 'function');\n        var retType = func.outputs && func.outputs[0] && func.outputs[0].type;\n        var retTypes = retType ? [types_1.ABI_DATA_TYPE_TABLE.indexOf(retType)] : [];\n        if (typeof li === 'string' || typeof li === 'number' || li instanceof BN || li instanceof ArrayBuffer || li instanceof Uint8Array || typeof li === 'boolean')\n            return this.abiEncode(name, [li]);\n        if (li === undefined || li === null)\n            return [[], [], retTypes];\n        if (Array.isArray(li)) {\n            var arr_1 = [];\n            var types_2 = [];\n            if (li.length != func.inputs.length)\n                throw new Error(\"abi encode failed for \" + func.name + \", expect \" + func.inputs.length + \" parameters while \" + li.length + \" found\");\n            for (var i = 0; i < li.length; i++) {\n                arr_1[i] = utils_1.convert(li[i], types_1.ABI_DATA_TYPE_TABLE.indexOf(func.inputs[i].type));\n                types_2[i] = types_1.ABI_DATA_TYPE_TABLE.indexOf(func.inputs[i].type);\n            }\n            return [types_2, arr_1, retTypes];\n        }\n        var arr = [];\n        var types = [];\n        for (var i = 0; i < func.inputs.length; i++) {\n            var input = func.inputs[i];\n            types[i] = types_1.ABI_DATA_TYPE_TABLE.indexOf(func.inputs[i].type);\n            if (!(input.name in li)) {\n                throw new Error(\"key \" + input.name + \" not found in parameters\");\n            }\n            arr[i] = utils_1.convert(li[input.name], types_1.ABI_DATA_TYPE_TABLE.indexOf(input.type));\n        }\n        return [types, arr, retTypes];\n    };\n    Contract.prototype.abiDecode = function (name, buf, type) {\n        type = type || 'function';\n        buf = buf || [];\n        if (buf.length === 0)\n            return [];\n        var a = this.getABI(name, type);\n        var ret = abiDecode(a.outputs, buf);\n        if (type === 'function')\n            return ret && ret[0];\n        return ret;\n    };\n    /**\n     *  paylod\n     */\n    Contract.prototype.abiToBinary = function () {\n        var ret = [];\n        for (var _i = 0, _a = this.abi; _i < _a.length; _i++) {\n            var a = _a[_i];\n            ret.push([a.name, a.type === 'function' ? 0 : 1, a.inputs.map(function (x) { return types_1.ABI_DATA_ENUM[x.type]; }), a.outputs.map(function (x) { return types_1.ABI_DATA_ENUM[x.type]; })]);\n        }\n        return ret;\n    };\n    Contract.prototype.getABI = function (name, type) {\n        var funcs = this.abi.filter(function (x) { return x.type === type && x.name === name; });\n        utils_1.assert(funcs.length === 1, \"exact exists one and only one abi \" + name + \", while found \" + funcs.length);\n        return funcs[0];\n    };\n    return Contract;\n}());\nexports.Contract = Contract;\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/contract.ts?");

/***/ }),

/***/ "./contract-src/index.ts":
/*!*******************************!*\
  !*** ./contract-src/index.ts ***!
  \*******************************/
/*! flagged exports */
/*! export Contract [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export RPC [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export TX_STATUS [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export TransactionBuilder [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export __esModule [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export address2PublicKeyHash [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export assertAddress [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export bin2hex [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export compileABI [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export compileContract [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export getContractAddress [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export privateKey2PublicKey [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export publicKey2Hash [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export publicKeyHash2Address [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! export rlp [provided] [maybe used in main (runtime-defined)] [usage and provision prevents renaming] -> ./contract-src/rlp.ts */
/*!   export RLPList [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export byteArrayToInt [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export decode [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export decodeElements [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export encode [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export encodeElements [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export encodeString [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export numberToByteArray [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! export rmd160 [provided] [maybe used in main (runtime-defined)] [usage prevents renaming] */
/*! other exports [not provided] [maybe used in main (runtime-defined)] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getContractAddress = exports.Contract = exports.compileABI = exports.compileContract = exports.TX_STATUS = exports.rlp = exports.RPC = exports.TransactionBuilder = exports.assertAddress = exports.address2PublicKeyHash = exports.rmd160 = exports.bin2hex = exports.publicKey2Hash = exports.publicKeyHash2Address = exports.privateKey2PublicKey = void 0;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nObject.defineProperty(exports, \"privateKey2PublicKey\", ({ enumerable: true, get: function () { return utils_1.privateKey2PublicKey; } }));\nObject.defineProperty(exports, \"publicKeyHash2Address\", ({ enumerable: true, get: function () { return utils_1.publicKeyHash2Address; } }));\nObject.defineProperty(exports, \"publicKey2Hash\", ({ enumerable: true, get: function () { return utils_1.publicKey2Hash; } }));\nObject.defineProperty(exports, \"bin2hex\", ({ enumerable: true, get: function () { return utils_1.bin2hex; } }));\nObject.defineProperty(exports, \"rmd160\", ({ enumerable: true, get: function () { return utils_1.rmd160; } }));\nObject.defineProperty(exports, \"address2PublicKeyHash\", ({ enumerable: true, get: function () { return utils_1.address2PublicKeyHash; } }));\nObject.defineProperty(exports, \"assertAddress\", ({ enumerable: true, get: function () { return utils_1.assertAddress; } }));\nvar builder_1 = __webpack_require__(/*! ./builder */ \"./contract-src/builder.ts\");\nObject.defineProperty(exports, \"TransactionBuilder\", ({ enumerable: true, get: function () { return builder_1.TransactionBuilder; } }));\nvar rpc_1 = __webpack_require__(/*! ./rpc */ \"./contract-src/rpc.ts\");\nObject.defineProperty(exports, \"RPC\", ({ enumerable: true, get: function () { return rpc_1.RPC; } }));\nexports.rlp = __webpack_require__(/*! ./rlp */ \"./contract-src/rlp.ts\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./contract-src/types.ts\");\nObject.defineProperty(exports, \"TX_STATUS\", ({ enumerable: true, get: function () { return types_1.TX_STATUS; } }));\nvar contract_1 = __webpack_require__(/*! ./contract */ \"./contract-src/contract.ts\");\nObject.defineProperty(exports, \"compileContract\", ({ enumerable: true, get: function () { return contract_1.compileContract; } }));\nObject.defineProperty(exports, \"compileABI\", ({ enumerable: true, get: function () { return contract_1.compileABI; } }));\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contract_1.Contract; } }));\nObject.defineProperty(exports, \"getContractAddress\", ({ enumerable: true, get: function () { return contract_1.getContractAddress; } }));\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/index.ts?");

/***/ }),

/***/ "./contract-src/rlp.ts":
/*!*****************************!*\
  !*** ./contract-src/rlp.ts ***!
  \*****************************/
/*! flagged exports */
/*! export RLPList [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export byteArrayToInt [provided] [no usage info] [missing usage info prevents renaming] */
/*! export decode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export decodeElements [provided] [no usage info] [missing usage info prevents renaming] */
/*! export encode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export encodeElements [provided] [no usage info] [missing usage info prevents renaming] */
/*! export encodeString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export numberToByteArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RLPList = exports.decodeElements = exports.decode = exports.encode = exports.encodeString = exports.encodeElements = exports.numberToByteArray = exports.byteArrayToInt = void 0;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar OFFSET_SHORT_ITEM = 0x80;\nvar SIZE_THRESHOLD = 56;\nvar OFFSET_LONG_ITEM = 0xb7;\nvar OFFSET_SHORT_LIST = 0xc0;\nvar OFFSET_LONG_LIST = 0xf7;\nvar EMPTY_BYTES = new Uint8Array(0);\nvar EMPTY_RLP_ARRAY = new Uint8Array([0xc0]);\nvar NULL_RLP = new Uint8Array([0x80]);\nvar utils_2 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\n/**\n *  number\n */\nfunction byteArrayToInt(bytes) {\n    var arr = utils_2.hex2bin(bytes);\n    var ret = 0;\n    for (var i = 0; i < arr.length; i++) {\n        var u = arr[arr.length - i - 1];\n        ret += (u << (i * 8));\n    }\n    return ret;\n}\nexports.byteArrayToInt = byteArrayToInt;\n/**\n * number \n */\nfunction numberToByteArray(u) {\n    if (u < 0 || !Number.isInteger(u))\n        throw new Error(\"cannot convert number \" + u + \" to byte array\");\n    var buf = new Uint8Array(8);\n    for (var i = 0; i < 8; i++) {\n        buf[buf.length - 1 - i] = u & 0xff;\n        u = u >>> 8;\n    }\n    var k = 8;\n    for (var i = 0; i < 8; i++) {\n        if (buf[i] !== 0) {\n            k = i;\n            break;\n        }\n    }\n    return buf.slice(k, buf.length);\n}\nexports.numberToByteArray = numberToByteArray;\nfunction isRLPList(encoded) {\n    return encoded[0] >= OFFSET_SHORT_LIST;\n}\nfunction encodeBytes(b) {\n    var bytes = b instanceof Uint8Array ? b : new Uint8Array(b);\n    if (bytes.length === 0) {\n        var ret_1 = new Uint8Array(1);\n        ret_1[0] = OFFSET_SHORT_ITEM;\n        return ret_1;\n    }\n    if (bytes.length === 1 && (bytes[0] & 0xFF) < OFFSET_SHORT_ITEM) {\n        return bytes;\n    }\n    if (bytes.length < SIZE_THRESHOLD) {\n        // length = 8X\n        var prefix = OFFSET_SHORT_ITEM + bytes.length;\n        var ret_2 = new Uint8Array(bytes.length + 1);\n        for (var i = 0; i < bytes.length; i++) {\n            ret_2[i + 1] = bytes[i];\n        }\n        ret_2[0] = prefix;\n        return ret_2;\n    }\n    var tmpLength = bytes.length;\n    var lengthOfLength = 0;\n    while (tmpLength !== 0) {\n        lengthOfLength = lengthOfLength + 1;\n        tmpLength = tmpLength >> 8;\n    }\n    var ret = new Uint8Array(1 + lengthOfLength + bytes.length);\n    ret[0] = OFFSET_LONG_ITEM + lengthOfLength;\n    // copy length after first byte\n    tmpLength = bytes.length;\n    for (var i = lengthOfLength; i > 0; --i) {\n        ret[i] = (tmpLength & 0xFF);\n        tmpLength = tmpLength >> 8;\n    }\n    for (var i = 0; i < bytes.length; i++) {\n        ret[i + 1 + lengthOfLength] = bytes[i];\n    }\n    return ret;\n}\n/**\n * encode elements to rlp list\n */\nfunction encodeElements(elements) {\n    var totalLength = 0;\n    for (var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        totalLength += el.length;\n    }\n    var data;\n    var copyPos;\n    if (totalLength < SIZE_THRESHOLD) {\n        data = new Uint8Array(1 + totalLength);\n        data[0] = OFFSET_SHORT_LIST + totalLength;\n        copyPos = 1;\n    }\n    else {\n        // length of length = BX\n        // prefix = [BX, [length]]\n        var tmpLength = totalLength;\n        var byteNum = 0;\n        while (tmpLength !== 0) {\n            ++byteNum;\n            tmpLength = tmpLength >> 8;\n        }\n        tmpLength = totalLength;\n        var lenBytes = new Uint8Array(byteNum);\n        for (var i = 0; i < byteNum; ++i) {\n            lenBytes[byteNum - 1 - i] = ((tmpLength >> (8 * i)) & 0xFF);\n        }\n        // first byte = F7 + bytes.length\n        data = new Uint8Array(1 + lenBytes.length + totalLength);\n        data[0] = OFFSET_LONG_LIST + byteNum;\n        for (var i = 0; i < lenBytes.length; i++) {\n            data[i + 1] = lenBytes[i];\n        }\n        copyPos = lenBytes.length + 1;\n    }\n    for (var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        for (var j = 0; j < el.length; j++) {\n            data[j + copyPos] = el[j];\n        }\n        copyPos += el.length;\n    }\n    return data;\n}\nexports.encodeElements = encodeElements;\nfunction copyOfRange(bytes, from, to) {\n    var ret = new Uint8Array(to - from);\n    var j = 0;\n    for (var i = from; i < to; i++) {\n        ret[j] = bytes[i];\n        j++;\n    }\n    return ret;\n}\nfunction estimateSize(encoded) {\n    var parser = new RLPParser(encoded, 0, encoded.length);\n    return parser.peekSize();\n}\nfunction validateSize(encoded) {\n    utils_1.assert(encoded.length === estimateSize(encoded), 'invalid rlp format');\n}\nfunction encodeString(s) {\n    return encodeBytes(utils_2.str2bin(s));\n}\nexports.encodeString = encodeString;\nfunction encode(o) {\n    if (o && (typeof o.getEncoded === 'function')) {\n        return o.getEncoded();\n    }\n    if (o === null || o === undefined)\n        return NULL_RLP;\n    if (o instanceof ArrayBuffer)\n        o = new Uint8Array(o);\n    if (typeof o === 'string')\n        return encodeString(o);\n    if (typeof o === 'number') {\n        utils_1.assert(o >= 0 && Number.isInteger(o), o + \" is not a valid non-negative integer\");\n        return encodeBytes(numberToByteArray(o));\n    }\n    if (typeof o === 'boolean')\n        return o ? new Uint8Array([0x01]) : NULL_RLP;\n    if (o instanceof Uint8Array)\n        return encodeBytes(o);\n    if (o instanceof BN) {\n        return encodeBytes(utils_2.trimLeadingZeros(o.toArrayLike(Uint8Array, 'be')));\n    }\n    if (Array.isArray(o)) {\n        var elements = o.map(function (x) { return encode(x); });\n        return encodeElements(elements);\n    }\n}\nexports.encode = encode;\nfunction decode(e) {\n    var encoded = e instanceof ArrayBuffer ? new Uint8Array(e) : e;\n    validateSize(encoded);\n    if (!isRLPList(encoded)) {\n        var parser_1 = new RLPParser(encoded, 0, encoded.length);\n        if (encoded.length === 1 && encoded[0] === 0x80)\n            return EMPTY_BYTES;\n        if (parser_1.remained() > 1) {\n            parser_1.skip(parser_1.prefixLength());\n        }\n        return parser_1.bytes(parser_1.remained());\n    }\n    var parser = new RLPParser(encoded, 0, encoded.length);\n    parser.skip(parser.prefixLength());\n    var ret = [];\n    while (parser.remained() > 0) {\n        ret.push(decode(parser.bytes(parser.peekSize())));\n    }\n    return ret;\n}\nexports.decode = decode;\nfunction decodeElements(enc) {\n    var encoded = enc instanceof Uint8Array ? enc : new Uint8Array(enc);\n    validateSize(encoded);\n    if (!isRLPList(encoded)) {\n        throw new Error('not a rlp list');\n    }\n    var parser = new RLPParser(encoded, 0, encoded.length);\n    parser.skip(parser.prefixLength());\n    var ret = [];\n    while (parser.remained() > 0) {\n        ret.push(parser.bytes(parser.peekSize()));\n    }\n    return ret;\n}\nexports.decodeElements = decodeElements;\nvar RLPParser = /** @class */ (function () {\n    function RLPParser(buf, offset, limit) {\n        this.buf = buf;\n        this.offset = offset;\n        this.limit = limit;\n    }\n    RLPParser.prototype.prefixLength = function () {\n        var prefix = this.buf[this.offset];\n        if (prefix <= OFFSET_LONG_ITEM) {\n            return 1;\n        }\n        if (prefix < OFFSET_SHORT_LIST) {\n            return 1 + (prefix - OFFSET_LONG_ITEM);\n        }\n        if (prefix <= OFFSET_LONG_LIST) {\n            return 1;\n        }\n        return 1 + (prefix - OFFSET_LONG_LIST);\n    };\n    RLPParser.prototype.remained = function () {\n        return this.limit - this.offset;\n    };\n    RLPParser.prototype.skip = function (n) {\n        this.offset += n;\n    };\n    RLPParser.prototype.peekSize = function () {\n        var prefix = this.buf[this.offset];\n        if (prefix < OFFSET_SHORT_ITEM) {\n            return 1;\n        }\n        if (prefix <= OFFSET_LONG_ITEM) {\n            return prefix - OFFSET_SHORT_ITEM + 1;\n        }\n        if (prefix < OFFSET_SHORT_LIST) {\n            return byteArrayToInt(copyOfRange(this.buf, 1 + this.offset, 1 + this.offset + prefix - OFFSET_LONG_ITEM)) + 1 + prefix - OFFSET_LONG_ITEM;\n        }\n        if (prefix <= OFFSET_LONG_LIST) {\n            return prefix - OFFSET_SHORT_LIST + 1;\n        }\n        return byteArrayToInt(copyOfRange(this.buf, 1 + this.offset, this.offset + 1 + prefix - OFFSET_LONG_LIST))\n            + 1 + prefix - OFFSET_LONG_LIST;\n    };\n    RLPParser.prototype.u8 = function () {\n        var ret = this.buf[this.offset];\n        this.offset++;\n        return ret;\n    };\n    RLPParser.prototype.bytes = function (n) {\n        utils_1.assert(this.offset + n <= this.limit, 'read overflow');\n        var ret = this.buf.slice(this.offset, this.offset + n);\n        this.offset += n;\n        return ret;\n    };\n    return RLPParser;\n}());\nvar RLPList = /** @class */ (function () {\n    function RLPList(elements) {\n        this.elements = elements;\n    }\n    RLPList.fromEncoded = function (encoded) {\n        var els = decodeElements(encoded);\n        return new RLPList(els);\n    };\n    RLPList.prototype.list = function (index) {\n        return RLPList.fromEncoded(this.raw(index));\n    };\n    RLPList.prototype.length = function () {\n        return this.elements.length;\n    };\n    RLPList.prototype.raw = function (index) {\n        return this.elements[index];\n    };\n    RLPList.prototype.isNull = function (index) {\n        return this.elements[index].byteLength == 1 && this.elements[index][0] == 0x80;\n    };\n    RLPList.prototype.number = function (idx) {\n        return byteArrayToInt(this.bytes(idx));\n    };\n    RLPList.prototype.bool = function (idx) {\n        return this.number(idx) != 0;\n    };\n    RLPList.prototype.bytes = function (idx) {\n        return decode(this.elements[idx]);\n    };\n    RLPList.EMPTY = new RLPList([]);\n    return RLPList;\n}());\nexports.RLPList = RLPList;\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/rlp.ts?");

/***/ }),

/***/ "./contract-src/rpc.ts":
/*!*****************************!*\
  !*** ./contract-src/rpc.ts ***!
  \*****************************/
/*! flagged exports */
/*! export RPC [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RPC = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"./contract-src/types.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar rlp_1 = __webpack_require__(/*! ./rlp */ \"./contract-src/rlp.ts\");\nvar contract_1 = __webpack_require__(/*! ../contract */ \"./contract.js\");\nvar contract_2 = __webpack_require__(/*! ./contract */ \"./contract-src/contract.ts\");\nvar rlp = __webpack_require__(/*! ./rlp */ \"./contract-src/rlp.ts\");\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\nvar RPC = /** @class */ (function () {\n    /**\n     *\n     * @param host  \n     * @param port  \n     */\n    function RPC(host, port) {\n        this.host = host || 'localhost';\n        this.port = (port || 80).toString();\n        this.callbacks = new Map(); // id -> function\n        this.id2key = new Map(); // id -> address:event\n        this.id2hash = new Map(); // id -> txhash\n        this.eventHandlers = new Map(); // address:event -> [id]\n        this.txObservers = new Map(); // hash -> [id]\n        this.cid = 0;\n        this.rpcCallbacks = new Map(); // nonce -> cb\n        this.nonce = 0;\n    }\n    RPC.prototype.tryConnect = function () {\n        var _this = this;\n        var WS;\n        if (typeof WebSocket === 'string')\n            WS = WebSocket;\n        else\n            WS = __webpack_require__(/*! ws */ \"./node_modules/ws/browser.js\");\n        if (this.ws && this.ws.readyState === this.ws.OPEN) {\n            return Promise.resolve();\n        }\n        if (this.ws) {\n            var fn_1 = this.ws.onopen || (function (e) { });\n            var _rj_1 = this.ws.onerror || (function (e) { });\n            var p_1 = new Promise(function (rs, rj) {\n                _this.ws.onopen = function (e) {\n                    fn_1.call(_this.ws, e);\n                    rs();\n                };\n                _this.ws.onerror = function (e) {\n                    _rj_1.call(_this.ws, e);\n                    rj(e);\n                };\n            });\n            return p_1;\n        }\n        this.uuid = utils_1.uuidv4();\n        this.ws = new WS(\"ws://\" + this.host + \":\" + (this.port || 80) + \"/websocket/\" + this.uuid);\n        this.ws.onerror = console.error;\n        this.ws.onmessage = function (e) {\n            if (typeof WebSocket !== 'function') {\n                _this.handleData(e.data);\n                return;\n            }\n            var reader = new FileReader();\n            reader.onload = function () {\n                var arrayBuffer = reader.result;\n                _this.handleData(new Uint8Array(arrayBuffer));\n            };\n            reader.readAsArrayBuffer(e.data);\n        };\n        var p = new Promise(function (rs, rj) {\n            _this.ws.onopen = rs;\n            _this.ws.onerror = rj;\n        });\n        return p;\n    };\n    RPC.prototype.parse = function (data) {\n        var decoded = rlp.decode(data);\n        var nonce = rlp_1.byteArrayToInt(decoded[0]);\n        var code = rlp_1.byteArrayToInt(decoded[1]);\n        var body = decoded[2];\n        var r = {\n            code: code,\n            nonce: nonce,\n            body: body\n        };\n        switch (code) {\n            case types_1.WS_CODES.TRANSACTION_EMIT: {\n                var h = contract_1.bin2hex(body[0]);\n                var s = rlp_1.byteArrayToInt(body[1]);\n                var ret = r;\n                ret.hash = h;\n                ret.status = s;\n                if (s === types_1.TX_STATUS.DROPPED) {\n                    ret.reason = utils_1.bin2str(body[2]);\n                }\n                if (s === types_1.TX_STATUS.INCLUDED) {\n                    var arr = body[2];\n                    ret.blockHeight = utils_1.toSafeInt(arr[0]);\n                    ret.blockHash = contract_1.bin2hex(arr[1]);\n                    ret.gasUsed = utils_1.toSafeInt(arr[2]);\n                    ret.result = arr[3];\n                    ret.events = arr[4];\n                }\n                return ret;\n            }\n            case types_1.WS_CODES.EVENT_EMIT: {\n                var ret = r;\n                ret.addr = contract_1.bin2hex(body[0]);\n                ret.name = utils_1.bin2str(body[1]);\n                return ret;\n            }\n        }\n        return r;\n    };\n    RPC.prototype.handleData = function (data) {\n        var _this = this;\n        var r = this.parse(data);\n        switch (r.code) {\n            case types_1.WS_CODES.TRANSACTION_EMIT: {\n                var t_1 = r;\n                var funcIds = this.txObservers.get(t_1.hash) || [];\n                funcIds.forEach(function (id) {\n                    var func = _this.callbacks.get(id);\n                    func(t_1);\n                });\n                return;\n            }\n            case types_1.WS_CODES.EVENT_EMIT: {\n                var e_1 = r;\n                var funcIds = this.eventHandlers.get(e_1.addr + \":\" + e_1.name) || [];\n                funcIds.forEach(function (id) {\n                    var func = _this.callbacks.get(id);\n                    func(e_1);\n                });\n                return;\n            }\n        }\n        if (r.nonce) {\n            var fn = this.rpcCallbacks.get(r.nonce);\n            if (fn)\n                fn(r);\n            this.rpcCallbacks.delete(r.nonce);\n        }\n    };\n    /**\n     * \n     */\n    RPC.prototype.__listen = function (contract, event, func) {\n        var addr = utils_1.normalizeAddress(contract.address);\n        var addrHex = contract_1.bin2hex(addr);\n        this.wsRpc(types_1.WS_CODES.EVENT_SUBSCRIBE, addr);\n        var id = ++this.cid;\n        var key = addrHex + \":\" + event;\n        this.id2key.set(id, key);\n        var fn = function (e) {\n            var abiDecoded = contract.abiDecode(event, e.body, 'event');\n            func(abiDecoded);\n        };\n        if (!this.eventHandlers.has(key))\n            this.eventHandlers.set(key, new Set());\n        this.eventHandlers.get(key).add(id);\n        this.callbacks.set(id, fn);\n        return id;\n    };\n    RPC.prototype.listen = function (contract, event, func) {\n        var _this = this;\n        if (func === undefined) {\n            return new Promise(function (rs, rj) {\n                _this.__listen(contract, event, rs);\n            });\n        }\n        utils_1.assert(typeof func === 'function', 'callback should be function');\n        this.__listen(contract, event, func);\n    };\n    /**\n     * \n     * @param {number} id  id\n     */\n    RPC.prototype.removeListener = function (id) {\n        var key = this.id2key.get(id);\n        var h = this.id2hash.get(id);\n        this.callbacks.delete(id);\n        this.id2key.delete(id);\n        this.id2hash.delete(id);\n        if (key) {\n            var set = this.eventHandlers.get(key);\n            set && set.delete(id);\n            if (set && set.size === 0)\n                this.eventHandlers.delete(key);\n        }\n        if (h) {\n            var set = this.txObservers.get(h);\n            set && set.delete(id);\n            if (set && set.size === 0)\n                this.txObservers.delete(h);\n        }\n    };\n    RPC.prototype.listenOnce = function (contract, event, func) {\n        var _this = this;\n        var id = this.cid + 1;\n        if (func === undefined)\n            return this.listen(contract, event).then(function (r) {\n                _this.removeListener(id);\n                return r;\n            });\n        return this.listen(contract, event, function (p) {\n            func(p);\n            _this.removeListener(id);\n        });\n    };\n    /**\n     * \n     */\n    RPC.prototype.__observe = function (_hash, cb) {\n        var _this = this;\n        var hash = contract_1.bin2hex(_hash);\n        var id = ++this.cid;\n        hash = hash.toLowerCase();\n        if (!this.txObservers.has(hash))\n            this.txObservers.set(hash, new Set());\n        this.id2hash.set(id, hash);\n        this.txObservers.get(hash).add(id);\n        var fn = function (r) {\n            cb(r);\n            switch (r.status) {\n                case types_1.TX_STATUS.DROPPED:\n                case types_1.TX_STATUS.CONFIRMED:\n                    _this.removeListener(id);\n                    break;\n            }\n        };\n        this.callbacks.set(id, fn);\n        return id;\n    };\n    /**\n     * \n     */\n    RPC.prototype.viewContract = function (contract, method, parameters) {\n        if (!(contract instanceof contract_2.Contract))\n            throw new Error('create a instanceof Contract by new tool.Contract(addr, abi)');\n        var normalized = contract_2.normalizeParams(parameters);\n        var addr = contract.address;\n        var params = contract.abiEncode(method, normalized);\n        return this.wsRpc(types_1.WS_CODES.CONTRACT_QUERY, [\n            utils_1.normalizeAddress(addr),\n            method,\n            params\n        ]).then(function (r) { return contract.abiDecode(method, r.body); });\n    };\n    /**\n     *  websocket \n     * @param tx \n     */\n    RPC.prototype.sendTransaction = function (tx) {\n        return this.wsRpc(types_1.WS_CODES.TRANSACTION_SEND, [Array.isArray(tx), tx])\n            .then(function () { return Promise.resolve(); });\n    };\n    RPC.prototype.observe = function (tx, status, timeout) {\n        var _this = this;\n        status = status === undefined ? types_1.TX_STATUS.CONFIRMED : status;\n        return new Promise(function (resolve, reject) {\n            var success = false;\n            if (timeout)\n                setTimeout(function () {\n                    if (success)\n                        return;\n                    reject({ reason: 'timeout' });\n                }, timeout);\n            var ret = {};\n            var confirmed = false;\n            var included = false;\n            _this.__observe(tx.getHash(), function (resp) {\n                if (resp.status === types_1.TX_STATUS.DROPPED) {\n                    var e = { hash: resp.hash, reason: resp.reason };\n                    reject(e);\n                    return;\n                }\n                if (resp.status === types_1.TX_STATUS.CONFIRMED) {\n                    if (status === types_1.TX_STATUS.INCLUDED)\n                        return;\n                    confirmed = true;\n                    if (included) {\n                        success = true;\n                        resolve(ret);\n                        return;\n                    }\n                }\n                if (resp.status === types_1.TX_STATUS.INCLUDED) {\n                    included = true;\n                    ret.blockHeight = resp.blockHeight;\n                    ret.blockHash = resp.blockHash;\n                    ret.gasUsed = resp.gasUsed;\n                    if (resp.result && resp.result.length\n                        && tx.__abi\n                        && tx.isDeployOrCall()) {\n                        var decoded = (new contract_2.Contract('', tx.__abi)).abiDecode(tx.getMethod(), resp.result);\n                        ret.result = decoded;\n                    }\n                    if (resp.events &&\n                        resp.events.length\n                        && tx.__abi) {\n                        var events = [];\n                        for (var _i = 0, _a = resp.events; _i < _a.length; _i++) {\n                            var e = _a[_i];\n                            var name_1 = utils_1.bin2str(e[0]);\n                            var decoded = (new contract_2.Contract('', tx.__abi)).abiDecode(name_1, e[1], 'event');\n                            events.push({ name: name_1, data: decoded });\n                        }\n                        ret.events = events;\n                    }\n                    ret.transactionHash = contract_1.bin2hex(tx.getHash());\n                    ret.fee = utils_1.toSafeInt((new BN(tx.gasPrice).mul(new BN(ret.gasUsed))));\n                    if (tx.isDeployOrCall()) {\n                        ret.method = tx.getMethod();\n                        ret.inputs = tx.__inputs;\n                    }\n                    if (status === types_1.TX_STATUS.INCLUDED) {\n                        success = true;\n                        resolve(ret);\n                        return;\n                    }\n                    if (confirmed) {\n                        success = true;\n                        resolve(ret);\n                    }\n                }\n            });\n        });\n    };\n    RPC.prototype.wsRpc = function (code, data) {\n        var _this = this;\n        this.nonce++;\n        var n = this.nonce;\n        var ret = new Promise(function (rs, rj) {\n            _this.rpcCallbacks.set(n, rs);\n        });\n        this.tryConnect()\n            .then(function () {\n            var encoded = rlp.encode([n, code, data]);\n            _this.ws.send(encoded);\n        });\n        return ret;\n    };\n    /**\n     * \n     */\n    RPC.prototype.sendAndObserve = function (tx, status, timeout) {\n        var _this = this;\n        var ret;\n        var sub;\n        if (Array.isArray(tx)) {\n            var arr = [];\n            sub = this.wsRpc(types_1.WS_CODES.TRANSACTION_SUBSCRIBE, tx.map(function (t) { return utils_1.hex2bin(t.getHash()); }));\n            for (var _i = 0, tx_1 = tx; _i < tx_1.length; _i++) {\n                var t = tx_1[_i];\n                arr.push(this.observe(t, status, timeout));\n            }\n            ret = Promise.all(arr);\n        }\n        else {\n            sub = this.wsRpc(types_1.WS_CODES.TRANSACTION_SUBSCRIBE, utils_1.hex2bin(tx.getHash()));\n            ret = this.observe(tx, status, timeout);\n        }\n        return sub\n            .then(function () { return _this.sendTransaction(tx); })\n            .then(function () { return ret; });\n    };\n    /**\n     *  nonce\n     */\n    RPC.prototype.getNonce = function (_pkOrAddress) {\n        var pkOrAddress = utils_1.normalizeAddress(_pkOrAddress);\n        return this.wsRpc(types_1.WS_CODES.ACCOUNT_QUERY, pkOrAddress)\n            .then(function (resp) {\n            return utils_1.toSafeInt(new BN(resp.body[0][2]));\n        });\n    };\n    /**\n     *  \n     */\n    RPC.prototype.getBalance = function (_pkOrAddress) {\n        var pkOrAddress = utils_1.normalizeAddress(_pkOrAddress);\n        return this.wsRpc(types_1.WS_CODES.ACCOUNT_QUERY, pkOrAddress)\n            .then(function (resp) {\n            return utils_1.toSafeInt(new BN(resp.body[0][3]));\n        });\n    };\n    RPC.prototype.close = function () {\n        if (this.ws) {\n            var ws = this.ws;\n            this.ws = null;\n            ws.close();\n        }\n    };\n    return RPC;\n}());\nexports.RPC = RPC;\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/rpc.ts?");

/***/ }),

/***/ "./contract-src/tx.ts":
/*!****************************!*\
  !*** ./contract-src/tx.ts ***!
  \****************************/
/*! flagged exports */
/*! export Transaction [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\n/**\n * \n */\nvar types_1 = __webpack_require__(/*! ./types */ \"./contract-src/types.ts\");\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./contract-src/utils.ts\");\nvar contract_1 = __webpack_require__(/*! ../contract */ \"./contract.js\");\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\nvar rlp = __webpack_require__(/*! ./rlp */ \"./contract-src/rlp.ts\");\nvar nacl = __webpack_require__(/*! ../nacl.min.js */ \"./nacl.min.js\");\nvar contract_2 = __webpack_require__(/*! ./contract */ \"./contract-src/contract.ts\");\nvar Transaction = /** @class */ (function () {\n    /**\n     * constructor of transaction\n     */\n    function Transaction(version, type, nonce, from, gasPrice, amount, payload, to, signature, __abi, __inputs) {\n        this.version = utils_1.dig2str(version || 0);\n        this.type = utils_1.dig2str(type || 0);\n        this.nonce = utils_1.dig2str(nonce || 0);\n        this.from = contract_1.bin2hex(from || '');\n        this.gasPrice = utils_1.dig2str(gasPrice || 0);\n        this.amount = utils_1.dig2str(amount || 0);\n        this.payload = contract_1.bin2hex(payload || '');\n        this.to = contract_1.bin2hex(to || '');\n        this.signature = contract_1.bin2hex(signature || '');\n        this.__abi = __abi;\n        this.__inputs = __inputs;\n    }\n    Transaction.clone = function (o) {\n        return new Transaction(o.version, o.type, o.nonce, o.from, o.gasPrice, o.amount, o.payload, o.to, o.signature);\n    };\n    /**\n     * \n     */\n    Transaction.prototype.getHash = function () {\n        return utils_1.digest(this.getRaw(false));\n    };\n    /**\n     * \n     */\n    Transaction.prototype.getRaw = function (nullSig) {\n        var sig = nullSig ? new Uint8Array(64) : utils_1.hex2bin(this.signature);\n        var p = utils_1.hex2bin(this.payload);\n        return utils_1.concatArray([\n            new Uint8Array([parseInt(this.version)]),\n            new Uint8Array([parseInt(this.type)]),\n            utils_1.padPrefix((new BN(this.nonce)).toArrayLike(Uint8Array, 'be'), 0, 8),\n            utils_1.hex2bin(this.from),\n            utils_1.padPrefix((new BN(this.gasPrice)).toArrayLike(Uint8Array, 'be'), 0, 8),\n            utils_1.padPrefix((new BN(this.amount)).toArrayLike(Uint8Array, 'be'), 0, 8),\n            sig,\n            utils_1.hex2bin(this.to),\n            utils_1.padPrefix((new BN(p.length)).toArrayLike(Uint8Array, 'be'), 0, 4),\n            p\n        ]);\n    };\n    /**\n     * rlp \n     */\n    Transaction.prototype.getEncoded = function () {\n        var arr = this.__toArr();\n        return rlp.encode(arr);\n    };\n    Transaction.prototype.__toArr = function () {\n        return [\n            utils_1.convert(this.version || 0, types_1.ABI_DATA_ENUM.u64),\n            utils_1.convert(this.type || 0, types_1.ABI_DATA_ENUM.u64),\n            utils_1.convert(this.nonce || '0', types_1.ABI_DATA_ENUM.u64),\n            utils_1.convert(this.from || '', types_1.ABI_DATA_ENUM.bytes),\n            utils_1.convert(this.gasPrice || '0', types_1.ABI_DATA_ENUM.u256),\n            utils_1.convert(this.amount || '0', types_1.ABI_DATA_ENUM.u256),\n            utils_1.convert(this.payload || '', types_1.ABI_DATA_ENUM.bytes),\n            utils_1.hex2bin(this.to),\n            utils_1.convert(this.signature || '', types_1.ABI_DATA_ENUM.bytes)\n        ];\n    };\n    /**\n     * \n     */\n    Transaction.prototype.sign = function (_sk) {\n        var sk = utils_1.hex2bin(_sk);\n        sk = utils_1.extendPrivateKey(sk);\n        this.signature = contract_1.bin2hex(nacl.sign(this.getRaw(true), sk).slice(0, 64));\n    };\n    Transaction.prototype.__setInputs = function (__inputs) {\n        var cnv = function (x) {\n            if (x instanceof ArrayBuffer || x instanceof Uint8Array)\n                return contract_1.bin2hex(x);\n            if (x instanceof BN)\n                return utils_1.toSafeInt(x);\n            return x;\n        };\n        if (Array.isArray(__inputs)) {\n            this.__inputs = __inputs.map(cnv);\n        }\n        else {\n            this.__inputs = {};\n            for (var _i = 0, _a = Object.keys(__inputs); _i < _a.length; _i++) {\n                var k = _a[_i];\n                this.__inputs[k] = cnv(__inputs[k]);\n            }\n        }\n        if (Array.isArray(this.__inputs)) {\n            var c = new contract_2.Contract('', this.__abi);\n            var a = c.getABI(this.getMethod(), 'function');\n            if (a.inputsObj()) {\n                this.__inputs = a.toObj(this.__inputs, true);\n            }\n        }\n    };\n    Transaction.prototype.getMethod = function () {\n        var t = parseInt(this.type);\n        return t === types_1.constants.WASM_DEPLOY ? 'init' : utils_1.bin2str((rlp.decode(utils_1.hex2bin(this.payload)))[1]);\n    };\n    Transaction.prototype.isDeployOrCall = function () {\n        var t = parseInt(this.type);\n        return t === types_1.constants.WASM_DEPLOY || t === types_1.constants.WASM_CALL;\n    };\n    return Transaction;\n}());\nexports.Transaction = Transaction;\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/tx.ts?");

/***/ }),

/***/ "./contract-src/types.ts":
/*!*******************************!*\
  !*** ./contract-src/types.ts ***!
  \*******************************/
/*! flagged exports */
/*! export ABI_DATA_ENUM [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ABI_DATA_TYPE_TABLE [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MAX_I64 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MAX_SAFE_INTEGER [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MAX_U256 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MAX_U64 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MIN_I64 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MIN_SAFE_INTEGER [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ONE [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TX_STATUS [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WS_CODES [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ZERO [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export constants [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZERO = exports.ONE = exports.MIN_SAFE_INTEGER = exports.MAX_SAFE_INTEGER = exports.MIN_I64 = exports.MAX_I64 = exports.MAX_U256 = exports.MAX_U64 = exports.ABI_DATA_ENUM = exports.TX_STATUS = exports.constants = exports.WS_CODES = exports.ABI_DATA_TYPE_TABLE = void 0;\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\nexports.ABI_DATA_TYPE_TABLE = ['bool', 'i64', 'u64', 'f64', 'string', 'bytes', 'address', 'u256'];\nvar WS_CODES;\n(function (WS_CODES) {\n    WS_CODES[WS_CODES[\"NULL\"] = 0] = \"NULL\";\n    WS_CODES[WS_CODES[\"EVENT_EMIT\"] = 1] = \"EVENT_EMIT\";\n    WS_CODES[WS_CODES[\"EVENT_SUBSCRIBE\"] = 2] = \"EVENT_SUBSCRIBE\";\n    WS_CODES[WS_CODES[\"TRANSACTION_EMIT\"] = 3] = \"TRANSACTION_EMIT\";\n    WS_CODES[WS_CODES[\"TRANSACTION_SUBSCRIBE\"] = 4] = \"TRANSACTION_SUBSCRIBE\";\n    WS_CODES[WS_CODES[\"TRANSACTION_SEND\"] = 5] = \"TRANSACTION_SEND\";\n    WS_CODES[WS_CODES[\"ACCOUNT_QUERY\"] = 6] = \"ACCOUNT_QUERY\";\n    WS_CODES[WS_CODES[\"CONTRACT_QUERY\"] = 7] = \"CONTRACT_QUERY\";\n})(WS_CODES = exports.WS_CODES || (exports.WS_CODES = {}));\nexports.constants = {\n    DEFAULT_TX_VERSION: 1,\n    WASM_DEPLOY: 16,\n    WASM_CALL: 17,\n};\nvar TX_STATUS;\n(function (TX_STATUS) {\n    TX_STATUS[TX_STATUS[\"PENDING\"] = 0] = \"PENDING\";\n    TX_STATUS[TX_STATUS[\"INCLUDED\"] = 1] = \"INCLUDED\";\n    TX_STATUS[TX_STATUS[\"CONFIRMED\"] = 2] = \"CONFIRMED\";\n    TX_STATUS[TX_STATUS[\"DROPPED\"] = 3] = \"DROPPED\";\n})(TX_STATUS = exports.TX_STATUS || (exports.TX_STATUS = {}));\nvar ABI_DATA_ENUM;\n(function (ABI_DATA_ENUM) {\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"bool\"] = 0] = \"bool\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"i64\"] = 1] = \"i64\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"u64\"] = 2] = \"u64\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"f64\"] = 3] = \"f64\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"string\"] = 4] = \"string\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"bytes\"] = 5] = \"bytes\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"address\"] = 6] = \"address\";\n    ABI_DATA_ENUM[ABI_DATA_ENUM[\"u256\"] = 7] = \"u256\";\n})(ABI_DATA_ENUM = exports.ABI_DATA_ENUM || (exports.ABI_DATA_ENUM = {}));\nexports.MAX_U64 = new BN('ffffffffffffffff', 16);\nexports.MAX_U256 = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);\nexports.MAX_I64 = new BN('9223372036854775807', 10);\nexports.MIN_I64 = new BN('-9223372036854775808', 10);\nexports.MAX_SAFE_INTEGER = new BN(Number.MAX_SAFE_INTEGER);\nexports.MIN_SAFE_INTEGER = new BN(Number.MIN_SAFE_INTEGER);\nexports.ONE = new BN(1);\nexports.ZERO = new BN(0);\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/types.ts?");

/***/ }),

/***/ "./contract-src/utils.ts":
/*!*******************************!*\
  !*** ./contract-src/utils.ts ***!
  \*******************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export address2PublicKeyHash [provided] [no usage info] [missing usage info prevents renaming] */
/*! export assert [provided] [no usage info] [missing usage info prevents renaming] */
/*! export assertAddress [provided] [no usage info] [missing usage info prevents renaming] */
/*! export bin2hex [provided] [no usage info] [missing usage info prevents renaming] */
/*! export bin2str [provided] [no usage info] [missing usage info prevents renaming] */
/*! export bytesToF64 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compareBytes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export concatArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export concatBytes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convert [provided] [no usage info] [missing usage info prevents renaming] */
/*! export dig2str [provided] [no usage info] [missing usage info prevents renaming] */
/*! export digest [provided] [no usage info] [missing usage info prevents renaming] */
/*! export extendPrivateKey [provided] [no usage info] [missing usage info prevents renaming] */
/*! export f64ToBytes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export hex2bin [provided] [no usage info] [missing usage info prevents renaming] */
/*! export inverse [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isBin [provided] [no usage info] [missing usage info prevents renaming] */
/*! export normalizeAddress [provided] [no usage info] [missing usage info prevents renaming] */
/*! export padPrefix [provided] [no usage info] [missing usage info prevents renaming] */
/*! export privateKey2PublicKey [provided] [no usage info] [missing usage info prevents renaming] */
/*! export publicKey2Hash [provided] [no usage info] [missing usage info prevents renaming] */
/*! export publicKeyHash2Address [provided] [no usage info] [missing usage info prevents renaming] */
/*! export rmd160 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export str2bin [provided] [no usage info] [missing usage info prevents renaming] */
/*! export toSafeInt [provided] [no usage info] [missing usage info prevents renaming] */
/*! export trimLeadingZeros [provided] [no usage info] [missing usage info prevents renaming] */
/*! export uuidv4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bin2hex = exports.uuidv4 = exports.bin2str = exports.toSafeInt = exports.inverse = exports.convert = exports.bytesToF64 = exports.padPrefix = exports.f64ToBytes = exports.trimLeadingZeros = exports.str2bin = exports.normalizeAddress = exports.assertAddress = exports.concatBytes = exports.concatArray = exports.extendPrivateKey = exports.publicKeyHash2Address = exports.address2PublicKeyHash = exports.publicKey2Hash = exports.privateKey2PublicKey = exports.compareBytes = exports.dig2str = exports.hex2bin = exports.assert = exports.rmd160 = exports.digest = exports.isBin = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"./contract-src/types.ts\");\nvar nacl = __webpack_require__(/*! ../nacl.min.js */ \"./nacl.min.js\");\nvar RMD160 = (new (__webpack_require__(/*! ../hashes.js */ \"./hashes.js\").RMD160));\nvar _keccak256 = __webpack_require__(/*! ../sha3.js */ \"./sha3.js\").keccak256;\nvar base58_1 = __webpack_require__(/*! ./base58 */ \"./contract-src/base58.ts\");\nvar BN = __webpack_require__(/*! ../bn */ \"./bn.js\");\nRMD160.setUTF8(false);\nvar EMPTY_BYTES = new Uint8Array(0);\nfunction isBin(r) {\n    return r && (r instanceof Uint8Array || r instanceof ArrayBuffer);\n}\nexports.isBin = isBin;\n/**\n *  keccak256\n */\nfunction digest(_msg) {\n    var msg = hex2bin(_msg);\n    var hasher = _keccak256.create();\n    hasher.update(msg);\n    return new Uint8Array(hasher.arrayBuffer());\n}\nexports.digest = digest;\n/**\n * rmd160 \n */\nfunction rmd160(bin) {\n    var o = hex2bin(bin);\n    return hex2bin(RMD160.hex(new FakeString(o)));\n}\nexports.rmd160 = rmd160;\n// rmd  Uint8Array  Uint8Array \nvar FakeString = /** @class */ (function () {\n    function FakeString(u8) {\n        this.u8 = hex2bin(u8);\n        this.length = this.u8.length;\n    }\n    FakeString.prototype.charCodeAt = function (i) {\n        return this.u8[i];\n    };\n    return FakeString;\n}());\nfunction assert(truth, err) {\n    if (!truth)\n        throw new Error(err);\n}\nexports.assert = assert;\n/**\n * \n * decode hex string\n */\nfunction hex2bin(s) {\n    if (s instanceof ArrayBuffer)\n        return new Uint8Array(s);\n    if (s instanceof Uint8Array)\n        return s;\n    if (s.startsWith('0x'))\n        s = s.substr(2, s.length - 2);\n    assert(s.length % 2 === 0, 'invalid char');\n    var ret = new Uint8Array(s.length / 2);\n    for (var i = 0; i < s.length / 2; i++) {\n        var h = s.charCodeAt(i * 2);\n        var l = s.charCodeAt(i * 2 + 1);\n        ret[i] = (hexToInt(h) << 4) + hexToInt(l);\n    }\n    return ret;\n}\nexports.hex2bin = hex2bin;\nfunction hexToInt(x) {\n    if (48 <= x && x <= 57)\n        return x - 48;\n    if (97 <= x && x <= 102)\n        return x - 87;\n    if (65 <= x && x <= 70)\n        return x - 55;\n    return 0;\n}\nfunction dig2str(s) {\n    if (typeof s === 'string') {\n        if (s.startsWith('0x'))\n            s = new BN(s.substr(2), 16);\n        else\n            return s;\n    }\n    return s.toString(10);\n}\nexports.dig2str = dig2str;\n/**\n * \n */\nfunction compareBytes(_a, _b) {\n    var a = hex2bin(_a);\n    var b = hex2bin(_b);\n    if (a.length > b.length)\n        return 1;\n    if (b.length > a.length)\n        return -1;\n    for (var i = 0; i < a.length; i++) {\n        var ai = a[i];\n        var bi = b[i];\n        if (ai > bi)\n            return 1;\n        if (bi > ai)\n            return -1;\n    }\n    return 0;\n}\nexports.compareBytes = compareBytes;\n/**\n * \n */\nfunction privateKey2PublicKey(_privateKey) {\n    var privateKey = hex2bin(_privateKey);\n    if (privateKey.length === 64)\n        privateKey = privateKey.slice(32);\n    var pair = nacl.sign.keyPair.fromSeed(privateKey);\n    return pair.publicKey;\n}\nexports.privateKey2PublicKey = privateKey2PublicKey;\n/**\n * \n */\nfunction publicKey2Hash(_publicKey) {\n    var publicKey = hex2bin(_publicKey);\n    publicKey = digest(publicKey);\n    return rmd160(publicKey);\n}\nexports.publicKey2Hash = publicKey2Hash;\n/**\n * \n */\nfunction address2PublicKeyHash(str) {\n    assert(typeof str === 'string', 'address is string');\n    var r5;\n    if (str.indexOf(\"1\") === 0) {\n        r5 = base58_1.Base58.decode(str);\n    }\n    else {\n        r5 = base58_1.Base58.decode(str.substr(2));\n    }\n    return r5.slice(1, r5.length - 4);\n}\nexports.address2PublicKeyHash = address2PublicKeyHash;\n/**\n * \n */\nfunction publicKeyHash2Address(_hash) {\n    var hash = hex2bin(_hash);\n    var r2 = concatBytes(new Uint8Array([0]), hash);\n    var r3 = digest(digest(hash));\n    var b4 = r3.slice(0, 4);\n    var b5 = concatBytes(r2, b4);\n    return base58_1.Base58.encode(b5);\n}\nexports.publicKeyHash2Address = publicKeyHash2Address;\n/**\n * 32  64\n */\nfunction extendPrivateKey(_sk) {\n    var sk = hex2bin(_sk);\n    if (sk.length === 64)\n        return sk;\n    return concatBytes(sk, privateKey2PublicKey(sk));\n}\nexports.extendPrivateKey = extendPrivateKey;\nfunction concatArray(arr) {\n    var ret = new Uint8Array(0);\n    arr.forEach(function (a) {\n        ret = concatBytes(ret, a);\n    });\n    return ret;\n}\nexports.concatArray = concatArray;\nfunction concatBytes(_x, _y) {\n    var x = hex2bin(_x);\n    var y = hex2bin(_y);\n    var ret = new Uint8Array(x.length + y.length);\n    for (var i = 0; i < x.length; i++) {\n        ret[i] = x[i];\n    }\n    for (var i = 0; i < y.length; i++) {\n        ret[x.length + i] = y[i];\n    }\n    return ret;\n}\nexports.concatBytes = concatBytes;\n/**\n * \n * @param {string} address\n */\nfunction assertAddress(address) {\n    if (typeof address !== 'string')\n        throw new Error('invalid address not a string');\n    if (!address.startsWith('1') && !address.startsWith('WX') && !address.startsWith('WR')) {\n        throw new Error('address should starts with 1, WX or WR');\n    }\n    if (address.startsWith('WX') || address.startsWith('WR'))\n        address = address.substr(2);\n    var _r5 = base58_1.Base58.decode(address);\n    var a = address2PublicKeyHash(address);\n    var c = digest(a);\n    var r3 = digest(c);\n    var b4 = r3.slice(0, 4);\n    var _b4 = _r5.slice(21, 25);\n    if (compareBytes(b4, _b4) != 0) {\n        throw new Error('invalid address ' + address);\n    }\n}\nexports.assertAddress = assertAddress;\n/**\n *  \n * @returns  {Uint8Array}\n */\nfunction normalizeAddress(_addr) {\n    var addr;\n    if ((typeof _addr === 'string' && isHex(_addr)) || _addr instanceof Uint8Array || _addr instanceof ArrayBuffer) {\n        addr = hex2bin(_addr);\n        if (addr.length === 20)\n            return addr;\n        if (addr.length === 32)\n            return publicKey2Hash(addr);\n        throw new Error(\"invalid size \" + addr.length);\n    }\n    // \n    assertAddress(_addr);\n    return address2PublicKeyHash(_addr);\n}\nexports.normalizeAddress = normalizeAddress;\n/**\n * \n * @param {string} hex\n * @returns {boolean}\n */\nfunction isHex(hex) {\n    if (typeof hex === 'string' && hex.startsWith('0x'))\n        hex = hex.substr(2);\n    if (hex.length % 2 !== 0)\n        return false;\n    hex = hex.toLowerCase();\n    for (var i = 0; i < hex.length; i++) {\n        var code = hex.charCodeAt(i);\n        if ((code >= 48 && code <= 57) || (code >= 97 && code <= 102)) {\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n *  utf8 \n * @param str \n */\nfunction str2bin(str) {\n    if (typeof Buffer === 'function')\n        return Buffer.from(str, 'utf-8');\n    if (typeof TextEncoder === 'function')\n        return new TextEncoder().encode(str);\n    throw new Error('encode string to utf8 failed');\n}\nexports.str2bin = str2bin;\nfunction trimLeadingZeros(data) {\n    var k = -1;\n    for (var i = 0; i < data.length; i++) {\n        if (data[i] !== 0) {\n            k = i;\n            break;\n        }\n    }\n    if (k === -1)\n        return new Uint8Array(0);\n    return data.slice(k, data.length);\n}\nexports.trimLeadingZeros = trimLeadingZeros;\nfunction reverse(_arr) {\n    var arr = hex2bin(_arr);\n    var ret = new Uint8Array(arr.length);\n    for (var i = 0; i < arr.length; i++) {\n        ret[i] = arr[arr.length - i - 1];\n    }\n    return ret;\n}\n/**\n * \n */\nfunction f64ToBytes(f) {\n    var _buf = new ArrayBuffer(8);\n    var float = new Float64Array(_buf);\n    float[0] = f;\n    var buf = new Uint8Array(_buf);\n    return trimLeadingZeros(reverse(buf));\n}\nexports.f64ToBytes = f64ToBytes;\n/**\n * pad prefix to size\n */\nfunction padPrefix(arr, prefix, size) {\n    if (arr.length >= size)\n        return arr;\n    var ret = new Uint8Array(size);\n    for (var i = 0; i < ret.length; i++) {\n        ret[i + size - arr.length] = arr[i];\n    }\n    if (prefix === 0)\n        return ret;\n    for (var i = 0; i < size - arr.length; i++)\n        ret[i] = prefix;\n}\nexports.padPrefix = padPrefix;\n/**\n * \n * @param {Uint8Array} buf\n */\nfunction bytesToF64(buf) {\n    return new Float64Array(padPrefix(reverse(buf), 0, 8).buffer)[0];\n}\nexports.bytesToF64 = bytesToF64;\nfunction convert(o, type) {\n    if (o instanceof Uint8Array || o instanceof ArrayBuffer) {\n        switch (type) {\n            case types_1.ABI_DATA_ENUM.bool:\n            case types_1.ABI_DATA_ENUM.u256:\n            case types_1.ABI_DATA_ENUM.i64:\n            case types_1.ABI_DATA_ENUM.u64:\n            case types_1.ABI_DATA_ENUM.f64: {\n                throw new Error('cannot convert uint8array to u64, u256 or bool');\n            }\n            case types_1.ABI_DATA_ENUM.string: {\n                throw new Error('cannot convert uint8array to string');\n            }\n            case types_1.ABI_DATA_ENUM.bytes:\n                return hex2bin(o);\n            case types_1.ABI_DATA_ENUM.address:\n                return normalizeAddress(o);\n        }\n        throw new Error(\"unexpected abi type \" + type);\n    }\n    if (typeof o === 'string') {\n        switch (type) {\n            case types_1.ABI_DATA_ENUM.u256:\n            case types_1.ABI_DATA_ENUM.u64: {\n                var ret = void 0;\n                if (o.substr(0, 2) === '0x') {\n                    ret = new BN(o.substr(2, o.length - 2), 16);\n                }\n                else {\n                    ret = new BN(o, 10);\n                }\n                if (type === types_1.ABI_DATA_ENUM.u64)\n                    assert(ret.cmp(types_1.MAX_U64) <= 0 && !ret.isNeg(), ret.toString(10) + \" overflows max u64 \" + types_1.MAX_U64.toString(10));\n                if (type === types_1.ABI_DATA_ENUM.u256)\n                    assert(ret.cmp(types_1.MAX_U256) <= 0 && !ret.isNeg(), ret.toString(10) + \" overflows max u256 \" + types_1.MAX_U256.toString(10));\n                return ret;\n            }\n            case types_1.ABI_DATA_ENUM.i64: {\n                if (o.substr(0, 2) === '0x') {\n                    var ret = new BN(o.substr(2, o.length - 2), 16);\n                    assert(ret.cmp(types_1.MAX_I64) <= 0, ret.toString(10) + \" overflows max i64 \" + types_1.MAX_I64.toString(10));\n                    assert(ret.cmp(types_1.MIN_I64) >= 0, ret.toString(10) + \" overflows min i64 \" + types_1.MIN_I64.toString(10));\n                    return ret;\n                }\n                return convert(parseInt(o), types_1.ABI_DATA_ENUM.i64);\n            }\n            case types_1.ABI_DATA_ENUM.f64: {\n                var f = parseFloat(o);\n                return f64ToBytes(f);\n            }\n            case types_1.ABI_DATA_ENUM.string: {\n                return o;\n            }\n            case types_1.ABI_DATA_ENUM.bool: {\n                var l = o.toLowerCase();\n                if ('true' === l)\n                    return types_1.ONE;\n                if ('false' === l)\n                    return types_1.ZERO;\n                // @ts-ignore\n                if (isNaN(o))\n                    throw new Error(\"cannot convert \" + o + \" to bool\");\n                var ln = parseInt(o);\n                if (1 === ln || 0 === ln)\n                    return l;\n                throw new Error(\"convert \" + l + \" to bool failed, provide 1 or 0\");\n            }\n            case types_1.ABI_DATA_ENUM.bytes:\n                return hex2bin(o);\n            case types_1.ABI_DATA_ENUM.address: {\n                return normalizeAddress(o);\n            }\n        }\n        throw new Error(\"unexpected abi type \" + type);\n    }\n    if (typeof o === 'number') {\n        switch (type) {\n            case types_1.ABI_DATA_ENUM.u256:\n            case types_1.ABI_DATA_ENUM.u64: {\n                if (o < 0 || !Number.isInteger(o))\n                    throw new Error('o is negative or not a integer');\n                return new BN(o);\n            }\n            case types_1.ABI_DATA_ENUM.string: {\n                return o.toString(10);\n            }\n            case types_1.ABI_DATA_ENUM.bool: {\n                if (1 === o || 0 === o)\n                    return 1 === o ? types_1.ONE : types_1.ZERO;\n                throw new Error(\"convert \" + o + \" to bool failed, provide 1 or 0\");\n            }\n            case types_1.ABI_DATA_ENUM.bytes:\n            case types_1.ABI_DATA_ENUM.address: {\n                throw new Error(\"cannot convert number to address or bytes\");\n            }\n            case types_1.ABI_DATA_ENUM.i64: {\n                if (!Number.isInteger(o))\n                    throw new Error('o is negative or not a integer');\n                if (o >= 0)\n                    return new BN(o);\n                return convert(new BN(o), types_1.ABI_DATA_ENUM.i64);\n            }\n            case types_1.ABI_DATA_ENUM.f64: {\n                return f64ToBytes(o);\n            }\n        }\n        throw new Error(\"unexpected abi type \" + type);\n    }\n    if (o instanceof BN) {\n        switch (type) {\n            case types_1.ABI_DATA_ENUM.u256:\n            case types_1.ABI_DATA_ENUM.u64: {\n                if (o.isNeg())\n                    throw new Error(\"cannot convert negative \" + o.toString() + \" to uint\");\n                return o;\n            }\n            case types_1.ABI_DATA_ENUM.string: {\n                return o.toString(10);\n            }\n            case types_1.ABI_DATA_ENUM.bytes:\n            case types_1.ABI_DATA_ENUM.address: {\n                throw new Error(\"cannot convert big number to address or bytes\");\n            }\n            case types_1.ABI_DATA_ENUM.bool: {\n                if (o.cmp(new BN(1)) === 0 || o.cmp(new BN(0)) === 0)\n                    return o;\n                throw new Error(\"convert \" + o + \" to bool failed, provide 1 or 0\");\n            }\n            case types_1.ABI_DATA_ENUM.i64: {\n                assert(o.cmp(types_1.MAX_I64) <= 0, o.toString(10) + \" overflows max i64 \" + types_1.MAX_I64.toString(10));\n                assert(o.cmp(types_1.MIN_I64) >= 0, o.toString(10) + \" overflows min i64 \" + types_1.MIN_I64.toString(10));\n                if (o.cmp(new BN(0)) >= 0)\n                    return o;\n                var buf = o.neg().toArrayLike(Uint8Array, 'be', 8);\n                buf = inverse(buf);\n                return new BN(buf).add(types_1.ONE);\n            }\n            case types_1.ABI_DATA_ENUM.f64: {\n                return f64ToBytes(o.toNumber());\n            }\n        }\n        throw new Error(\"unexpected abi type \" + type);\n    }\n    if (typeof o === 'boolean') {\n        switch (type) {\n            case types_1.ABI_DATA_ENUM.u256:\n            case types_1.ABI_DATA_ENUM.i64:\n            case types_1.ABI_DATA_ENUM.u64: {\n                return o ? types_1.ONE : types_1.ZERO;\n            }\n            case types_1.ABI_DATA_ENUM.string: {\n                return o.toString();\n            }\n            case types_1.ABI_DATA_ENUM.bytes:\n            case types_1.ABI_DATA_ENUM.address: {\n                throw new Error(\"cannot convert boolean to address or bytes\");\n            }\n            case types_1.ABI_DATA_ENUM.bool: {\n                return o ? types_1.ONE : types_1.ZERO;\n            }\n            case types_1.ABI_DATA_ENUM.f64: {\n                return f64ToBytes(o ? 1 : 0);\n            }\n        }\n        throw new Error(\"unexpected abi type \" + type);\n    }\n    throw new Error(\"unexpected type \" + o);\n}\nexports.convert = convert;\n/**\n * \n */\nfunction inverse(arr) {\n    var ret = new Uint8Array(arr.length);\n    for (var i = 0; i < ret.length; i++) {\n        ret[i] = (~arr[i] & 0xff);\n    }\n    return ret;\n}\nexports.inverse = inverse;\nfunction toSafeInt(x) {\n    var bn;\n    if (typeof x === 'number')\n        return x;\n    if (typeof x === 'string') {\n        var hex = x.startsWith('0x');\n        x = hex ? x.substr(2, x.length - 2) : x;\n        bn = new BN(x, hex ? 16 : 10);\n    }\n    if (x instanceof ArrayBuffer || x instanceof Uint8Array) {\n        var arr = x instanceof ArrayBuffer ? new Uint8Array(x) : x;\n        bn = new BN(arr);\n    }\n    if (x instanceof BN)\n        bn = x;\n    if (bn.cmp(types_1.MAX_SAFE_INTEGER) <= 0 && bn.cmp(types_1.MIN_SAFE_INTEGER) >= 0)\n        return bn.toNumber();\n    return x.toString(10);\n}\nexports.toSafeInt = toSafeInt;\n/**\n * decode binary as utf8 string\n */\nfunction bin2str(_bin) {\n    if (typeof _bin === 'string')\n        return _bin;\n    var bin = hex2bin(_bin);\n    if (typeof TextDecoder === 'function')\n        return new TextDecoder().decode(bin);\n    if (typeof Buffer === 'function')\n        return Buffer.from(bin).toString('utf8');\n    throw new Error('bin2str failed');\n}\nexports.bin2str = bin2str;\nfunction uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\nexports.uuidv4 = uuidv4;\nfunction bin2hex(s) {\n    if (typeof s === 'string' && s.startsWith('0x')) {\n        s = s.substr(2);\n        assert(isHex(s), 'hex string');\n        return s;\n    }\n    if (!(s instanceof ArrayBuffer) &&\n        !(s instanceof Uint8Array) &&\n        !Array.isArray(s))\n        throw new Error(\"input \" + s + \" is not ArrayBuffer Uint8Array or Buffer and other array-like \");\n    if (!(s instanceof Uint8Array))\n        s = new Uint8Array(s);\n    // input maybe Buffer or Uint8Array\n    if (typeof Buffer === 'function')\n        return Buffer.from(s).toString('hex');\n    return Array.prototype.map.call(s, function (x) { return ('00' + x.toString(16)).slice(-2); }).join('');\n}\nexports.bin2hex = bin2hex;\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./contract-src/utils.ts?");

/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 3:0-14 */
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack://keystore_wdc_contract/./node_modules/ws/browser.js?");

/***/ }),

/***/ "?e7a9":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://keystore_wdc_contract/buffer_(ignored)?");

/***/ }),

/***/ "?df8b":
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://keystore_wdc_contract/child_process_(ignored)?");

/***/ }),

/***/ "?8465":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://keystore_wdc_contract/crypto_(ignored)?");

/***/ }),

/***/ "?d356":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://keystore_wdc_contract/http_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./contract-src/index.ts");
/******/ })()
;
});